---
title: "(JUC) Java并发面试题笔记"
date: 2025-03-05T21:45:49+08:00
lastmod: 2025-03-05T21:45:49+08:00
author: ["SwimmingLiu"]

categories:
- 💻 Job

tags:
- Java
- JUC

keywords:
- Java
- JUC

description: "" # 文章描述，与搜索优化相关
summary: "" # 文章简单描述，会展示在主页
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
math: true
draft: false # 是否为草稿
comments: true
showToc: true # 显示目录
TocOpen: false # 自动展开目录
autonumbering: true # 目录自动编号
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
searchHidden: false # 该页面可以被搜索到
showbreadcrumbs: true #顶部显示当前路径
mermaid: true
cover:
    image: ""
    caption: ""
    alt: ""
    relative: false
---

## 1. 什么是 Java 内存模型（JMM）？

`JMM` 是 Java内存模型 ， 它是Java虚拟机 `JVM` 定义的一种规范，用于描述多线程程序中的变量，像实例字段、静态字段和数组元素，他们如何在内存中存储和传递的规则。也就是规定线程啥时候从住内存里面读数据，啥时候把数据写回到住内存。`JMM` 的核心目标是确保多线程环境下的**可见性**、**有序性**和**原子性**, 避免硬件和编译器优化带来的不一致问题。

**【可见性、有序性、原子性定义】**

- **可见性**：确保一个线程对共享变量的修改，能够及时被另外一个线程看到。 `volatile`就是用来保证可见性的，强制线程每次读写的时候，直接从主内存当中获取最新值。
- **有序性**：指线程执行操作的顺序。JMM允许某些指令重排序之后再提高性能，但会保证线程内的操作顺序不会被破坏。通过`happens-before` (线程A发生在线程B之前)的关系来保证跨线程的有序性。
- **原子性**：操作不可分割，线程不会在执行的过程当中被打断。例如, `synchronize` 关键字能确保方法或代码块的原子性

**【JMM作用】**

因为不同的操作系统都有一套独立的内存模型，但是Java为了满足跨平台的特性，它需要定义一套内存模型屏蔽个操作系统之间的差异。我们可以利用JMM当中定义好的从Java源码到CPU指令的执行规范，也就是使用`synchronized` 、`volatile` 等关键字，还有`happens-before`原则，就可以写出并发安全的代码了。
比如说，线程A和线程B同时操作 `变量-1`，假如最开始`变量-1` 是 `0`

- 首先，线程A和线程B都读取了`变量-1`
- 然后，线程B对取到的`变量-1`自增为`1`，并写回主内存
- 此时，线程A对读取到的`变量-1`也自增`1`，并写回主内存。这就会导致线程B的操作失效了，出现并发安全问题。

如果有JMM，我们就可以在线程A要修改数据之前,让它采用CAS乐观锁的方式进行修改。再次去读主内存当中的值，然后修改之后，再判断一下主内存的值是否发生变化。如果没有发生变化，就写回主内存。如果发生变化，就要进行自旋。

**【注意】** 工作内存是每个线程独立的内存空间，其他线程都是看不到的。主内存是Java堆内存的一部分，所有的实例变量、静态变量和数组元素都存储在主内存当中。

![JMM架构图](https://oss.swimmingliu.cn/49ddf552-f9c8-11ef-99c5-c858c0c1deba)

**【内存间交互操作类型 (8种原子操作)】**

1. **lock 上锁**：把一个变量表示为一条线程独占的状态
2. **unlock 解锁**： 把一个变量从独占状态中释放出来，释放后的变量才能被其他线程锁定
3. **read 读取**： 从主内存当中读取一个变量到工作内存中
4. **load 载入**：把`read`操作从主内存中得到的变量值放入工作内存的变量副本当中
5. **use 使用**：把工作内存当中的一个变量值传递给执行引擎
6. **assign 赋值**：把一个从执行引擎接收到的值赋给工作内存中的变量
7. **store 存储**：把工作内存中的一个变量的值传送给主内存中
8. **write 写入**：把store操作从工作内存中得到的变量值放入主内存的变量中

**【volatile 特殊规则】**

- **可见性**：对于 `volatile` 修饰的变量的写操作会立即刷新到内存中，任何线程对这个`volatile` 变量的读操作都能立即看到最新的值。
- **禁止指令重排序**： 在对 `volatile` 变量进行读/写操作的时候，会插入内存屏障，禁止指令重排序。也就是该变量的写操作不能与之前的读/写操作重排序，它的都操作不能与之后的读/写操作重排序。

**【Happens-Before 原则】**

见下一个问题

## 2. 什么是Java的 happens-before 规则?

`happens-before` 原则就是 `JMM` 当中定义操作间顺序的规则，确保操作的有序性和可见性。

1. **程序次序规则**：线程当中所有操作都是按程序代码的顺序发生
2. **监视器锁规则**：解锁操作发生在同一个锁的随后的加锁操作之前，说白了，先解锁，后上锁
3. **`volatile` 变量规则**： `volatile` 变量的写操作发生在对改变量随后的读操作之前，先写后读
4. **线程启动规则**：线程A对线程B的`Thread.start()` 调用发生在这个新线程的每一个操作之前
5. **线程终止规则**：线程A所有的操作都发生在其他线程检测到线程A终止之前
6. **线程中断规则**：对线程的中断操作 (`Thread.interrupt()`) 发生在被中断线程检测到的中断时间之前 (通过`Thread.interrupted()` 或 `Thread.isInterrupted()` 进行检测)
7. **对象终结规则**： 一个对象的构造函数执行结束发生在这个对象的`finalize()` 方法之前
8. **传递性**： 如果A `happens-before` B，B `happens-before` C, 则 A `happens-before` C

## 3.  Java 的 synchronized 是怎么实现的？

**【实现原理】** 

`synchronized` 关键字是以来 `JVM` 的Monitor (监视器锁)和 Object Header (对象头) 实现的。其中，重量级所依赖于 `Monitor` 监视器锁， 轻量级锁和偏向锁都依赖于对象头 (Object Header)

**【不同使用场景的区别】**

- **修饰方法**：会在修饰的方法的访问标志中增加一个 `ACC_SYNCHRONIZED` 标志，每当有一个线程访问该方法时， JVM回去检测该方法的访问标志。如果包含`ACC_SYNCHRONIZED` 标志， 线程必须获得该方法对应的对象监视器锁 (对象锁)，也就是`Monitor` 当中的`owner`执行该线程。 然后再执行该方法，保持同步性。
- **修饰代码块**：在代码块的前后分别插入 `monitorenter` 和 `monitorexit` 字节码指令， 可以理解为加锁和解锁

**【可重入性】** 

`synchronized` 是可以重入的，每次获取一次锁。如果是当前线程的锁，计数器加`1`，锁释放的时候，计数器减`1`。直到计数器减为 `0` 为止，锁才真正释放

**【`synchronized` 锁升级】**

`synchronized` 锁分为三种，偏向锁，轻量级锁，重量级锁。其升级次序为偏向锁(一个线程) -> 轻量级锁 (多个线程) -> 重量级锁 (多个线程竞争激烈)

![Synchronized对象头](https://oss.swimmingliu.cn/4a286ce8-f9c8-11ef-b127-c858c0c1deba)

- **偏向锁**：当有线程第一次获取锁的时候， `JVM` 会采用修改锁对象的对象头，将该线程标记为偏向状态。对象头里面会记录线程`ID` 和 对应的`epoch` 偏向锁版本。后续该线程再获取锁，基本没啥开销。
- **轻量级锁**：当有另外的线程尝试去获取已经被偏向的锁时，锁会升级为轻量级锁。使用CAS操作来减少锁竞争的开销。
- **重量级锁**：当CAS失败无法获取锁的时候，JVM判定其为多个线程竞争锁激烈。锁会升级成为重量锁，线程会被挂起直到释放。线程会被放入Monitor的owner当中

![Monitor结构](https://oss.swimmingliu.cn/4a41e56d-f9c8-11ef-8eab-c858c0c1deba)

**【锁消除和锁粗化】**

- **锁消除**：JVM判断对象是否只在当前线程使用，如果只在当前线程使用，则消除不必要加的锁
- **锁粗化**：多个锁频繁操作出现时，JVM会将这些锁操作合并，见锁获取和释放的开销。