---
title: "JVM 面试题笔记"
date: 2025-03-23T21:45:49+08:00
lastmod: 2025-03-23T21:45:49+08:00
author: ["SwimmingLiu"]

categories:
- 💻 Job

tags:
- Java
- JVM

keywords:
- Java
- JVM

description: "" # 文章描述，与搜索优化相关
summary: "" # 文章简单描述，会展示在主页
weight: # 输入1可以顶置文章，用来给文章展示排序，不填就默认按时间排序
slug: ""
math: true
draft: false # 是否为草稿
comments: true
showToc: true # 显示目录
TocOpen: false # 自动展开目录
autonumbering: true # 目录自动编号
hidemeta: false # 是否隐藏文章的元信息，如发布日期、作者等
disableShare: true # 底部不显示分享栏
searchHidden: false # 该页面可以被搜索到
showbreadcrumbs: true #顶部显示当前路径
mermaid: true
cover:
    image: ""
    caption: ""
    alt: ""
    relative: false
---

# JVM 面试题笔记

## 1. JVM 的内存区域是如何划分的？

`JVM` 内存当中，运行时数据的区域包含堆、方法区（元空间）、虚拟机栈、本地方法栈、程序计数器。另外，其他的内存区域属于本地内存，本地内存就包括直接内存，直接内存是非运行时数据区的一部分。
其中，堆和方法区（元空间） 是线程共享的，虚拟机栈、本地方法栈、程序计数器都是线程私有的。

**【注意】** `JVM` 规范对于运行时数据区域的规定是很宽松的。就拿堆来说，堆可以是连续空间，也可以是不连续空间。堆的大小可以固定，也可以再运行时按照需求进行扩展。虚拟机实现者可以使用任何**垃圾回收算法**管理堆，甚至完全不进行垃圾回收也是可以的。

![JVM内存区域](https://oss.swimmingliu.cn/6ebff0fa-07e8-11f0-86bd-c858c0c1debd)

下面逐一介绍不同部分的功能和作用

首先是线程私有的部分，**程序计数器**、**虚拟机栈**、**本地方法栈**。

**【程序计数器】**

- **定义**：程序计数器就是记录当前所执行的字节码的行号。字节码解释器通过改变程序计数器的值，来选取下一条需要执行的字节码指令。它的生命周期随着线程的创建而创建，随着线程的结束而死亡。
- **作用**：分支、循环、跳转、异常处理、线程恢复这些功能都需要依赖程序计数器完成。比如线程切换上下文中，从 `A线程` 先切换到 `B线程`，然后从 `B线程` 恢复到 `A线程` 的过程当中，为了 `A线程` 能够恢复到正确的执行位置，就需要读取 `A线程` 程序计数器的值，来确认切换线程前执行的位置在哪里。
- **为什么是线程私有**：因为线程切换的过程当中，每个线程都需要一个程序计数器来记录自己的程序执行位置。

**【注意】** 程序计数器是唯一一个不会出现 `OOM` 内存不足的内存区域，因为他就只是存储一个值。

**【虚拟机栈】**

- **定义**：虚拟机栈按照先进后出的方案存储的是非本地方法的调用对应的**栈帧**。每一次方法调用的时候会被压入栈中，方法结束的时候会被弹出栈中。栈帧中包含**局部变量表**、**操作次数栈**（存储操作数和临时计算结果）、**动态链接**、**方法的返回地址**。虚拟机的生命周期随着线程的创建而创建，随着线程的结束而死亡。
- **作用**：存储非本地方法的栈帧，支持方法的调用和返回。当栈深度超过虚拟机允许的最大深度，会抛出 `StackOverflowError` 栈溢出异常。如果虚拟机栈无法动态扩展或申请到足够的内存，会抛出 `OutOfMemoryError` 内存不足异常。

![JVM-虚拟机栈-完整结构](https://oss.swimmingliu.cn/6f22fcdc-07e8-11f0-92ef-c858c0c1debd)

栈帧中包含**局部变量表**、**操作次数栈**（存储操作数和临时变量）、**动态链接**、**方法的返回地址**。其中，局部变量表存放的是所有的局部变量，或者其出对应的地址（数组）。动态链接就是当前类常量池的引用。

- **局部变量表**：存放**方法参数传入的形参值**，**方法内的局部变量**、**方法的 `this` 引用**。内部结构主要存放了编译期可知的各种数据类型（`boolean`、`byte`、`char`、`short`、`int`、`float`、`long`、`double`）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针）
- **操作数栈**：主要作为**方法调用的中转站**使用，用于存放**方法执行过程中**产生的**中间计算结果**。另外，**计算过程中产生的临时变量**也会放在操作数栈中。
- **动态链接**：主要作用是实现在**当前方法中调用其他方法**。 `Class` 文件的常量池里面保存有大量的符号引用，比如方法的符号引用。 当一个方法需要调用其他方法，需要将常量池中只想方法的符号引用转换为在内存地址当中的直接引用。动态链接的作用就是**把常量池的符号引用转换为内存当中的直接引用**。

**【本地方法栈】**

- **定义**：本地方法栈和虚拟栈的结构是一样的。不同的是，本地方法栈是 `JVM` 调用 `Native` 方法的时候才会用到的，虚拟机栈是执行 `Java` 自身的方法 (也就是字节码) 会用到的。
- **作用**：存储本地方法 (`Native`) 栈帧，支持方法的调用和返回。

**【注意】** 在 `HotSpot` 虚拟机当中，将本地方法栈和虚拟机栈合二为一了。

其次，我们将介绍线程共享的部分，**堆** 和 **方法区 （`JDK 1.8`叫元空间）**

**【堆】**

- **定义**：堆当中存储了**所有的对象实例**、**数组**。堆是 `JVM` 内存区域当中最大的一块，所有线程均可共享。另外，`JVM` 的堆**是垃圾收集器**管理的**主要区域**，因此也被称作 **GC 堆（Garbage Collected Heap）**
- **堆结构**：从垃圾回收的角度，堆可以分为**新生代**、**老年代**、**永久代**。其中，新生代当中还包括了一个 `Eden` 伊甸园区 和 两个 `Survivor` 存活区 (`S0` 和 `S1`) 。在 `JDK 1.8` 当中，永久代已经被元空间取代了，而且元空间用得是本地内存。

![JVM-堆结构](https://oss.swimmingliu.cn/6f5466c7-07e8-11f0-91c4-c858c0c1debd)

- **不同代的区别**：大部分情况下，对象会分先分到新生代的 `Eden` 区域，在一次新生代垃圾回收之后，如果对象还存货，则进入 `Survivor` 区中的 `s0` 或者 `s1`。同时，对象的年龄还会增加 `1`  (从 `Eden` 区到 `Survior` 区后，对象的初始年龄变为 `1`)。当它的年龄达到一定阈值 (默认为 `15` 岁)，就会从新生代晋升到老年代。年龄的阈值可以通过 `XX:MaxTenuringThreshold` 来设置，但是设置的值必须在 `0 ~ 15` 之间，不然会报错。
- **为什么年龄只能是 0-15?**: 因为记录**对象年龄的区域**在**对象头**中，这个区域的大小通常是 **`4` 位**。这 4 位可以表示的最大二进制数字是 `1111` ，即十进制的 `15` 。因此，对象的年龄被限制为 `0 ~ 15`。
  在`Hotspot` 虚拟机中，遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的**某个年龄大小**超过了 **`Survivor` 区的一半**时，取这个年龄和 `MaxTenuringThreshold` 中**更小**的一个值，作为新的晋升年龄阈值

**【注意】** `JVM` 的堆 最容易出现的就是 `OutOfMemoryError` 内存不足错误，并且出现这种错误之后的表现形式还会有好几种。比如 `java.lang.OutOfMemoryError: GC Overhead Limit Exceeded` 说明 `JVM` 花太多时间 ( **`98%` 的时间**) 进行垃圾回收并且只回收了很少的垃圾 (**`2%` 的垃圾**); `java.lang.OutOfMemoryError: Java heap space` 是在创建新对象的时候，堆内存中空间不足，不能再存放新创建的对象了。

**【方法区】**

- **定义**：当虚拟机要使用一个类的时候，它需要读取并解析 `Class` 文件并获取相关信息，再将信息存入方法区。方法区存储被 `JVM` 加载的 **类信息**、**字段信息**、**方法信息**、**常量**、**静态变量**、**`JIT` 即时编译器编译后的代码缓存**等数据

- **方法区和永久代以及元空间是什么关系？**：方法区和永久代以及元空间的关系，特别像 `Java` 当中的接口和类的关系，类实现了接口。类就相当于永久代或者元空间，接口就是方法区。也就是说永久代或者元空间是 `HotSpot` 虚拟机对方法区的两种实现方式。 `JDK 1.7` 是 永久代， `JDK 1.8` 之后是方法区。

  ![方法区-永久代和元空间](https://oss.swimmingliu.cn/6f7881dd-07e8-11f0-9839-c858c0c1debd)

- **为什么`JDK 1.8` 采用元空间替换永久代？**

  - **无法动态调整大小，容易内存溢出**：整个永久代的大小受 `JVM` 内存大小的限制，而元空间用的是本地内存，元空间的大小和本机可用内存大小相关。虽然元空间还是可能出现内存溢出，但是比原来的几率更小。

    > 可以使用 `-XX：MaxMetaspaceSize` 标志设置最大元空间大小，默认值为 `unlimited`，这意味着它只受系统内存的限制。`-XX：MetaspaceSize` 调整标志定义元空间的初始大小如果未指定此标志，则元空间将根据运行时的应用程序需求动态地重新调整大小。

  - **元空间加载的类更多**：元空间存放的是类的元数据，所以加载类的元数据不再受 `MaxPermSize`  控制 (永久代的最大阈值) ，而是由系统的实际可用空间来进行控制的，这样加载的类就更多了。

  - **永久代 `GC` 复杂度更高**：永久代会为 `GC` 带来不必要的复杂度，并且回收效率偏低。

- **方法区常用参数有哪些？**： 可以分为 `JDK 1.7` 和 `JDK 1.8` 来看

  - **JDK 1.7**: 采用永久代，常用下面的参数

    ```java
    -XX:PermSize=N //方法区 (永久代) 初始大小
    -XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen
    ```

  - **JDK 1.8**：采用元空间，常用下面的参数

    ```java
    -XX:MetaspaceSize=N //设置 Metaspace 的初始（和最小大小）
    -XX:MaxMetaspaceSize=N //设置 Metaspace 的最大大小, 默认值为 unlimited
    ```

下面将对运行时常量池 （方法区）、字符串常量池 （堆）、直接内存进行介绍

**【运行时常量池】**

运行时常量池是用来存放编译期间生成的各种**字面量**和**符号引用**的常量池表。这个常量池表会在类加载之后，存放到方法区的运行时常量池当中。

- **字面量**：顾名思义，包括整数、浮点数、字符串等字面量
- **符号引用**：类符号引用、字段符号引用、方法符号引用、接口方法符号

**【字符串常量池】**

字符串常量池是 `JVM` 为了提升性能和减少内存消耗专门针对字符串 `String` 类开辟的一块区域，主要是用来避免字符串的重复创建。

```java
// 在字符串常量池中创建字符串对象 "ab"
// 将字符串对象 "ab" 的引用赋值给给 aa
String aa = "ab";
// 直接返回字符串常量池中字符串对象"ab"，赋值给引用 bb
String bb = "ab";
System.out.println(aa==bb); // true, aa和bb都是用的字符串常量池中的"ab"
```

`JDK 1.6` 和 `JDK 1.7` 中，字符串常量池的存放位置不一致。在 `JDK 1.6` 中和 运行时常量池一样，存放在方法区里面。在 `JDK 1.7`  中，存放在堆里面。那么 `JDK 1.7` 为什么要将字符串常量池移动到堆中呢？
主要是因为永久代 (方法区) 的 `GC` 回收效率太低， 只有在整堆收集 `Full GC` 的时候，才会被执行 `GC`。 `Java` 程序中通常会有大量的被创建的字符串等待回收，将这些字符串常量池存放在堆中，能够更高效及时地回收字符串内存。

![方法区-结构图-jdk1.6和jdk1.7对比](https://oss.swimmingliu.cn/6f8e05a3-07e8-11f0-9a6e-c858c0c1debd)

**【直接内存】**

直接内存是一种特殊的内存缓冲区，并不属于 `JVM` 当中的堆或者方法区，而是通过 `JNI` （Java Native Interface）`Java` 本地方法接口的方式在本地内存上直接分配的一块区域。直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 `OutOfMemoryError` 错误出现。

> JDK1.4 中新加入的 NIO（Non-Blocking I/O，也被称为 New I/O），引入了一种基于通道（Channel）与缓存区（Buffer）的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 `DirectByteBuffer` 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆之间来回复制数据。

## 2. HotSpot 对象的创建过程

在 `HotSpot` 虚拟机当中，对象的创建过程如下：

1. **类加载检查**：虚拟机遇到一条 `new` 指令时，首先将去检查这个**指令的参数**是否能在**常量池**中定位到**这个类的符号引用**，并且检查这个**符号引用代表的类**是否已**被加载过、解析和初始化过**。如果没有，那必须先执行相应的**类加载过程**。

2. **分配内存**：在类加载检查通过后，接下来 `JVM` 将为**新生对象分配内存。**对象所需的**内存大小**在**类加载完成**后便可确定，为对象分配空间的任务等同于**把一块确定大小的内存从 `Java` 堆中划分出来**。分配方式有 **“指针碰撞”** 和 **“空闲列表”** 两种，选择哪种分配方式由 `Java` 堆是否规整决定，而  **`Java` 堆是否规整**又由所采用的**垃圾收集器是否带有压缩整理功能决定**。

   - **指针碰撞**： 
     - 适用场合：**堆内存规整（即没有内存碎片）**的情况下。
     - 原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。
     - 使用该分配方式的 GC 收集器：**Serial**, **ParNew**

   - **空闲列表**： 
     - 适用场合：堆内存不规整的情况下。
     - 原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。
     - 使用该分配方式的 GC 收集器：**CMS**

3. **初始化零值**：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为**零值**（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以**不赋初始值**就**直接使用**，程序能访问到这些字段的数据类型所对应的零值。

4. **设置对象头**：初始化零值完成之后，虚拟机要对**对象**进行必要的设置，例如这个对象是**哪个类的实例**、**如何才能找到类的元数据信息**、**对象的哈希值**、**对象的 GC 分代年龄等信息**。 这些信息存放在**对象头**中。 另外，根据虚拟机当前运行状态的不同，如**是否启用偏向锁**等，对象头会有不同的设置方式。

5. **执行 `init` 方法**：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

**【对象的内存布局】**

在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：**对象头（Header）**、**实例数据（Instance Data）**和 **对齐填充（Padding）**。

- **对象头**： 对象头主要包含**标记字段**和**类型指针**两个部分
  - **标记字段（Mark Word）**：用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。
  - **类型指针（Klass pointer）**：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。

- **实例数据**：实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。

- **对齐填充**：对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。因为 `Hotspot` 虚拟机的自动内存管理系统**要求对象起始地址**必须是 **`8` 字节的整数倍**，换句话说就是**对象的大小必须是 `8` 字节的整数倍**。而**对象头部分正好是 `8` 字节的倍数（1 倍或 2 倍）**，因此，当**对象实例数据部分没有对齐时**，就需要通过**对齐填充**来补全.

![Java对象内存布局和数据布局-完整图](https://oss.swimmingliu.cn/6fbb1f69-07e8-11f0-b576-c858c0c1debd)

**【对象的访问方式】**

对象的访问方式主要有两种：**使用句柄** 或者 **直接指针**

- **句柄**：如果使用句柄的话，那么 `Java` 堆中将会划分出一块内存来作为**句柄池**，`reference` 中存储的就是**对象的句柄地址**，而句柄中包含了**对象实例数据**与**对象类型数据各自的具体地址信息**。
- **直接指针**：如果使用直接指针访问，`reference` 中存储的直接就是对象的地址。

![对象访问](https://oss.swimmingliu.cn/6fecdbcc-07e8-11f0-8fcc-c858c0c1debd)

