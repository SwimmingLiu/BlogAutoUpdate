<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Coze工作流分析 | SwimmingLiu&#39;s Blog</title>
<meta name="keywords" content="Java">
<meta name="description" content="Coze工作流-QA

工作流可以分为三个大板块：工作流管理 (前后端交互-画布存储)、工作流校验、工作流执行
工作流管理

对于前端来讲，工作流就是一张canvas画布。用户可以在画布中，创建不同功能的节点。

节点类型可以分为：开始和结束节点 （默认）、LLM节点、子工作流 (嵌套)、插件 (外部工具-例如MCP、OCR)、业务逻辑节点 (选择、循环、分类、批处理(并发)、变量聚合)、数据库节点(SQL、CRUD)、知识库节点(RAG、增删、变量赋值)、图像处理节点、音视频处理节点、组件(JSON序列化、HTTP请求)、定时触发器节点(定时触发任务)
工作流大体执行流程如下
graph TD
    subgraph &#34;前端Canvas层&#34;
        A[Canvas画布用户可视化配置] --&gt; B[Node节点vo.Node结构体]
        A --&gt; C[Edge连接节点间关系]
        B --&gt; D[节点样式：哪些固定字段？表单形式？]
    end
    
    subgraph &#34;验证层&#34;
        E[Canvas结构验证CanvasValidator] --&gt; F{验证通过?}
        F --&gt;|失败| G[返回错误信息]
        G --&gt; H[前端显示错误提示]
    end
    
    subgraph &#34;转换层&#34;
        I[后端保存，workflow运行CanvasToWorkflowSchema] --&gt; J[NodeType -&gt; 节点Config通过NodeAdaptor接口]
        J --&gt; K[前端schema -&gt; 后端schemaschema.NodeSchema]
    end
    
    subgraph &#34;实例化层&#34;
        L[节点实例化NodeBuilder接口] --&gt; M[NodeSchema.Configs实现NodeBuilder接口]
        M --&gt; N[后端schema -&gt; 节点实例具体节点对象]
    end
    
    subgraph &#34;执行层&#34;
        O[节点运行InvokableNode等接口] --&gt; P[业务逻辑具体执行逻辑]
        P --&gt; Q[结果输出返回执行结果]
    end
    
    A --&gt; E
    F --&gt;|通过| I
    K --&gt; L
    N --&gt; O
    
    style A fill:#e3f2fd
    style E fill:#ffebee
    style I fill:#fff3e0
    style L fill:#e8f5e8
    style O fill:#f3e5f5


1.1 画布和后端结构
前端的画布采用DSL (JSON) 形式存储，每次更新画布都是将DSL传给后端。DSL的后端结构如下所示，主要包含节点 (node)、 边 (edge)、 版本">
<meta name="author" content="SwimmingLiu">
<link rel="canonical" href="https://swimmingliu.cn/posts/job/coze-workflow-analysis/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.6ecbb0040febd20e47edd88a662c19f1ea945bf7427774b86594271d18f88faf.css" integrity="sha256-bsuwBA/r0g5H7diKZiwZ8eqUW/dCd3S4ZZQnHRj4j68=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<link rel="apple-touch-icon" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<link rel="mask-icon" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://swimmingliu.cn/posts/job/coze-workflow-analysis/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ],
            
            throwOnError: false
        });
    });
</script>

<meta property="og:url" content="https://swimmingliu.cn/posts/job/coze-workflow-analysis/">
  <meta property="og:site_name" content="SwimmingLiu&#39;s Blog">
  <meta property="og:title" content="Coze工作流分析">
  <meta property="og:description" content="Coze工作流-QA 工作流可以分为三个大板块：工作流管理 (前后端交互-画布存储)、工作流校验、工作流执行
工作流管理 对于前端来讲，工作流就是一张canvas画布。用户可以在画布中，创建不同功能的节点。
节点类型可以分为：开始和结束节点 （默认）、LLM节点、子工作流 (嵌套)、插件 (外部工具-例如MCP、OCR)、业务逻辑节点 (选择、循环、分类、批处理(并发)、变量聚合)、数据库节点(SQL、CRUD)、知识库节点(RAG、增删、变量赋值)、图像处理节点、音视频处理节点、组件(JSON序列化、HTTP请求)、定时触发器节点(定时触发任务)
工作流大体执行流程如下
graph TD subgraph &#34;前端Canvas层&#34; A[Canvas画布用户可视化配置] --&gt; B[Node节点vo.Node结构体] A --&gt; C[Edge连接节点间关系] B --&gt; D[节点样式：哪些固定字段？表单形式？] end subgraph &#34;验证层&#34; E[Canvas结构验证CanvasValidator] --&gt; F{验证通过?} F --&gt;|失败| G[返回错误信息] G --&gt; H[前端显示错误提示] end subgraph &#34;转换层&#34; I[后端保存，workflow运行CanvasToWorkflowSchema] --&gt; J[NodeType -&gt; 节点Config通过NodeAdaptor接口] J --&gt; K[前端schema -&gt; 后端schemaschema.NodeSchema] end subgraph &#34;实例化层&#34; L[节点实例化NodeBuilder接口] --&gt; M[NodeSchema.Configs实现NodeBuilder接口] M --&gt; N[后端schema -&gt; 节点实例具体节点对象] end subgraph &#34;执行层&#34; O[节点运行InvokableNode等接口] --&gt; P[业务逻辑具体执行逻辑] P --&gt; Q[结果输出返回执行结果] end A --&gt; E F --&gt;|通过| I K --&gt; L N --&gt; O style A fill:#e3f2fd style E fill:#ffebee style I fill:#fff3e0 style L fill:#e8f5e8 style O fill:#f3e5f5 1.1 画布和后端结构 前端的画布采用DSL (JSON) 形式存储，每次更新画布都是将DSL传给后端。DSL的后端结构如下所示，主要包含节点 (node)、 边 (edge)、 版本">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-08-07T23:27:35+08:00">
    <meta property="article:modified_time" content="2025-08-07T23:27:35+08:00">
    <meta property="article:tag" content="Java">
      <meta property="og:image" content="https://swimmingliu.cn/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://swimmingliu.cn/papermod-cover.png">
<meta name="twitter:title" content="Coze工作流分析">
<meta name="twitter:description" content="Coze工作流-QA

工作流可以分为三个大板块：工作流管理 (前后端交互-画布存储)、工作流校验、工作流执行
工作流管理

对于前端来讲，工作流就是一张canvas画布。用户可以在画布中，创建不同功能的节点。

节点类型可以分为：开始和结束节点 （默认）、LLM节点、子工作流 (嵌套)、插件 (外部工具-例如MCP、OCR)、业务逻辑节点 (选择、循环、分类、批处理(并发)、变量聚合)、数据库节点(SQL、CRUD)、知识库节点(RAG、增删、变量赋值)、图像处理节点、音视频处理节点、组件(JSON序列化、HTTP请求)、定时触发器节点(定时触发任务)
工作流大体执行流程如下
graph TD
    subgraph &#34;前端Canvas层&#34;
        A[Canvas画布用户可视化配置] --&gt; B[Node节点vo.Node结构体]
        A --&gt; C[Edge连接节点间关系]
        B --&gt; D[节点样式：哪些固定字段？表单形式？]
    end
    
    subgraph &#34;验证层&#34;
        E[Canvas结构验证CanvasValidator] --&gt; F{验证通过?}
        F --&gt;|失败| G[返回错误信息]
        G --&gt; H[前端显示错误提示]
    end
    
    subgraph &#34;转换层&#34;
        I[后端保存，workflow运行CanvasToWorkflowSchema] --&gt; J[NodeType -&gt; 节点Config通过NodeAdaptor接口]
        J --&gt; K[前端schema -&gt; 后端schemaschema.NodeSchema]
    end
    
    subgraph &#34;实例化层&#34;
        L[节点实例化NodeBuilder接口] --&gt; M[NodeSchema.Configs实现NodeBuilder接口]
        M --&gt; N[后端schema -&gt; 节点实例具体节点对象]
    end
    
    subgraph &#34;执行层&#34;
        O[节点运行InvokableNode等接口] --&gt; P[业务逻辑具体执行逻辑]
        P --&gt; Q[结果输出返回执行结果]
    end
    
    A --&gt; E
    F --&gt;|通过| I
    K --&gt; L
    N --&gt; O
    
    style A fill:#e3f2fd
    style E fill:#ffebee
    style I fill:#fff3e0
    style L fill:#e8f5e8
    style O fill:#f3e5f5


1.1 画布和后端结构
前端的画布采用DSL (JSON) 形式存储，每次更新画布都是将DSL传给后端。DSL的后端结构如下所示，主要包含节点 (node)、 边 (edge)、 版本">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚 Posts",
      "item": "https://swimmingliu.cn/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "💻 Job",
      "item": "https://swimmingliu.cn/posts/job/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Coze工作流分析",
      "item": "https://swimmingliu.cn/posts/job/coze-workflow-analysis/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Coze工作流分析",
  "name": "Coze工作流分析",
  "description": "Coze工作流-QA 工作流可以分为三个大板块：工作流管理 (前后端交互-画布存储)、工作流校验、工作流执行\n工作流管理 对于前端来讲，工作流就是一张canvas画布。用户可以在画布中，创建不同功能的节点。\n节点类型可以分为：开始和结束节点 （默认）、LLM节点、子工作流 (嵌套)、插件 (外部工具-例如MCP、OCR)、业务逻辑节点 (选择、循环、分类、批处理(并发)、变量聚合)、数据库节点(SQL、CRUD)、知识库节点(RAG、增删、变量赋值)、图像处理节点、音视频处理节点、组件(JSON序列化、HTTP请求)、定时触发器节点(定时触发任务)\n工作流大体执行流程如下\ngraph TD subgraph \"前端Canvas层\" A[Canvas画布用户可视化配置] --\u003e B[Node节点vo.Node结构体] A --\u003e C[Edge连接节点间关系] B --\u003e D[节点样式：哪些固定字段？表单形式？] end subgraph \"验证层\" E[Canvas结构验证CanvasValidator] --\u003e F{验证通过?} F --\u003e|失败| G[返回错误信息] G --\u003e H[前端显示错误提示] end subgraph \"转换层\" I[后端保存，workflow运行CanvasToWorkflowSchema] --\u003e J[NodeType -\u003e 节点Config通过NodeAdaptor接口] J --\u003e K[前端schema -\u003e 后端schemaschema.NodeSchema] end subgraph \"实例化层\" L[节点实例化NodeBuilder接口] --\u003e M[NodeSchema.Configs实现NodeBuilder接口] M --\u003e N[后端schema -\u003e 节点实例具体节点对象] end subgraph \"执行层\" O[节点运行InvokableNode等接口] --\u003e P[业务逻辑具体执行逻辑] P --\u003e Q[结果输出返回执行结果] end A --\u003e E F --\u003e|通过| I K --\u003e L N --\u003e O style A fill:#e3f2fd style E fill:#ffebee style I fill:#fff3e0 style L fill:#e8f5e8 style O fill:#f3e5f5 1.1 画布和后端结构 前端的画布采用DSL (JSON) 形式存储，每次更新画布都是将DSL传给后端。DSL的后端结构如下所示，主要包含节点 (node)、 边 (edge)、 版本\n",
  "keywords": [
    "Java"
  ],
  "articleBody": "Coze工作流-QA 工作流可以分为三个大板块：工作流管理 (前后端交互-画布存储)、工作流校验、工作流执行\n工作流管理 对于前端来讲，工作流就是一张canvas画布。用户可以在画布中，创建不同功能的节点。\n节点类型可以分为：开始和结束节点 （默认）、LLM节点、子工作流 (嵌套)、插件 (外部工具-例如MCP、OCR)、业务逻辑节点 (选择、循环、分类、批处理(并发)、变量聚合)、数据库节点(SQL、CRUD)、知识库节点(RAG、增删、变量赋值)、图像处理节点、音视频处理节点、组件(JSON序列化、HTTP请求)、定时触发器节点(定时触发任务)\n工作流大体执行流程如下\ngraph TD subgraph \"前端Canvas层\" A[Canvas画布用户可视化配置] --\u003e B[Node节点vo.Node结构体] A --\u003e C[Edge连接节点间关系] B --\u003e D[节点样式：哪些固定字段？表单形式？] end subgraph \"验证层\" E[Canvas结构验证CanvasValidator] --\u003e F{验证通过?} F --\u003e|失败| G[返回错误信息] G --\u003e H[前端显示错误提示] end subgraph \"转换层\" I[后端保存，workflow运行CanvasToWorkflowSchema] --\u003e J[NodeType -\u003e 节点Config通过NodeAdaptor接口] J --\u003e K[前端schema -\u003e 后端schemaschema.NodeSchema] end subgraph \"实例化层\" L[节点实例化NodeBuilder接口] --\u003e M[NodeSchema.Configs实现NodeBuilder接口] M --\u003e N[后端schema -\u003e 节点实例具体节点对象] end subgraph \"执行层\" O[节点运行InvokableNode等接口] --\u003e P[业务逻辑具体执行逻辑] P --\u003e Q[结果输出返回执行结果] end A --\u003e E F --\u003e|通过| I K --\u003e L N --\u003e O style A fill:#e3f2fd style E fill:#ffebee style I fill:#fff3e0 style L fill:#e8f5e8 style O fill:#f3e5f5 1.1 画布和后端结构 前端的画布采用DSL (JSON) 形式存储，每次更新画布都是将DSL传给后端。DSL的后端结构如下所示，主要包含节点 (node)、 边 (edge)、 版本\ntype Canvas struct { Nodes []*Node `json:\"nodes\"` Edges []*Edge `json:\"edges\"` Versions any `json:\"versions\"` } 1.1.1 节点数据 画布中的节点会转换为后端中 backend/domain/workflow/entity/vo/canvas.go 中的 Node 结构体， 后端存储的结构体如下\n// Node 工作流节点的完整定义 // 节点是工作流的基本执行单元，每个节点代表一个特定的功能或操作 type Node struct { // 节点的唯一标识符，用于在画布中定位和引用节点 ID string `json:\"id\"` // 节点类型，决定节点的功能和行为（如LLM、API调用、条件判断等） Type BlockType `json:\"type\"` // 节点的元数据信息，包含前端显示相关的配置 (前端的一些extendInfo) Meta any `json:\"meta\"` // 节点的核心数据，包含输入输出配置和具体参数，例如LLM的配置、MCP的配置、异常处理 Data *Data `json:\"data\"` // 子节点列表，用于复合节点（如循环、条件分支）的嵌套结构 Blocks []*Node `json:\"blocks,omitempty\"` // 节点内部的连线，用于复杂节点的内部逻辑连接 Edges []*Edge `json:\"edges,omitempty\"` // 节点的版本号，用于节点定义的版本控制 Version string `json:\"version,omitempty\"` // 父节点引用，不序列化到JSON，用于内存中的树形结构导航 parent *Node } 节点的核心数据Data如下所示\ntype Data struct { // 节点的显示元数据，如标题、icon等 Meta *NodeMeta `json:\"nodeMeta,omitempty\"` // 节点的输出定义，可以是 []*Variable 或 []*Param 类型 Outputs []any `json:\"outputs,omitempty\"` // 节点的输入配置，包含所有输入参数和设置 Inputs *Inputs `json:\"inputs,omitempty\"` // 节点在画布上的尺寸信息，用于前端显示 Size any `json:\"size,omitempty\"` } 节点的输入参数 inputs\n// Inputs 节点输入配置的综合结构 // 这是一个联合结构，包含了所有可能的节点输入配置，不同类型的节点使用不同的字段子集 type Inputs struct { // 通用输入配置 InputParameters []*Param `json:\"inputParameters\"` // 节点的输入参数列表，定义节点需要的数据输入 Content *BlockInput `json:\"content\"` // 节点的主要内容输入，通常用于文本处理或提示词 TerminatePlan *TerminatePlan `json:\"terminatePlan,omitempty\"` // 终止计划，定义节点完成后的行为 StreamingOutput bool `json:\"streamingOutput,omitempty\"` // 是否启用流式输出，用于实时返回处理结果 CallTransferVoice bool `json:\"callTransferVoice,omitempty\"` // 语音通话转接设置，用于语音相关节点 ChatHistoryWriting string `json:\"chatHistoryWriting,omitempty\"` // 聊天历史记录写入配置 LLMParam any `json:\"llmParam,omitempty\"` // LLM参数，可能是LLMParam、IntentDetectorLLMParam或QALLMParam类型 FCParam *FCParam `json:\"fcParam,omitempty\"` // 功能调用参数，用于配置工作流、插件或知识库的调用 SettingOnError *SettingOnError `json:\"settingOnError,omitempty\"` // 错误处理配置，定义节点出错时的处理策略 // 循环控制相关 LoopType LoopType `json:\"loopType,omitempty\"` // 循环类型：数组循环、计数循环或无限循环 LoopCount *BlockInput `json:\"loopCount,omitempty\"` // 循环次数，用于计数循环 VariableParameters []*Param `json:\"variableParameters,omitempty\"` // 循环变量参数 // 条件分支相关 Branches []*struct { Condition struct { Logic LogicType `json:\"logic\"` // 条件逻辑：AND或OR Conditions []*Condition `json:\"conditions\"` // 具体的条件列表 } `json:\"condition\"` } `json:\"branches,omitempty\"` // 分支条件配置，用于条件判断节点 // 批处理配置 NodeBatchInfo *NodeBatch `json:\"batch,omitempty\"` // 节点批处理模式配置 // 特定节点类型的配置（使用嵌入结构体实现类型多态） *TextProcessor // 文本处理器配置：拼接、分割等操作 *SubWorkflow // 子工作流配置：调用其他工作流 *IntentDetector // 意图检测配置：识别用户意图 *DatabaseNode // 数据库操作配置：增删改查 *HttpRequestNode // HTTP请求配置：API调用 *KnowledgeIndexer // 知识库索引配置：文档处理和索引 *CodeRunner // 代码执行器配置：运行自定义代码 *PluginAPIParam // 插件API参数配置 *VariableAggregator // 变量聚合器配置：合并多个变量 *VariableAssigner // 变量赋值器配置：设置变量值 *QA // 问答节点配置：处理问题和答案 *Batch // 批处理配置：批量处理数据 *Comment // 注释节点配置：添加说明文字 OutputSchema string `json:\"outputSchema,omitempty\"` // 输出模式定义，描述节点输出数据的结构 } 1.1.2 边数据 边主要是包含输入节点、输出节点的ID，还有输入的端口和输出的端口 （输入输出端口都是只存在于业务逻辑节点中）\n// Edge 工作流连线定义 // 连线定义了节点之间的连接关系，确定工作流的执行顺序和数据流向 type Edge struct { // 源节点ID，连线的起始节点 SourceNodeID string `json:\"sourceNodeID\"` // 目标节点ID，连线的终止节点 TargetNodeID string `json:\"targetNodeID\"` // 源端口ID，用于多输出端口的节点，指定具体的输出端口 SourcePortID string `json:\"sourcePortID,omitempty\"` // 目标端口ID，用于多输入端口的节点，指定具体的输入端口 TargetPortID string `json:\"targetPortID,omitempty\"` } 1.1.3 大语言模型节点 (NoteTypeLLM) LLM节点类图如下图所示 classDiagram class Inputs { +Param[] inputParameters +SettingOnError settingOnError +NodeBatch nodeBatchInfo +any llmParam +LLM llmSpecificConfig } class LLM { +FCParam fcParam } class LLMParam { +Param[] parameters } class SimpleLLMParam { +string generationDiversity +int maxTokens +string modelName +int64 modelType +ResponseFormat responseFormat +string systemPrompt +float64 temperature +float64 topP } class Param { +string name +BlockInput input +BlockInput left +BlockInput right +BlockInput[] variables } class BlockInput { +VariableType type +AssistType assistType +any schema +BlockInputValue value } class BlockInputValue { +BlockInputValueType type +any content +any rawMeta } class BlockInputReference { +string blockID +string name +string[] path +RefSourceType source } class FCParam { +WorkflowFCParam workflowFCParam +PluginFCParam pluginFCParam +KnowledgeFCParam knowledgeFCParam } class SettingOnError { +ErrorHandlingStrategy strategy +string customMessage } class NodeBatch { +int batchSize +int concurrentSize } Inputs --\u003e LLM : \"contains\" Inputs --\u003e LLMParam : \"llmParam as\" Inputs --\u003e SimpleLLMParam : \"llmParam as\" Inputs --\u003e Param : \"contains\" Inputs --\u003e SettingOnError : \"contains\" Inputs --\u003e NodeBatch : \"contains\" LLM --\u003e FCParam : \"contains\" LLMParam --\u003e Param : \"contains\" Param --\u003e BlockInput : \"contains\" BlockInput --\u003e BlockInputValue : \"contains\" BlockInputValue --\u003e BlockInputReference : \"content as\" note for Inputs \"LLM节点的所有输入配置包含通用输入和LLM专用配置\" note for LLMParam \"标准LLM参数列表每个参数都是Param类型\" note for SimpleLLMParam \"简化的LLM参数结构直接包含所有LLM配置字段\" note for FCParam \"函数调用能力配置LLM可调用的外部工具\" LLM参数 - SimpleLLMParam SimpleLLMParam如下所示，主要包含多样性程度、最大Token、模型名称、模型类型、响应格式、系统提示词、Temperature温度、TopP 核采样参数\n【注意】generationDiversity多样性程度 是高层的预设策略（如\"创意/平衡/精确\"模式），而 temperature和 topP是底层的具体算法参数，前者通过内置的参数组合来简化配置，后者则提供精确的随机性控制（temperature调节概率分布平滑度，topP限制候选词汇范围）。\n简单说：generationDiversity = “我要什么风格”，temperature = “要多随机”，topP = “考虑多少词汇”。\n// SimpleLLMParam 简化的大语言模型参数配置 // 提供直接的字段映射方式配置LLM参数，适用于简单的模型调用场景 type SimpleLLMParam struct { // GenerationDiversity 生成多样性配置 // 控制模型输出的多样性程度，影响生成内容的创新性 GenerationDiversity string `json:\"generationDiversity\"` // MaxTokens 最大生成令牌数 // 限制模型单次生成的最大token数量，控制输出长度 MaxTokens int `json:\"maxTokens\"` // ModelName 模型名称 // 指定要使用的具体模型名称，如gpt-3.5-turbo、gpt-4等 ModelName string `json:\"modelName\"` // ModelType 模型类型标识 // 用于区分不同类型的模型，如聊天模型、补全模型等 ModelType int64 `json:\"modelType\"` // ResponseFormat 响应格式配置 // 指定模型输出的格式，支持文本、JSON、Markdown等格式 ResponseFormat model.ResponseFormat `json:\"responseFormat\"` // SystemPrompt 系统提示词 // 定义模型的系统级指令，设定模型的角色和行为规范 SystemPrompt string `json:\"systemPrompt\"` // Temperature 温度参数 // 控制模型输出的随机性，范围通常为0.0-1.0，值越高输出越随机 // 通过调整softmax概率分布的平滑度来影响词汇选择的确定性 Temperature float64 `json:\"temperature\"` // TopP 核采样参数 // 控制模型生成时考虑的词汇概率质量，影响输出的多样性和质量 // 通过设置概率累积阈值来限制候选词汇的范围，范围通常为0.0-1.0 TopP float64 `json:\"topP\"` } LLM中的函数调用参数 **FcParam** functionCalling （大语言模型节点的“技能”）中需要用到的参数\ngraph TD A[用户输入问题] --\u003e B[LLM节点接收] B --\u003e C{LLM分析是否需要调用工具} C --\u003e|需要调用| D[FCParam 工具配置] C --\u003e|不需要| E[直接生成回答] D --\u003e F[WorkflowFCParam子工作流调用] D --\u003e G[PluginFCParam插件API调用] D --\u003e H[KnowledgeFCParam知识库检索] F --\u003e F1[配置可调用的子工作流列表] F --\u003e F2[定义请求/响应参数] F --\u003e F3[执行子工作流] G --\u003e G1[配置可调用的插件API列表] G --\u003e G2[定义API参数和响应格式] G --\u003e G3[调用第三方插件服务] H --\u003e H1[配置知识库列表] H --\u003e H2[设置检索策略TopK/MinScore/搜索模式] H --\u003e H3[执行知识库检索] F3 --\u003e I[工具执行结果] G3 --\u003e I H3 --\u003e I I --\u003e J[LLM整合工具结果] J --\u003e K[生成最终回答] E --\u003e K K --\u003e L[返回给用户] style A fill:#e1f5fe style D fill:#fff3e0 style F fill:#f3e5f5 style G fill:#e8f5e8 style H fill:#fce4ec style K fill:#e0f2f1 函数调用参数 FcParam主要包含三种模式：子工作流调用、插件API调用、知识库检索\n// FCParam 函数调用参数配置 // 用于配置工作流中不同类型的函数调用能力，包括子工作流调用、插件API调用和知识库检索调用 type FCParam struct { // WorkflowFCParam 工作流函数调用参数配置 // 配置当前工作流可以调用的子工作流列表及其参数设置 WorkflowFCParam *struct { // WorkflowList 可调用的工作流列表 // 每个工作流项包含工作流标识、版本信息和函数调用设置 WorkflowList []struct { // WorkflowID 工作流唯一标识符 WorkflowID string `json:\"workflow_id\"` // WorkflowVersion 工作流版本号 WorkflowVersion string `json:\"workflow_version\"` // PluginID 关联的插件ID（如果工作流基于插件） PluginID string `json:\"plugin_id\"` // PluginVersion 插件版本号 PluginVersion string `json:\"plugin_version\"` // IsDraft 是否为草稿版本 IsDraft bool `json:\"is_draft\"` // FCSetting 函数调用设置 // 定义调用该工作流时的请求和响应参数结构 FCSetting *struct { // RequestParameters 请求参数列表 // 定义调用工作流时需要传入的参数 RequestParameters []*workflow.APIParameter `json:\"request_params\"` // ResponseParameters 响应参数列表 // 定义工作流执行完成后返回的参数 ResponseParameters []*workflow.APIParameter `json:\"response_params\"` } `json:\"fc_setting,omitempty\"` } `json:\"workflowList,omitempty\"` } `json:\"workflowFCParam,omitempty\"` // PluginFCParam 插件函数调用参数配置 // 配置当前工作流可以调用的插件API列表及其参数设置 PluginFCParam *struct { // PluginList 可调用的插件列表 // 每个插件项包含插件标识、API信息和函数调用设置 PluginList []struct { // PluginID 插件唯一标识符 PluginID string `json:\"plugin_id\"` // ApiId API接口唯一标识符 ApiId string `json:\"api_id\"` // ApiName API接口名称 ApiName string `json:\"api_name\"` // PluginVersion 插件版本号 PluginVersion string `json:\"plugin_version\"` // IsDraft 是否为草稿版本 IsDraft bool `json:\"is_draft\"` // FCSetting 函数调用设置 // 定义调用该插件API时的请求和响应参数结构 FCSetting *struct { // RequestParameters 请求参数列表 // 定义调用插件API时需要传入的参数 RequestParameters []*workflow.APIParameter `json:\"request_params\"` // ResponseParameters 响应参数列表 // 定义插件API执行完成后返回的参数 ResponseParameters []*workflow.APIParameter `json:\"response_params\"` } `json:\"fc_setting,omitempty\"` } } `json:\"pluginFCParam,omitempty\"` // KnowledgeFCParam 知识库函数调用参数配置 // 配置当前工作流的知识库检索功能及其全局设置 KnowledgeFCParam *struct { // GlobalSetting 知识库检索全局设置 // 定义知识库检索的通用配置参数 GlobalSetting *struct { // SearchMode 搜索模式 // 定义知识库检索使用的搜索算法模式 SearchMode int64 `json:\"search_mode\"` // TopK 返回结果数量 // 定义知识库检索返回的最大结果数量 TopK int64 `json:\"top_k\"` // MinScore 最小相似度分数 // 定义知识库检索结果的最小相似度阈值 MinScore float64 `json:\"min_score\"` // UseNL2SQL 是否启用自然语言转SQL功能 UseNL2SQL bool `json:\"use_nl2_sql\"` // UseRewrite 是否启用查询重写功能 UseRewrite bool `json:\"use_rewrite\"` // UseRerank 是否启用结果重排序功能 UseRerank bool `json:\"use_rerank\"` // NoRecallReplyCustomizePrompt 无召回结果时的自定义回复提示词 NoRecallReplyCustomizePrompt string `json:\"no_recall_reply_customize_prompt\"` // NoRecallReplyMode 无召回结果时的回复模式 NoRecallReplyMode int64 `json:\"no_recall_reply_mode\"` } `json:\"global_setting,omitempty\"` // KnowledgeList 可检索的知识库列表 // 定义当前工作流可以检索的知识库集合 KnowledgeList []*struct { // ID 知识库唯一标识符 ID string `json:\"id\"` } `json:\"knowledgeList,omitempty\"` } `json:\"knowledgeFCParam,omitempty\"` } 子工作流调用 { \"workflowFCParam\": { \"workflowList\": [ { \"workflow_id\": \"7509120431183544356\", \"workflow_version\": \"v0.0.1\", \"plugin_id\": \"7509121334769795126\", \"is_draft\": false, \"fc_setting\": { \"request_params\": [...], // 调用参数 \"response_params\": [...] // 返回参数 } } ] } } 插件API调用 { \"pluginFCParam\": { \"pluginList\": [ { \"plugin_id\": \"7509353177339133952\", \"api_id\": \"7509353598782816256\", \"api_name\": \"周公解梦\", \"plugin_version\": \"0\", \"fc_setting\": { \"request_params\": [ { \"name\": \"title\", \"desc\": \"查询解梦标题，例如：梦见蛇\", \"type\": 1, \"is_required\": true } ], \"response_params\": [...] } } ] } } 知识库检索 { \"knowledgeFCParam\": { \"knowledgeList\": [ { \"id\": \"7512369185624686592\", \"name\": \"旅游景点\" } ], \"global_setting\": { \"top_k\": 3, // \"min_score\": 0.5, \"search_mode\": 0, \"use_rerank\": true, \"use_rewrite\": true, \"use_nl2_sql\": true, \"no_recall_reply_mode\": 0, \"no_recall_reply_customize_prompt\": \"抱歉，您的问题超出了我的知识范围\" } } 1.1.4 BlockInput结构 BlockInput是工作流系统中的数据绑定核心，它解决了一个关键问题：如何在工作流节点之间传递和配置数据。BlockInput = \"这个输入框里放什么数据，从哪里来\"\ngraph TD A[BlockInput 块输入配置] --\u003e B[Type: 数据类型] A --\u003e C[AssistType: 辅助类型] A --\u003e D[Schema: 结构定义] A --\u003e E[Value: 输入值配置] E --\u003e F[BlockInputValue] F --\u003e G[Type: 值类型] F --\u003e H[Content: 具体内容] F --\u003e I[RawMeta: 元数据] G --\u003e G1[literal: 字面值] G --\u003e G2[ref: 节点引用] G --\u003e G3[object_ref: 对象引用] H --\u003e H1[静态文本/数值] H --\u003e H2[BlockInputReference] H2 --\u003e J[BlockID: 源节点ID] H2 --\u003e K[Name: 字段名称] H2 --\u003e L[Path: 访问路径] H2 --\u003e M[Source: 引用源类型] M --\u003e M1[block-output: 节点输出] M --\u003e M2[global_variable_app: 应用变量] M --\u003e M3[global_variable_system: 系统变量] M --\u003e M4[global_variable_user: 用户变量] N[实际使用场景] --\u003e N1[静态配置: 固定值] N --\u003e N2[动态绑定: 引用其他节点] N --\u003e N3[模板渲染: 变量替换] N --\u003e N4[复杂对象: 嵌套结构] style A fill:#e1f5fe style F fill:#fff3e0 style H2 fill:#f3e5f5 style N fill:#e8f5e8 BlockInput结构如下所示\ntype BlockInput struct { Type VariableType // 数据类型：string、number、object等 AssistType AssistType // 辅助类型：更具体的类型描述 Schema any // 结构定义：复杂对象的内部结构 Value *BlockInputValue // 值配置：具体的数据来源 } 三种数据流来源：常量literal、节点引用ref、对象引用 Object Ref\n常量literal { \"type\": \"string\", \"value\": { \"type\": \"literal\", \"content\": \"Hello World\", \"rawMeta\": {\"type\": 1} } } 节点引用ref (最常用的) { \"type\": \"string\", \"value\": { \"type\": \"ref\", \"content\": { \"blockID\": \"100001\", \"name\": \"output\", \"source\": \"block-output\" } } } 对象引用 { \"type\": \"object\", \"schema\": [{\"name\": \"name\", \"type\": \"string\"}], \"value\": { \"type\": \"object_ref\", \"content\": { \"blockID\": \"100001\", \"name\": \"person\", \"source\": \"block-output\" } } } 1.1.5 知识库节点 (RAG) RAG完整流程图 一个完整的RAG流程如下：\n查询重写优化 （小模型）-\u003e 自然语言转SQL （NL2SQL）-\u003e 向量检索 (语义搜索/混合搜索/全量搜索) -\u003e 相似度过滤 (最小相似度阈值) -\u003e 结果重排序 (Rerank) -\u003e TopK结果截取 -\u003e 构建新的上下文提示词\ngraph LR A[用户输入查询] --\u003e B[查询预处理] B --\u003e B1[UseRewrite: 查询重写] B1 --\u003e B2[优化查询语义] B2 --\u003e B3[UseNL2SQL: 自然语言转SQL] B3 --\u003e C[向量检索阶段] C --\u003e C1[文档向量化] C --\u003e C2[查询向量化] C1 --\u003e C3[向量相似度计算] C2 --\u003e C3 C3 --\u003e D[SearchMode: 搜索策略] D --\u003e D1[0: 语义搜索Semantic Search] D --\u003e D2[1: 混合搜索Hybrid Search] D --\u003e D3[20: 全文搜索Full-text Search] D1 --\u003e E[初步结果筛选] D2 --\u003e E D3 --\u003e E E --\u003e E1[MinScore: 相似度过滤] E1 --\u003e E2[过滤低质量结果] E2 --\u003e F[UseRerank: 结果重排序] F --\u003e F1[深度语义匹配] F1 --\u003e F2[重新排序结果] F2 --\u003e G[TopK: 结果截取] G --\u003e G1[选择前K个最佳结果] G1 --\u003e H{是否有合适结果?} H --\u003e|有| I[构建增强上下文] H --\u003e|无| J[NoRecallReplyMode处理] J --\u003e J1[0: 使用自定义提示词] J --\u003e J2[1: 其他处理模式] J1 --\u003e K[返回无结果回复] J2 --\u003e K I --\u003e L[RAG生成阶段] L --\u003e L1[组合查询+检索内容] L1 --\u003e L2[LLM生成增强回答] L2 --\u003e M[返回最终答案] K --\u003e M style A fill:#e1f5fe style B fill:#fff3e0 style C fill:#f3e5f5 style D fill:#e8f5e8 style F fill:#fce4ec style L fill:#e0f2f1 向量检索规则 graph TD A[用户查询] --\u003e B{SearchMode选择} B --\u003e|0: 语义搜索| C[Semantic Search] B --\u003e|1: 混合搜索| D[Hybrid Search] B --\u003e|20: 全文搜索| E[Full-text Search] C --\u003e C1[Step1: 查询向量化] C1 --\u003e C2[Embedding Model] C2 --\u003e C3[Query Vector] C3 --\u003e C4[Step2: 文档向量匹配] C4 --\u003e C5[向量数据库] C5 --\u003e C6[余弦相似度计算] D --\u003e D1[Step1: 向量搜索路径] D --\u003e D2[Step2: 关键词搜索路径] D1 --\u003e D3[Embedding检索] D2 --\u003e D4[BM25算法] D3 --\u003e D5[结果融合算法] D4 --\u003e D5 E --\u003e E1[Step1: 分词处理] E1 --\u003e E2[分词器] E2 --\u003e E3[Step2: 倒排索引] E3 --\u003e E4[搜索引擎] E4 --\u003e E5[TF-IDF评分] C6 --\u003e F[语义理解强] D5 --\u003e G[平衡精确性和语义] E5 --\u003e H[关键词精确匹配] F --\u003e I[最终检索结果] G --\u003e I H --\u003e I style C fill:#e1f5fe style D fill:#fff3e0 style E fill:#f3e5f5 style I fill:#e8f5e8 语义搜索 （准）: 使用 Embedding 模型计算向量相似度，理解深层语义，处理同义词和概念匹配。\n混合搜索 （全面）: 结合向量搜索 + BM25 关键词搜索，平衡语义理解和精确匹配。\n全文搜索 （快）: 传统的倒排索引和TF-IDF，精确的关键词匹配，速度快\n【算法说明】\nEmbedding向量检索：将文本通过编码器转为向量和DB中的向量计算cos相似度最后返回TopK的结果 graph TD A[文本输入] --\u003e B[Embedding检索流程] B --\u003e C[第一阶段: 向量化] C --\u003e C1[分词和预处理] C1 --\u003e C2[Transformer编码器] C2 --\u003e C3[池化操作] C3 --\u003e C4[归一化处理] C4 --\u003e C5[生成向量表示] B --\u003e D[第二阶段: 索引构建] D --\u003e D1[向量维度优化] D1 --\u003e D2[索引结构选择] D2 --\u003e D3[HNSW/IVF/LSH] D3 --\u003e D4[分布式存储] B --\u003e E[第三阶段: 相似度检索] E --\u003e E1[查询向量化] E1 --\u003e E2[近似最近邻搜索] E2 --\u003e E3[相似度计算] E3 --\u003e E4[TopK结果返回] F[技术栈] --\u003e F1[模型: BERT/Sentence-BERT] F --\u003e F2[向量DB: Pinecone/Milvus/ElasticSearch] F --\u003e F3[相似度: 余弦/点积/欧氏] F --\u003e F4[索引: HNSW/IVF] style C fill:#e1f5fe style D fill:#fff3e0 style E fill:#f3e5f5 style F fill:#e8f5e8 倒排索引：将文档切分成独立的词汇单元，建立从词汇到文档的映射索引\nTF-IDF (词频-逆文档频率)：TF（词频）： 计算一个词在文档中出现的词次数， 用于衡量词汇的重要性。IDF （逆文档频率）：衡量词汇在整个语料库中的重要性。 TF(t,d) = 词汇t在文档d中出现的次数 / 文档d的总词数 IDF(t) = log(文档总数 / 包含词汇t的文档数) TF-IDF = sigmoid (TF(t,d) * IDF(t)) 缺点：不能考虑词汇的位置，忽略了词汇的相关性；不利于稀疏性 （短文档很多词汇 TF-IDF=0）\nBM25 算法：在 TF-IDF (词频-逆文档频率) 基础上，解决了词频饱和问题和文档长度归一化问题。 ReRank 规则 Rerank就是根据多个检索方式得到的结果进行整合，然后根据RRF算法重新排序的过程\nRRF: score = 1/(rank + k) # 默认 k = 60 rerank模型的时序图\nsequenceDiagram participant User as 用户 participant RS as 检索服务RetrieveService participant QR as 查询重写QueryRewriter participant VS as 向量检索VectorStore participant ES as 全文检索ElasticSearch participant NL as NL2SQL检索NL2SQLEngine participant RK as 重排序器Reranker participant API as Rerank APIVikingDB Note over User, API: 1. 初始化检索请求 User-\u003e\u003eRS: 发起检索请求(query, knowledgeIDs, strategy) RS-\u003e\u003eRS: 构建检索上下文(RetrieveContext) Note over User, API: 2. 查询重写 (可选) alt 启用查询重写 \u0026\u0026 有对话历史 RS-\u003e\u003eQR: 基于对话历史重写查询 QR--\u003e\u003eRS: 返回重写后的查询 end Note over User, API: 3. 并行多通道检索 par 向量检索 alt 语义检索 || 混合检索 RS-\u003e\u003eVS: 向量相似度检索 VS-\u003e\u003eVS: 1. 查询文本向量化 VS-\u003e\u003eVS: 2. 计算余弦相似度 VS-\u003e\u003eVS: 3. 返回TopK相似文档 VS--\u003e\u003eRS: 向量检索结果(score: 0.0-1.0) end and 全文检索 alt 全文检索 || 混合检索 RS-\u003e\u003eES: 关键词匹配检索 ES-\u003e\u003eES: 1. 分词和索引匹配 ES-\u003e\u003eES: 2. 计算BM25分数 ES-\u003e\u003eES: 3. 返回匹配文档 ES--\u003e\u003eRS: ES检索结果(score: BM25) end and NL2SQL检索 alt 启用NL2SQL RS-\u003e\u003eNL: 自然语言转SQL查询 NL-\u003e\u003eNL: 1. 解析查询意图 NL-\u003e\u003eNL: 2. 生成SQL语句 NL-\u003e\u003eNL: 3. 执行结构化查询 NL--\u003e\u003eRS: NL2SQL结果(score: 相关性分数) end end Note over User, API: 4. Rerank重排序 RS-\u003e\u003eRS: 整合多通道检索结果 Note right of RS: 根据检索策略收集结果:- SearchTypeSemantic: 仅向量结果- SearchTypeFullText: 仅ES结果- SearchTypeHybrid: 向量+ES结果- 如启用NL2SQL: 额外添加NL2SQL结果 RS-\u003e\u003eRK: 调用Rerank服务 Note right of RK: 传入参数:- Query: 原始查询或重写后查询- Data: 多通道检索结果数组- TopN: 最终返回数量 alt VikingDB Reranker (深度学习模型) RK-\u003e\u003eRK: 1. 扁平化所有检索结果 RK-\u003e\u003eRK: 2. 构造rerank请求{query, content, title} RK-\u003e\u003eAPI: HTTP POST请求/api/knowledge/service/rerank API-\u003e\u003eAPI: 1. 使用base-multilingual-rerank模型 API-\u003e\u003eAPI: 2. 计算query-document相关性分数 API--\u003e\u003eRK: 返回每个文档的新分数{scores: [0.8, 0.6, 0.9, ...]} RK-\u003e\u003eRK: 3. 按新分数降序排序 RK-\u003e\u003eRK: 4. 截取TopN结果 else RRF Reranker (排名融合算法) RK-\u003e\u003eRK: 1. 为每个通道的结果按排名计算分数 Note right of RK: RRF公式: score = 1/(rank + k)其中k=60为默认参数 RK-\u003e\u003eRK: 2. 同一文档取最高分数 RK-\u003e\u003eRK: 3. 按分数降序排序 RK-\u003e\u003eRK: 4. 截取TopN结果 end RK--\u003e\u003eRS: 返回重排序结果{sortedData, tokenUsage} Note over User, API: 5. 结果过滤与封装 RS-\u003e\u003eRS: 1. 应用最小分数阈值过滤(score \u003c minScore的文档被移除) RS-\u003e\u003eRS: 2. 更新文档分数为rerank分数 RS-\u003e\u003eRS: 3. 封装最终检索结果 RS--\u003e\u003eUser: 返回最终检索结果(按相关性排序的文档列表) 知识库节点结构 // Knowledge 知识库节点配置 // 用于配置独立的知识库检索节点，定义数据源参数和处理策略 // 与LLM节点中的KnowledgeFCParam不同，这是专门的知识库检索步骤 type Knowledge struct { // DatasetParam 数据集参数配置 // 定义知识库的数据源配置，包括数据库连接、文件路径等信息 // 每个Param包含具体的数据源配置项 DatasetParam []*Param `json:\"datasetParam,omitempty\"` // StrategyParam 知识库处理策略参数 // 定义文档解析、分块、索引等各个环节的处理策略和参数 StrategyParam StrategyParam `json:\"strategyParam,omitempty\"` } // StrategyParam 知识库处理策略参数配置 // 定义知识库从文档解析到向量索引的完整处理流程策略 type StrategyParam struct { // ParsingStrategy 文档解析策略配置 // 定义如何解析和提取不同类型文档的内容 ParsingStrategy struct { // ParsingType 解析类型 // 定义文档解析的方式，如自动识别、手动指定等 // 常见值：auto（自动识别）、manual（手动指定）、custom（自定义） ParsingType string `json:\"parsingType,omitempty\"` // ImageExtraction 是否提取图片 // 控制是否从文档中提取图片内容进行处理 // true表示提取图片，false表示忽略图片内容 ImageExtraction bool `json:\"imageExtraction\"` // TableExtraction 是否提取表格 // 控制是否从文档中提取表格结构和数据 // true表示解析表格结构，false表示将表格视为普通文本 TableExtraction bool `json:\"tableExtraction\"` // ImageOcr 是否启用图片OCR识别 // 控制是否对提取的图片进行光学字符识别 // true表示对图片进行OCR文字识别，false表示忽略图片中的文字 ImageOcr bool `json:\"imageOcr\"` } `json:\"parsingStrategy,omitempty\"` // ChunkStrategy 文档分块策略配置 // 定义如何将长文档切分成适合向量化的小块 ChunkStrategy struct { // ChunkType 分块类型 // 定义文档分块的策略类型 // 常见值：fixed（固定长度）、semantic（语义分块）、sentence（句子分块） ChunkType string `json:\"chunkType,omitempty\"` // SeparatorType 分隔符类型 // 定义用于分块的分隔符类型 // 常见值：auto（自动选择）、newline（换行符）、paragraph（段落）、custom（自定义） SeparatorType string `json:\"separatorType,omitempty\"` // Separator 自定义分隔符 // 当SeparatorType为custom时，指定具体的分隔符字符串 Separator string `json:\"separator,omitempty\"` // MaxToken 最大令牌数 // 定义每个文档块的最大token数量，控制块的大小 // 通常设置为模型的上下文窗口大小，如512、1024等 MaxToken int64 `json:\"maxToken,omitempty\"` // Overlap 重叠比例 // 定义相邻文档块之间的重叠比例，避免语义信息在边界处丢失 // 取值范围0.0-1.0，常见值为0.1-0.2（10%-20%重叠） Overlap float64 `json:\"overlap,omitempty\"` } `json:\"chunkStrategy,omitempty\"` // IndexStrategy 索引策略配置 // 定义向量索引的构建策略，如索引类型、参数等 // 具体结构依赖于使用的向量数据库类型（如HNSW、IVF等） IndexStrategy any `json:\"indexStrategy\"` } 1.2 如何从画布转换为后端类？如何转换为执行态？ 前端传入画布的 DSL语言（JSON）给后端之后，会解析为上方的后端结构。画布中的每个节点都会变成 canvas.go中的 Node结构体。但是转换后的 Node结构体只是一个存储态，如果需要执行工作流还需要将 Node结构体从存储态转为运行态。后端 schema 的 NodeSchema结构体就是 针对用于表达工作流的运行态的\n1.2.1 转换流程图 graph TD A[Canvas画布] --\u003e B[CanvasToWorkflowSchema] B --\u003e C[移除孤立节点] C --\u003e D[遍历Canvas Nodes] D --\u003e E{节点类型判断} E --\u003e|子工作流| F[toSubWorkflowNodeSchema] E --\u003e|普通节点| G[获取NodeAdaptor] G --\u003e H[调用Adaptor.Adapt方法] H --\u003e I{节点有子节点?} I --\u003e|是| J[递归转换子节点] I --\u003e|否| K[转换输入输出类型] J --\u003e L[设置层次关系] L --\u003e K K --\u003e M[设置异常处理配置] M --\u003e N[生成NodeSchema] F --\u003e N N --\u003e O[收集所有NodeSchema] O --\u003e P[转换连接边] P --\u003e Q[标准化端口] Q --\u003e R[构建分支信息] R --\u003e S[WorkflowSchema] subgraph \"NodeAdaptor转换细节\" H1[解析节点配置] --\u003e H2[转换输入参数] H2 --\u003e H3[转换输出定义] H3 --\u003e H4[设置节点特定Config] H4 --\u003e H5[调用SetInputsForNodeSchema] H5 --\u003e H6[调用SetOutputTypesForNodeSchema] end H --\u003e H1 subgraph \"类型转换细节\" T1[CanvasBlockInputToTypeInfo] --\u003e T2[解析基础类型] T2 --\u003e T3[处理复杂对象类型] T3 --\u003e T4[处理数组类型] T4 --\u003e T5[处理文件类型] T5 --\u003e T6[生成TypeInfo] U1[CanvasBlockInputToFieldInfo] --\u003e U2[分析数据来源] U2 --\u003e U3{来源类型} U3 --\u003e|静态值| U4[创建LiteralFieldInfo] U3 --\u003e|节点引用| U5[创建ReferenceFieldInfo] U3 --\u003e|模板字符串| U6[创建TemplateFieldInfo] U4 --\u003e U7[生成FieldInfo] U5 --\u003e U7 U6 --\u003e U7 end K --\u003e T1 K --\u003e U1 style A fill:#e1f5fe style S fill:#c8e6c9 style H fill:#fff3e0 style N fill:#fce4ec 1.2.2 转换后的NodeSchema结构 // NodeSchema 工作流节点的统一描述和配置结构 // 包含实例化一个节点所需的所有信息，是Canvas Node转换后的后端执行结构 type NodeSchema struct { // Key 节点在Eino图中的唯一标识符 // 节点在执行过程中可能需要这个信息，例如： // - 使用此Key查询工作流状态中属于当前节点的数据 Key vo.NodeKey `json:\"key\"` // Name 节点在Canvas画布上指定的显示名称 // 节点可能会在Canvas上显示这个名称作为输入/输出的一部分 Name string `json:\"name\"` // Type 节点的类型标识 // 对应entity.NodeType枚举，决定节点的具体行为和功能 Type entity.NodeType `json:\"type\"` // Configs 节点特定的配置信息 // 每个节点类型定义自己的配置结构体，不包含字段映射或静态值信息 // 这些配置是节点实现的内部配置，与工作流编排无关 // 实际类型应该实现两个接口： // - NodeAdaptor: 提供从vo.Node到NodeSchema的转换 // - NodeBuilder: 提供从NodeSchema到实际节点实例的实例化 Configs any `json:\"configs,omitempty\"` // InputTypes 节点输入字段的类型信息映射 // 键为字段名，值为对应的类型信息，用于类型检查和验证 InputTypes map[string]*vo.TypeInfo `json:\"input_types,omitempty\"` // InputSources 节点输入字段的映射信息 // 定义每个输入字段的数据来源，如来自其他节点的输出或静态值 InputSources []*vo.FieldInfo `json:\"input_sources,omitempty\"` // OutputTypes 节点输出字段的类型信息映射 // 键为字段名，值为对应的类型信息，用于下游节点的类型推导 OutputTypes map[string]*vo.TypeInfo `json:\"output_types,omitempty\"` // OutputSources 节点输出字段的映射信息 // 注意：仅适用于复合节点，如NodeTypeBatch或NodeTypeLoop OutputSources []*vo.FieldInfo `json:\"output_sources,omitempty\"` // ExceptionConfigs 节点的异常处理策略配置 // 包含超时、重试、错误处理类型等异常处理相关设置 ExceptionConfigs *ExceptionConfig `json:\"exception_configs,omitempty\"` // StreamConfigs 节点的流式处理特性配置 // 定义节点是否支持流式输入/输出等流处理能力 StreamConfigs *StreamConfig `json:\"stream_configs,omitempty\"` // SubWorkflowBasic 子工作流的基本信息 // 仅当节点类型为NodeTypeSubWorkflow时使用 SubWorkflowBasic *entity.WorkflowBasic `json:\"sub_workflow_basic,omitempty\"` // SubWorkflowSchema 子工作流的完整Schema信息 // 仅当节点类型为NodeTypeSubWorkflow时使用，包含子工作流的完整定义 SubWorkflowSchema *WorkflowSchema `json:\"sub_workflow_schema,omitempty\"` // FullSources 节点输入字段映射来源的完整信息 // 包含更详细的信息，如字段是否为流式字段，或字段是否为包含子字段映射的对象 // 用于需要处理流式输入的节点 // 在NodeMeta中设置InputSourceAware = true来启用此功能 FullSources map[string]*SourceInfo // Lambda 直接设置节点为Eino Lambda // 注意：不可序列化，仅用于内部测试 Lambda *compose.Lambda } 1.2.3 转换结构前后对比 graph LR subgraph \"前端Canvas结构\" A[Canvas画布] A --\u003e B[Node节点] A --\u003e C[Edge连接] B --\u003e D[ID: string] B --\u003e E[Type: string] B --\u003e F[Data配置] F --\u003e G[Meta元数据] F --\u003e H[Inputs输入] F --\u003e I[Outputs输出] H --\u003e J[InputParameters参数列表] H --\u003e K[LLMParam模型参数] H --\u003e L[SettingOnError错误处理] J --\u003e M[Param参数] M --\u003e N[Name: string] M --\u003e O[Input: BlockInput] O --\u003e P[Type: VariableType] O --\u003e Q[Value: BlockInputValue] Q --\u003e R[Type: literal/ref/object_ref] Q --\u003e S[Content: any] I --\u003e T[Variable变量] T --\u003e U[Name: string] T --\u003e V[Type: VariableType] T --\u003e W[Schema: any] end subgraph \"转换过程\" X[CanvasToWorkflowSchema] --\u003e Y[NodeToNodeSchema] Y --\u003e Z[NodeAdaptor.Adapt] Z --\u003e AA[SetInputsForNodeSchema] Z --\u003e BB[SetOutputTypesForNodeSchema] AA --\u003e CC[CanvasBlockInputToTypeInfo] AA --\u003e DD[CanvasBlockInputToFieldInfo] BB --\u003e EE[CanvasVariableToTypeInfo] end subgraph \"后端NodeSchema结构\" FF[WorkflowSchema工作流] FF --\u003e GG[NodeSchema节点] FF --\u003e HH[Connection连接] FF --\u003e II[Branch分支] GG --\u003e JJ[Key: NodeKey] GG --\u003e KK[Type: NodeType枚举] GG --\u003e LL[Configs: 节点配置] GG --\u003e MM[InputTypes类型映射] GG --\u003e NN[InputSources来源映射] GG --\u003e OO[OutputTypes输出类型] MM --\u003e PP[\"map[string]*TypeInfo\"] NN --\u003e QQ[\"[]*FieldInfo\"] OO --\u003e RR[\"map[string]*TypeInfo\"] QQ --\u003e SS[FieldInfo字段信息] SS --\u003e TT[Path: FieldPath] SS --\u003e UU[Source: 数据来源] SS --\u003e VV[Type: Literal/Reference/Template] PP --\u003e WW[TypeInfo类型信息] WW --\u003e XX[Type: DataType枚举] WW --\u003e YY[Properties: 对象属性] WW --\u003e ZZ[ElemTypeInfo: 数组元素类型] GG --\u003e AAA[ExceptionConfigs异常配置] AAA --\u003e BBB[TimeoutMS: 超时时间] AAA --\u003e CCC[MaxRetry: 重试次数] AAA --\u003e DDD[ProcessType: 处理类型] end A -.转换.-\u003e FF B -.适配器转换.-\u003e GG C -.标准化.-\u003e HH O -.类型转换.-\u003e WW Q -.来源分析.-\u003e SS style A fill:#e3f2fd style FF fill:#e8f5e8 style X fill:#fff3e0 style Y fill:#fff3e0 style Z fill:#fff3e0 【转换过程】\ncanvas到 NodeSchema的转换过程是Coze Studio工作流系统中的核心架构设计，它通过适配器模式将前端面向用户的可视化画布结构转换为后端面向执行的标准化 Schema结构。在这个过程中，前端的 Canvas包含了用户在画布上拖拽配置的 Node节点和 Edge连接，每个Node节点包含字符串类型的ID和Type、用户配置的Data数据（包括输入参数、输出定义、元数据等），这些数据以灵活的 `any `类型和嵌套结构存储以适应前端的动态配置需求；而转换后的NodeSchema则采用强类型的结构化设计，将节点类型转换为枚举、将输入输出转换为 TypeInfo和FieldInfo的映射关系、将数据来源分析为具体的引用路径，并添加了执行时需要的 异常处理配置、流式处理配置等运行时信息。这个转换过程之所以必要，是因为前端Canvas需要保持高度的灵活性和可扩展性来支持用户的各种配置操作和UI交互，而后端执行引擎则需要严格的类型安全、明确的数据流向和优化的执行性能，两者的设计目标和约束条件完全不同，因此需要通过这个转换层来实现前后端的解耦，同时确保用户在画布上的每一个配置都能准确无误地转换为可执行的工作流逻辑，并且这种转换过程还支持复杂的节点类型（如子工作流、批处理节点）、数据类型推导、字段映射分析等高级特性，为整个工作流系统的稳定运行和功能扩展提供了坚实的基础。\n1.3 工作流执行过程分析 工作流执行图 (细节) graph TD A[Canvas画布] --\u003e B{保存/运行工作流} B --\u003e C[画布结构验证] C --\u003e D[连接关系验证] C --\u003e E[闭环检测] C --\u003e F[节点配置验证] C --\u003e G[变量引用验证] C --\u003e H[嵌套流程验证] C --\u003e I[全局变量验证] C --\u003e J[子工作流终止计划验证] D --\u003e K{验证通过?} E --\u003e K F --\u003e K G --\u003e K H --\u003e K I --\u003e K J --\u003e K K --\u003e|否| L[返回验证错误] L --\u003e M[前端显示错误信息] K --\u003e|是| N[Canvas转换为WorkflowSchema] N --\u003e O[移除孤立节点] O --\u003e P[遍历Canvas Nodes] P --\u003e Q{节点类型判断} Q --\u003e|子工作流| R[递归解析子工作流Canvas] Q --\u003e|批处理节点| S[解析批处理模式] Q --\u003e|普通节点| T[获取NodeAdaptor] R --\u003e U[toSubWorkflowNodeSchema] S --\u003e V[parseBatchMode生成批处理结构] T --\u003e W[调用Adaptor.Adapt方法] U --\u003e X[设置异常处理配置] V --\u003e X W --\u003e X X --\u003e Y{节点有子节点?} Y --\u003e|是| Z[递归转换子节点] Y --\u003e|否| AA[转换输入输出类型] Z --\u003e BB[设置层次关系映射] BB --\u003e AA AA --\u003e CC[SetInputsForNodeSchema] AA --\u003e DD[SetOutputTypesForNodeSchema] CC --\u003e EE[CanvasBlockInputToTypeInfo] CC --\u003e FF[CanvasBlockInputToFieldInfo] DD --\u003e GG[CanvasVariableToTypeInfo] EE --\u003e HH[解析基础类型] EE --\u003e II[处理复杂对象类型] EE --\u003e JJ[处理数组类型] EE --\u003e KK[处理文件类型] FF --\u003e LL[分析数据来源] LL --\u003e MM{来源类型} MM --\u003e|静态值| NN[创建LiteralFieldInfo] MM --\u003e|节点引用| OO[创建ReferenceFieldInfo] MM --\u003e|模板字符串| PP[创建TemplateFieldInfo] HH --\u003e QQ[生成NodeSchema] II --\u003e QQ JJ --\u003e QQ KK --\u003e QQ NN --\u003e QQ OO --\u003e QQ PP --\u003e QQ GG --\u003e QQ QQ --\u003e RR[收集所有NodeSchema] RR --\u003e SS[转换连接边EdgeToConnection] SS --\u003e TT[标准化端口normalizePorts] TT --\u003e UU[构建分支信息BuildBranches] UU --\u003e VV[生成完整WorkflowSchema] VV --\u003e WW[节点实例化] WW --\u003e XX[NodeBuilder.Build] XX --\u003e YY[创建具体节点实例] YY --\u003e ZZ[工作流执行引擎] subgraph \"验证器详细功能\" D1[ValidateConnections检查节点连接完整性] E1[DetectCycles检测工作流中的循环依赖] F1[节点配置验证检查必填字段和参数合法性] G1[CheckRefVariable验证变量引用的有效性] H1[ValidateNestedFlows检查批处理/循环嵌套限制] I1[CheckGlobalVariables验证全局变量类型匹配] J1[CheckSubWorkFlowTerminatePlan验证子工作流终止策略] end D -.-\u003e D1 E -.-\u003e E1 F -.-\u003e F1 G -.-\u003e G1 H -.-\u003e H1 I -.-\u003e I1 J -.-\u003e J1 subgraph \"NodeAdaptor转换细节\" W1[解析节点特定配置] --\u003e W2[转换输入参数类型] W2 --\u003e W3[转换输出定义类型] W3 --\u003e W4[设置节点内部Config] W4 --\u003e W5[调用通用类型转换函数] end W -.-\u003e W1 subgraph \"执行时节点类型\" YY1[InvokableNode普通执行节点] YY2[StreamableNode流式处理节点] YY3[TransformableNode数据转换节点] YY4[CollectableNode数据收集节点] end YY -.-\u003e YY1 YY -.-\u003e YY2 YY -.-\u003e YY3 YY -.-\u003e YY4 style A fill:#e3f2fd style C fill:#ffebee style K fill:#fff3e0 style VV fill:#e8f5e8 style ZZ fill:#f3e5f5 style L fill:#ffcdd2 前端交互层：前端 Canvas层是用户交互的起点，Canvas画布承载着用户的可视化配置，其中包含 Node（以vo.Node结构体表示）和Edge连接关系，这里的关键问题是\"节点样式：哪些固定字段？表单形式？\"，实际上每个节点都有标准化的元数据定义（如节点类型、显示名称、图标等固定字段）和动态的配置表单（根据节点类型展示不同的参数配置界面），前端schema采用灵活的JSON结构来适应各种节点类型的配置需求。\n验证层：验证层通过CanvasValidator对画布结构进行全面检查，包括节点连接完整性、循环依赖检测、配置合法性验证等多个维度，确保只有结构正确的工作流才能进入后续的转换和执行阶段，如果验证失败，系统会返回具体的错误信息给前端，帮助用户快速定位和修正问题。\n转换层：转换层是整个架构的核心枢纽，负责\"后端保存，workflow运行\"的关键转换过程，通过CanvasToWorkflowSchema函数协调整个转换流程，其中最重要的是NodeType到节点Config的转换，这通过NodeAdaptor接口实现，每个节点类型都有对应的适配器负责将前端的灵活配置转换为后端的强类型NodeSchema结构，实现了\"前端schema -\u003e 后端schema\"的标准化转换。\n节点实例化层：实例化层通过NodeBuilder接口将抽象的NodeSchema转换为具体的可执行节点实例，这里的关键是NodeSchema.Configs字段必须实现NodeBuilder接口，从而能够根据配置信息创建实际的节点对象，实现了\"后端schema -\u003e 节点实例\"的最终转换，为执行层提供了统一的节点实例接口。\n执行层：执行层是整个流程的最终目标，节点实例通过实现InvokableNode等执行接口来提供具体的业务逻辑处理能力，工作流引擎负责按照既定的执行顺序调度各个节点，处理数据流转和状态管理，最终产生业务执行结果并返回给用户。\n工作流校验 2.1 工作流验证流程 2.1.1 核心验证流程 graph LR A[画布预处理] --\u003e B[连接验证] --\u003e C[循环检测] --\u003e D[嵌套验证] --\u003e E[变量检查] --\u003e F[全局变量] --\u003e G[终止策略] 2.1.2 完整验证流程 %% 点击 “绘图” 按钮即可预览 graph LR A[\"1. 画布预处理• JSON反序列化• 清理孤立节点• 创建验证器实例\"] --\u003e H[\"2. 连接关系验证ValidateConnections\"] H --\u003e H1[\"• 检查节点连接完整性• 验证端口连接正确性• 检查分支节点完整性\"] H1 --\u003e I{发现问题?} I --\u003e|是| Z[\"返回验证错误\"] I --\u003e|否| J[\"3. 循环依赖检测DetectCycles\"] J --\u003e J1[\"• 构建依赖关系图• DFS算法检测环• 标识循环路径\"] J1 --\u003e K{发现循环?} K --\u003e|是| Z K --\u003e|否| L[\"4. 嵌套流程验证ValidateNestedFlows\"] L --\u003e L1[\"• 检查批处理节点嵌套• 验证循环节点嵌套• 防止过深嵌套\"] L1 --\u003e M{嵌套违规?} M --\u003e|是| Z M --\u003e|否| N[\"5. 引用变量检查CheckRefVariable\"] N --\u003e N1[\"• 验证变量可达性• 检查参数名规范• 验证作用域正确性\"] N1 --\u003e O{变量引用错误?} O --\u003e|是| Z O --\u003e|否| P[\"6. 全局变量验证CheckGlobalVariables\"] P --\u003e P1[\"• 验证变量类型匹配• 检查数组元素类型• 验证变量声明\"] P1 --\u003e Q{全局变量错误?} Q --\u003e|是| Z Q --\u003e|否| R[\"7. 子工作流终止策略CheckSubWorkFlowTerminatePlanType\"] R --\u003e R1[\"• 验证终止计划配置• 检查版本一致性• 验证子工作流存在性\"] R1 --\u003e S{终止策略错误?} S --\u003e|是| Z S --\u003e|否| T[\"主工作流验证完成\"] T --\u003e U[\"子工作流递归验证\"] U --\u003e U1[\"• 解析画布获取子工作流• 筛选项目级工作流• 批量获取工作流信息\"] U1 --\u003e U2[\"对每个子工作流重复验证流程\"] U2 --\u003e V[\"汇总所有验证结果\"] V --\u003e W[\"错误信息转换• Issue -\u003e ValidateErrorData• 节点错误/路径错误分类\"] W --\u003e X[\"返回验证结果ValidateTreeResponse\"] style A fill:#e1f5fe style H fill:#e8f5e8 style J fill:#e8f5e8 style L fill:#e8f5e8 style N fill:#e8f5e8 style P fill:#e8f5e8 style R fill:#e8f5e8 style U fill:#fff8e1 style Z fill:#ffebee 2.1.3 工作流验证流程技术实现总结 Coze Studio 的工作流验证采用分层递进式验证架构，从 API 层的 ValidateTree 接口开始，经过应用服务层的参数预处理，最终调用领域服务层的核心验证引擎 validateWorkflowTree。验证流程包含七个关键步骤：\n1. 画布预处理阶段 - 首先将 JSON 格式的画布结构反序列化为内存对象，然后调用 adaptor.PruneIsolatedNodes 清理没有连接关系的孤立节点，最后创建配置完整的 CanvasValidator 验证器实例并执行可达性分析，构建节点间的连通关系图。\n2. 连接关系验证 - ValidateConnections 方法通过遍历所有节点和边，构建出度映射表和端口映射表来实现。对于每个节点，检查其输出端口是否正确连接，特别是分支节点（如条件判断、错误处理）必须确保所有期望的端口都有连接。算法会递归验证嵌套节点的连接关系，确保数据流的完整性。\n3. 循环依赖检测 - DetectCycles 使用深度优先搜索（DFS）算法实现。首先构建反向依赖关系图（controlSuccessors），然后对每个未访问的节点启动 DFS 遍历。在遍历过程中维护当前路径栈，当发现路径中已存在的节点时，即检测到循环依赖，算法会提取并返回完整的循环路径。\n4. 嵌套流程验证 - ValidateNestedFlows 通过检查可达性分析结果中的 nestedReachability 结构实现。如果一个节点既有嵌套结构，又在其嵌套结构中还有更深层的嵌套（即 len(nestedReachableNodes.nestedReachability) \u003e 0），则判定为违反嵌套规则，防止批处理和循环节点的过度嵌套导致执行异常。\n5. 引用变量检查 - CheckRefVariable 采用递归作用域分析算法。定义内部函数 inputBlockVerify 解析每个输入参数的引用信息，检查引用的节点是否在当前或父级作用域的可达范围内。通过 combinedReachable 映射表合并当前层级和父级可达节点，实现作用域继承机制。同时验证参数名称的规范性（必须以字母开头，只能包含字母数字下划线）。\n6. 全局变量验证 - CheckGlobalVariables 首先收集所有变量分配节点（NodeTypeVariableAssigner）的变量定义，然后通过 VariablesMetaGetter 获取应用或智能体的变量元数据进行对比。验证包括基础类型匹配和数组元素类型的深度检查，确保工作流中使用的全局变量与系统定义一致。\n7. 子工作流终止策略验证 - CheckSubWorkFlowTerminatePlanType 通过递归收集所有子工作流节点，分别获取草稿版本和已发布版本的画布信息。对每个子工作流，查找其结束节点的终止计划配置，与当前节点的终止类型进行匹配验证，确保子工作流的输出处理策略与调用方期望一致。\n整个验证过程采用快速失败策略，任何步骤发现问题立即返回错误信息，同时支持递归子工作流验证，通过 getAllSubWorkflowIdentities 提取所有子工作流标识，对每个子工作流重复执行完整的验证流程，最终汇总所有验证结果，确保整个工作流树的结构完整性、逻辑正确性和执行安全性。\n",
  "wordCount" : "3254",
  "inLanguage": "en",
  "image": "https://swimmingliu.cn/papermod-cover.png","datePublished": "2025-08-07T23:27:35+08:00",
  "dateModified": "2025-08-07T23:27:35+08:00",
  "author":[{
    "@type": "Person",
    "name": "SwimmingLiu"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://swimmingliu.cn/posts/job/coze-workflow-analysis/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "SwimmingLiu's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://swimmingliu.cn/images/swimmingliu_icon.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://swimmingliu.cn/" accesskey="h" title="𝓢𝔀𝓲𝓶𝓶𝓲𝓷𝓰𝓛𝓲𝓾&#39;𝓼 𝓑𝓵𝓸𝓰 (Alt + H)">
                <img src="https://swimmingliu.cn/images/swimmingliu_icon.png" alt="" aria-label="logo"
                    height="30">𝓢𝔀𝓲𝓶𝓶𝓲𝓷𝓰𝓛𝓲𝓾&#39;𝓼 𝓑𝓵𝓸𝓰</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://swimmingliu.cn/index.html" title="🏡 Home">
                    <span>🏡 Home</span>
                </a>
            </li>
            <li>
                <a href="https://swimmingliu.cn/search/" title="🔍 Search">
                    <span>🔍 Search</span>
                </a>
            </li>
            <li>
                <a href="https://swimmingliu.cn/posts/" title="🗒️ Posts">
                    <span>🗒️ Posts</span>
                </a>
            </li>
            <li>
                <a href="https://swimmingliu.cn/archives/" title="📃 Archive">
                    <span>📃 Archive</span>
                </a>
            </li>
            <li>
                <a href="https://swimmingliu.cn/tags/" title="📑 Tags">
                    <span>📑 Tags</span>
                </a>
            </li>
            <li>
                <a href="https://bento.me/swimmingliu" title="👨🏻‍🎓 About Me">
                    <span>👨🏻‍🎓 About Me</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
            <li>
                <a href="https://www.emojisearch.app/" title="Emoji">
                    <span>Emoji</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://swimmingliu.cn/">Home</a>&nbsp;»&nbsp;<a href="https://swimmingliu.cn/posts/">📚 Posts</a>&nbsp;»&nbsp;<a href="https://swimmingliu.cn/posts/job/">💻 Job</a></div>
    <h1 class="post-title entry-hint-parent">
      Coze工作流分析
    </h1>
    <div class="post-meta"><span title='2025-08-07 23:27:35 +0800 CST'>August 7, 2025</span>&nbsp;·&nbsp;16 min&nbsp;·&nbsp;SwimmingLiu

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#coze%e5%b7%a5%e4%bd%9c%e6%b5%81-qa" aria-label="Coze工作流-QA">Coze工作流-QA</a><ul>
                        
                <li>
                    <a href="#%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%ae%a1%e7%90%86" aria-label="工作流管理">工作流管理</a><ul>
                        
                <li>
                    <a href="#11%e7%94%bb%e5%b8%83%e5%92%8c%e5%90%8e%e7%ab%af%e7%bb%93%e6%9e%84" aria-label="1.1 画布和后端结构">1.1 画布和后端结构</a><ul>
                        
                <li>
                    <a href="#111%e8%8a%82%e7%82%b9%e6%95%b0%e6%8d%ae" aria-label="1.1.1 节点数据">1.1.1 节点数据</a></li>
                <li>
                    <a href="#112%e8%be%b9%e6%95%b0%e6%8d%ae" aria-label="1.1.2 边数据">1.1.2 边数据</a></li>
                <li>
                    <a href="#113%e5%a4%a7%e8%af%ad%e8%a8%80%e6%a8%a1%e5%9e%8b%e8%8a%82%e7%82%b9notetypellm" aria-label="1.1.3 大语言模型节点 (NoteTypeLLM)">1.1.3 大语言模型节点 (NoteTypeLLM)</a><ul>
                        
                <li>
                    <a href="#llm%e8%8a%82%e7%82%b9%e7%b1%bb%e5%9b%be%e5%a6%82%e4%b8%8b%e5%9b%be%e6%89%80%e7%a4%ba" aria-label="LLM节点类图如下图所示">LLM节点类图如下图所示</a></li>
                <li>
                    <a href="#llm%e5%8f%82%e6%95%b0-simplellmparam" aria-label="LLM参数 - SimpleLLMParam">LLM参数 - SimpleLLMParam</a></li>
                <li>
                    <a href="#llm%e4%b8%ad%e7%9a%84%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8%e5%8f%82%e6%95%b0fcparam" aria-label="LLM中的函数调用参数 **FcParam**">LLM中的函数调用参数 **FcParam**</a></li></ul>
                </li>
                <li>
                    <a href="#114blockinput%e7%bb%93%e6%9e%84" aria-label="1.1.4 BlockInput结构">1.1.4 BlockInput结构</a></li>
                <li>
                    <a href="#115%e7%9f%a5%e8%af%86%e5%ba%93%e8%8a%82%e7%82%b9rag" aria-label="1.1.5 知识库节点 (RAG)">1.1.5 知识库节点 (RAG)</a><ul>
                        
                <li>
                    <a href="#rag%e5%ae%8c%e6%95%b4%e6%b5%81%e7%a8%8b%e5%9b%be" aria-label="RAG完整流程图">RAG完整流程图</a></li>
                <li>
                    <a href="#%e5%90%91%e9%87%8f%e6%a3%80%e7%b4%a2%e8%a7%84%e5%88%99" aria-label="向量检索规则">向量检索规则</a></li>
                <li>
                    <a href="#rerank%e8%a7%84%e5%88%99" aria-label="ReRank 规则">ReRank 规则</a></li>
                <li>
                    <a href="#%e7%9f%a5%e8%af%86%e5%ba%93%e8%8a%82%e7%82%b9%e7%bb%93%e6%9e%84" aria-label="知识库节点结构">知识库节点结构</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#12%e5%a6%82%e4%bd%95%e4%bb%8e%e7%94%bb%e5%b8%83%e8%bd%ac%e6%8d%a2%e4%b8%ba%e5%90%8e%e7%ab%af%e7%b1%bb%e5%a6%82%e4%bd%95%e8%bd%ac%e6%8d%a2%e4%b8%ba%e6%89%a7%e8%a1%8c%e6%80%81" aria-label="1.2 如何从画布转换为后端类？如何转换为执行态？">1.2 如何从画布转换为后端类？如何转换为执行态？</a><ul>
                        
                <li>
                    <a href="#121%e8%bd%ac%e6%8d%a2%e6%b5%81%e7%a8%8b%e5%9b%be" aria-label="1.2.1 转换流程图">1.2.1 转换流程图</a></li>
                <li>
                    <a href="#122%e8%bd%ac%e6%8d%a2%e5%90%8e%e7%9a%84nodeschema%e7%bb%93%e6%9e%84" aria-label="1.2.2 转换后的NodeSchema结构">1.2.2 转换后的NodeSchema结构</a></li>
                <li>
                    <a href="#123%e8%bd%ac%e6%8d%a2%e7%bb%93%e6%9e%84%e5%89%8d%e5%90%8e%e5%af%b9%e6%af%94" aria-label="1.2.3 转换结构前后对比">1.2.3 转换结构前后对比</a></li></ul>
                </li>
                <li>
                    <a href="#13%e5%b7%a5%e4%bd%9c%e6%b5%81%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b%e5%88%86%e6%9e%90" aria-label="1.3 工作流执行过程分析">1.3 工作流执行过程分析</a><ul>
                        <ul>
                        
                <li>
                    <a href="#%e5%b7%a5%e4%bd%9c%e6%b5%81%e6%89%a7%e8%a1%8c%e5%9b%be%e7%bb%86%e8%8a%82" aria-label="工作流执行图 (细节)">工作流执行图 (细节)</a></li></ul>
                    </ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%b7%a5%e4%bd%9c%e6%b5%81%e6%a0%a1%e9%aa%8c" aria-label="工作流校验">工作流校验</a><ul>
                        
                <li>
                    <a href="#21%e5%b7%a5%e4%bd%9c%e6%b5%81%e9%aa%8c%e8%af%81%e6%b5%81%e7%a8%8b" aria-label="2.1 工作流验证流程">2.1 工作流验证流程</a><ul>
                        
                <li>
                    <a href="#211%e6%a0%b8%e5%bf%83%e9%aa%8c%e8%af%81%e6%b5%81%e7%a8%8b" aria-label="2.1.1 核心验证流程">2.1.1 核心验证流程</a></li>
                <li>
                    <a href="#212%e5%ae%8c%e6%95%b4%e9%aa%8c%e8%af%81%e6%b5%81%e7%a8%8b" aria-label="2.1.2 完整验证流程">2.1.2 完整验证流程</a></li>
                <li>
                    <a href="#213%e5%b7%a5%e4%bd%9c%e6%b5%81%e9%aa%8c%e8%af%81%e6%b5%81%e7%a8%8b%e6%8a%80%e6%9c%af%e5%ae%9e%e7%8e%b0%e6%80%bb%e7%bb%93" aria-label="2.1.3 工作流验证流程技术实现总结">2.1.3 工作流验证流程技术实现总结</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>
  <div class="post-content"><h1 id="coze工作流-qa">Coze工作流-QA<a hidden class="anchor" aria-hidden="true" href="#coze工作流-qa">#</a></h1>
<blockquote>
<p>工作流可以分为三个大板块：工作流管理 (前后端交互-画布存储)、工作流校验、工作流执行</p></blockquote>
<h2 id="工作流管理">工作流管理<a hidden class="anchor" aria-hidden="true" href="#工作流管理">#</a></h2>
<blockquote>
<p>对于前端来讲，工作流就是一张canvas画布。用户可以在画布中，创建不同功能的节点。</p></blockquote>
<blockquote>
<p>节点类型可以分为：开始和结束节点 （默认）、LLM节点、子工作流 (嵌套)、插件 (外部工具-例如MCP、OCR)、业务逻辑节点 (选择、循环、分类、批处理(并发)、变量聚合)、数据库节点(SQL、CRUD)、知识库节点(RAG、增删、变量赋值)、图像处理节点、音视频处理节点、组件(JSON序列化、HTTP请求)、定时触发器节点(定时触发任务)</p></blockquote>
<p>工作流大体执行流程如下</p>
<pre class="mermaid">graph TD
    subgraph "前端Canvas层"
        A[Canvas画布<br/>用户可视化配置] --> B[Node节点<br/>vo.Node结构体]
        A --> C[Edge连接<br/>节点间关系]
        B --> D[节点样式：哪些固定字段？<br/>表单形式？]
    end
    
    subgraph "验证层"
        E[Canvas结构验证<br/>CanvasValidator] --> F{验证通过?}
        F -->|失败| G[返回错误信息]
        G --> H[前端显示错误提示]
    end
    
    subgraph "转换层"
        I[后端保存，workflow运行<br/>CanvasToWorkflowSchema] --> J[NodeType -> 节点Config<br/>通过NodeAdaptor接口]
        J --> K[前端schema -> 后端schema<br/>schema.NodeSchema]
    end
    
    subgraph "实例化层"
        L[节点实例化<br/>NodeBuilder接口] --> M[NodeSchema.Configs<br/>实现NodeBuilder接口]
        M --> N[后端schema -> 节点实例<br/>具体节点对象]
    end
    
    subgraph "执行层"
        O[节点运行<br/>InvokableNode等接口] --> P[业务逻辑<br/>具体执行逻辑]
        P --> Q[结果输出<br/>返回执行结果]
    end
    
    A --> E
    F -->|通过| I
    K --> L
    N --> O
    
    style A fill:#e3f2fd
    style E fill:#ffebee
    style I fill:#fff3e0
    style L fill:#e8f5e8
    style O fill:#f3e5f5
</pre>

<h3 id="11画布和后端结构">1.1 画布和后端结构<a hidden class="anchor" aria-hidden="true" href="#11画布和后端结构">#</a></h3>
<p>前端的画布采用DSL (JSON) 形式存储，每次更新画布都是将DSL传给后端。DSL的后端结构如下所示，主要包含节点 (node)、 边 (edge)、 版本</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Canvas</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Nodes</span>    <span class="p">[]</span><span class="o">*</span><span class="nx">Node</span> <span class="s">`json:&#34;nodes&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Edges</span>    <span class="p">[]</span><span class="o">*</span><span class="nx">Edge</span> <span class="s">`json:&#34;edges&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Versions</span> <span class="kt">any</span>     <span class="s">`json:&#34;versions&#34;`</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="111节点数据">1.1.1 节点数据<a hidden class="anchor" aria-hidden="true" href="#111节点数据">#</a></h4>
<p>画布中的节点会转换为后端中 <code>backend/domain/workflow/entity/vo/canvas.go</code> 中的 Node 结构体， 后端存储的结构体如下</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Node 工作流节点的完整定义</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 节点是工作流的基本执行单元，每个节点代表一个特定的功能或操作</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Node</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 节点的唯一标识符，用于在画布中定位和引用节点</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ID</span>      <span class="kt">string</span>    <span class="s">`json:&#34;id&#34;`</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 节点类型，决定节点的功能和行为（如LLM、API调用、条件判断等）</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Type</span>    <span class="nx">BlockType</span> <span class="s">`json:&#34;type&#34;`</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 节点的元数据信息，包含前端显示相关的配置 (前端的一些extendInfo)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Meta</span>    <span class="kt">any</span>       <span class="s">`json:&#34;meta&#34;`</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 节点的核心数据，包含输入输出配置和具体参数，例如LLM的配置、MCP的配置、异常处理</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Data</span>    <span class="o">*</span><span class="nx">Data</span>     <span class="s">`json:&#34;data&#34;`</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 子节点列表，用于复合节点（如循环、条件分支）的嵌套结构</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Blocks</span>  <span class="p">[]</span><span class="o">*</span><span class="nx">Node</span>   <span class="s">`json:&#34;blocks,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 节点内部的连线，用于复杂节点的内部逻辑连接</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Edges</span>   <span class="p">[]</span><span class="o">*</span><span class="nx">Edge</span>   <span class="s">`json:&#34;edges,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 节点的版本号，用于节点定义的版本控制</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Version</span> <span class="kt">string</span>    <span class="s">`json:&#34;version,omitempty&#34;`</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 父节点引用，不序列化到JSON，用于内存中的树形结构导航</span>
</span></span><span class="line"><span class="cl">	<span class="nx">parent</span> <span class="o">*</span><span class="nx">Node</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>节点的核心数据<code>Data</code>如下所示</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Data</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 节点的显示元数据，如标题、icon等</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Meta</span>    <span class="o">*</span><span class="nx">NodeMeta</span> <span class="s">`json:&#34;nodeMeta,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 节点的输出定义，可以是 []*Variable 或 []*Param 类型</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Outputs</span> <span class="p">[]</span><span class="kt">any</span>     <span class="s">`json:&#34;outputs,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 节点的输入配置，包含所有输入参数和设置</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Inputs</span>  <span class="o">*</span><span class="nx">Inputs</span>   <span class="s">`json:&#34;inputs,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 节点在画布上的尺寸信息，用于前端显示</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Size</span>    <span class="kt">any</span>       <span class="s">`json:&#34;size,omitempty&#34;`</span>     
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>节点的输入参数 <code>inputs</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Inputs 节点输入配置的综合结构</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 这是一个联合结构，包含了所有可能的节点输入配置，不同类型的节点使用不同的字段子集</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Inputs</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 通用输入配置</span>
</span></span><span class="line"><span class="cl">	<span class="nx">InputParameters</span>    <span class="p">[]</span><span class="o">*</span><span class="nx">Param</span>        <span class="s">`json:&#34;inputParameters&#34;`</span>              <span class="c1">// 节点的输入参数列表，定义节点需要的数据输入</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Content</span>            <span class="o">*</span><span class="nx">BlockInput</span>     <span class="s">`json:&#34;content&#34;`</span>                      <span class="c1">// 节点的主要内容输入，通常用于文本处理或提示词</span>
</span></span><span class="line"><span class="cl">	<span class="nx">TerminatePlan</span>      <span class="o">*</span><span class="nx">TerminatePlan</span>  <span class="s">`json:&#34;terminatePlan,omitempty&#34;`</span>      <span class="c1">// 终止计划，定义节点完成后的行为</span>
</span></span><span class="line"><span class="cl">	<span class="nx">StreamingOutput</span>    <span class="kt">bool</span>            <span class="s">`json:&#34;streamingOutput,omitempty&#34;`</span>    <span class="c1">// 是否启用流式输出，用于实时返回处理结果</span>
</span></span><span class="line"><span class="cl">	<span class="nx">CallTransferVoice</span>  <span class="kt">bool</span>            <span class="s">`json:&#34;callTransferVoice,omitempty&#34;`</span>  <span class="c1">// 语音通话转接设置，用于语音相关节点</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ChatHistoryWriting</span> <span class="kt">string</span>          <span class="s">`json:&#34;chatHistoryWriting,omitempty&#34;`</span> <span class="c1">// 聊天历史记录写入配置</span>
</span></span><span class="line"><span class="cl">	<span class="nx">LLMParam</span>           <span class="kt">any</span>             <span class="s">`json:&#34;llmParam,omitempty&#34;`</span>           <span class="c1">// LLM参数，可能是LLMParam、IntentDetectorLLMParam或QALLMParam类型</span>
</span></span><span class="line"><span class="cl">	<span class="nx">FCParam</span>            <span class="o">*</span><span class="nx">FCParam</span>        <span class="s">`json:&#34;fcParam,omitempty&#34;`</span>            <span class="c1">// 功能调用参数，用于配置工作流、插件或知识库的调用</span>
</span></span><span class="line"><span class="cl">	<span class="nx">SettingOnError</span>     <span class="o">*</span><span class="nx">SettingOnError</span> <span class="s">`json:&#34;settingOnError,omitempty&#34;`</span>     <span class="c1">// 错误处理配置，定义节点出错时的处理策略</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 循环控制相关</span>
</span></span><span class="line"><span class="cl">	<span class="nx">LoopType</span>           <span class="nx">LoopType</span>    <span class="s">`json:&#34;loopType,omitempty&#34;`</span>           <span class="c1">// 循环类型：数组循环、计数循环或无限循环</span>
</span></span><span class="line"><span class="cl">	<span class="nx">LoopCount</span>          <span class="o">*</span><span class="nx">BlockInput</span> <span class="s">`json:&#34;loopCount,omitempty&#34;`</span>          <span class="c1">// 循环次数，用于计数循环</span>
</span></span><span class="line"><span class="cl">	<span class="nx">VariableParameters</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Param</span>    <span class="s">`json:&#34;variableParameters,omitempty&#34;`</span> <span class="c1">// 循环变量参数</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 条件分支相关</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Branches</span> <span class="p">[]</span><span class="o">*</span><span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Condition</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">Logic</span>      <span class="nx">LogicType</span>    <span class="s">`json:&#34;logic&#34;`</span>      <span class="c1">// 条件逻辑：AND或OR</span>
</span></span><span class="line"><span class="cl">			<span class="nx">Conditions</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Condition</span> <span class="s">`json:&#34;conditions&#34;`</span> <span class="c1">// 具体的条件列表</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="s">`json:&#34;condition&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="s">`json:&#34;branches,omitempty&#34;`</span> <span class="c1">// 分支条件配置，用于条件判断节点</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 批处理配置</span>
</span></span><span class="line"><span class="cl">	<span class="nx">NodeBatchInfo</span> <span class="o">*</span><span class="nx">NodeBatch</span> <span class="s">`json:&#34;batch,omitempty&#34;`</span> <span class="c1">// 节点批处理模式配置</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 特定节点类型的配置（使用嵌入结构体实现类型多态）</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="nx">TextProcessor</span>      <span class="c1">// 文本处理器配置：拼接、分割等操作</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="nx">SubWorkflow</span>        <span class="c1">// 子工作流配置：调用其他工作流</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="nx">IntentDetector</span>     <span class="c1">// 意图检测配置：识别用户意图</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="nx">DatabaseNode</span>       <span class="c1">// 数据库操作配置：增删改查</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="nx">HttpRequestNode</span>    <span class="c1">// HTTP请求配置：API调用</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="nx">KnowledgeIndexer</span>   <span class="c1">// 知识库索引配置：文档处理和索引</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="nx">CodeRunner</span>         <span class="c1">// 代码执行器配置：运行自定义代码</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="nx">PluginAPIParam</span>     <span class="c1">// 插件API参数配置</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="nx">VariableAggregator</span> <span class="c1">// 变量聚合器配置：合并多个变量</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="nx">VariableAssigner</span>   <span class="c1">// 变量赋值器配置：设置变量值</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="nx">QA</span>                 <span class="c1">// 问答节点配置：处理问题和答案</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="nx">Batch</span>              <span class="c1">// 批处理配置：批量处理数据</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="nx">Comment</span>            <span class="c1">// 注释节点配置：添加说明文字</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">OutputSchema</span> <span class="kt">string</span> <span class="s">`json:&#34;outputSchema,omitempty&#34;`</span> <span class="c1">// 输出模式定义，描述节点输出数据的结构</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="112边数据">1.1.2 边数据<a hidden class="anchor" aria-hidden="true" href="#112边数据">#</a></h4>
<p>边主要是包含输入节点、输出节点的ID，还有输入的端口和输出的端口 （输入输出端口都是只存在于<code>业务逻辑节点</code>中）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Edge 工作流连线定义</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 连线定义了节点之间的连接关系，确定工作流的执行顺序和数据流向</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Edge</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 源节点ID，连线的起始节点</span>
</span></span><span class="line"><span class="cl">	<span class="nx">SourceNodeID</span> <span class="kt">string</span> <span class="s">`json:&#34;sourceNodeID&#34;`</span> 
</span></span><span class="line"><span class="cl">    <span class="c1">// 目标节点ID，连线的终止节点</span>
</span></span><span class="line"><span class="cl">	<span class="nx">TargetNodeID</span> <span class="kt">string</span> <span class="s">`json:&#34;targetNodeID&#34;`</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 源端口ID，用于多输出端口的节点，指定具体的输出端口</span>
</span></span><span class="line"><span class="cl">	<span class="nx">SourcePortID</span> <span class="kt">string</span> <span class="s">`json:&#34;sourcePortID,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 目标端口ID，用于多输入端口的节点，指定具体的输入端口</span>
</span></span><span class="line"><span class="cl">	<span class="nx">TargetPortID</span> <span class="kt">string</span> <span class="s">`json:&#34;targetPortID,omitempty&#34;`</span> 
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="113大语言模型节点notetypellm">1.1.3 大语言模型节点 (NoteTypeLLM)<a hidden class="anchor" aria-hidden="true" href="#113大语言模型节点notetypellm">#</a></h4>
<h5 id="llm节点类图如下图所示">LLM节点类图如下图所示<a hidden class="anchor" aria-hidden="true" href="#llm节点类图如下图所示">#</a></h5>
<pre class="mermaid">classDiagram
    class Inputs {
        +Param[] inputParameters
        +SettingOnError settingOnError
        +NodeBatch nodeBatchInfo
        +any llmParam
        +LLM llmSpecificConfig
    }

    class LLM {
        +FCParam fcParam
    }

    class LLMParam {
        +Param[] parameters
    }

    class SimpleLLMParam {
        +string generationDiversity
        +int maxTokens
        +string modelName
        +int64 modelType
        +ResponseFormat responseFormat
        +string systemPrompt
        +float64 temperature
        +float64 topP
    }

    class Param {
        +string name
        +BlockInput input
        +BlockInput left
        +BlockInput right
        +BlockInput[] variables
    }

    class BlockInput {
        +VariableType type
        +AssistType assistType
        +any schema
        +BlockInputValue value
    }

    class BlockInputValue {
        +BlockInputValueType type
        +any content
        +any rawMeta
    }

    class BlockInputReference {
        +string blockID
        +string name
        +string[] path
        +RefSourceType source
    }

    class FCParam {
        +WorkflowFCParam workflowFCParam
        +PluginFCParam pluginFCParam
        +KnowledgeFCParam knowledgeFCParam
    }

    class SettingOnError {
        +ErrorHandlingStrategy strategy
        +string customMessage
    }

    class NodeBatch {
        +int batchSize
        +int concurrentSize
    }

    Inputs --> LLM : "contains"
    Inputs --> LLMParam : "llmParam as"
    Inputs --> SimpleLLMParam : "llmParam as"
    Inputs --> Param : "contains"
    Inputs --> SettingOnError : "contains"
    Inputs --> NodeBatch : "contains"
    
    LLM --> FCParam : "contains"
    LLMParam --> Param : "contains"
    Param --> BlockInput : "contains"
    BlockInput --> BlockInputValue : "contains"
    BlockInputValue --> BlockInputReference : "content as"

    note for Inputs "LLM节点的所有输入配置<br/>包含通用输入和LLM专用配置"
    note for LLMParam "标准LLM参数列表<br/>每个参数都是Param类型"
    note for SimpleLLMParam "简化的LLM参数结构<br/>直接包含所有LLM配置字段"
    note for FCParam "函数调用能力配置<br/>LLM可调用的外部工具"
</pre>

<h5 id="llm参数-simplellmparam">LLM参数 - <code>SimpleLLMParam</code><a hidden class="anchor" aria-hidden="true" href="#llm参数-simplellmparam">#</a></h5>
<p><code>SimpleLLMParam</code>如下所示，主要包含多样性程度、最大Token、模型名称、模型类型、响应格式、系统提示词、<code>Temperature</code>温度、<code>TopP</code> 核采样参数</p>
<p>【注意】<code>generationDiversity</code>多样性程度 是高层的预设策略（如&quot;创意/平衡/精确&quot;模式），而 <code>temperature</code>和 <code>topP</code>是底层的具体算法参数，前者通过内置的参数组合来简化配置，后者则提供精确的随机性控制（temperature调节概率分布平滑度，topP限制候选词汇范围）。</p>
<p>简单说：generationDiversity = &ldquo;我要什么风格&rdquo;，temperature = &ldquo;要多随机&rdquo;，topP = &ldquo;考虑多少词汇&rdquo;。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// SimpleLLMParam 简化的大语言模型参数配置</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 提供直接的字段映射方式配置LLM参数，适用于简单的模型调用场景</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">SimpleLLMParam</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// GenerationDiversity 生成多样性配置</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 控制模型输出的多样性程度，影响生成内容的创新性</span>
</span></span><span class="line"><span class="cl">	<span class="nx">GenerationDiversity</span> <span class="kt">string</span> <span class="s">`json:&#34;generationDiversity&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// MaxTokens 最大生成令牌数</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 限制模型单次生成的最大token数量，控制输出长度</span>
</span></span><span class="line"><span class="cl">	<span class="nx">MaxTokens</span> <span class="kt">int</span> <span class="s">`json:&#34;maxTokens&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ModelName 模型名称</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 指定要使用的具体模型名称，如gpt-3.5-turbo、gpt-4等</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ModelName</span> <span class="kt">string</span> <span class="s">`json:&#34;modelName&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ModelType 模型类型标识</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 用于区分不同类型的模型，如聊天模型、补全模型等</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ModelType</span> <span class="kt">int64</span> <span class="s">`json:&#34;modelType&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ResponseFormat 响应格式配置</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 指定模型输出的格式，支持文本、JSON、Markdown等格式</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ResponseFormat</span> <span class="nx">model</span><span class="p">.</span><span class="nx">ResponseFormat</span> <span class="s">`json:&#34;responseFormat&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// SystemPrompt 系统提示词</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 定义模型的系统级指令，设定模型的角色和行为规范</span>
</span></span><span class="line"><span class="cl">	<span class="nx">SystemPrompt</span> <span class="kt">string</span> <span class="s">`json:&#34;systemPrompt&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Temperature 温度参数</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 控制模型输出的随机性，范围通常为0.0-1.0，值越高输出越随机</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 通过调整softmax概率分布的平滑度来影响词汇选择的确定性</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Temperature</span> <span class="kt">float64</span> <span class="s">`json:&#34;temperature&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// TopP 核采样参数</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 控制模型生成时考虑的词汇概率质量，影响输出的多样性和质量</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 通过设置概率累积阈值来限制候选词汇的范围，范围通常为0.0-1.0</span>
</span></span><span class="line"><span class="cl">	<span class="nx">TopP</span> <span class="kt">float64</span> <span class="s">`json:&#34;topP&#34;`</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h5 id="llm中的函数调用参数fcparam">LLM中的函数调用参数 <code>**FcParam**</code><a hidden class="anchor" aria-hidden="true" href="#llm中的函数调用参数fcparam">#</a></h5>
<p>functionCalling （大语言模型节点的“技能”）中需要用到的参数</p>
<pre class="mermaid">graph TD
    A[用户输入问题] --> B[LLM节点接收]
    B --> C{LLM分析是否需要调用工具}
    
    C -->|需要调用| D[FCParam 工具配置]
    C -->|不需要| E[直接生成回答]
    
    D --> F[WorkflowFCParam<br/>子工作流调用]
    D --> G[PluginFCParam<br/>插件API调用]  
    D --> H[KnowledgeFCParam<br/>知识库检索]
    
    F --> F1[配置可调用的子工作流列表]
    F --> F2[定义请求/响应参数]
    F --> F3[执行子工作流]
    
    G --> G1[配置可调用的插件API列表]
    G --> G2[定义API参数和响应格式]
    G --> G3[调用第三方插件服务]
    
    H --> H1[配置知识库列表]
    H --> H2[设置检索策略<br/>TopK/MinScore/搜索模式]
    H --> H3[执行知识库检索]
    
    F3 --> I[工具执行结果]
    G3 --> I
    H3 --> I
    
    I --> J[LLM整合工具结果]
    J --> K[生成最终回答]
    E --> K
    
    K --> L[返回给用户]
    
    style A fill:#e1f5fe
    style D fill:#fff3e0
    style F fill:#f3e5f5
    style G fill:#e8f5e8
    style H fill:#fce4ec
    style K fill:#e0f2f1
</pre>

<p>函数调用参数 <code>FcParam</code>主要包含三种模式：子工作流调用、插件API调用、知识库检索</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// FCParam 函数调用参数配置</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 用于配置工作流中不同类型的函数调用能力，包括子工作流调用、插件API调用和知识库检索调用</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">FCParam</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// WorkflowFCParam 工作流函数调用参数配置</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 配置当前工作流可以调用的子工作流列表及其参数设置</span>
</span></span><span class="line"><span class="cl">	<span class="nx">WorkflowFCParam</span> <span class="o">*</span><span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// WorkflowList 可调用的工作流列表</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 每个工作流项包含工作流标识、版本信息和函数调用设置</span>
</span></span><span class="line"><span class="cl">		<span class="nx">WorkflowList</span> <span class="p">[]</span><span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// WorkflowID 工作流唯一标识符</span>
</span></span><span class="line"><span class="cl">			<span class="nx">WorkflowID</span> <span class="kt">string</span> <span class="s">`json:&#34;workflow_id&#34;`</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// WorkflowVersion 工作流版本号</span>
</span></span><span class="line"><span class="cl">			<span class="nx">WorkflowVersion</span> <span class="kt">string</span> <span class="s">`json:&#34;workflow_version&#34;`</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// PluginID 关联的插件ID（如果工作流基于插件）</span>
</span></span><span class="line"><span class="cl">			<span class="nx">PluginID</span> <span class="kt">string</span> <span class="s">`json:&#34;plugin_id&#34;`</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// PluginVersion 插件版本号</span>
</span></span><span class="line"><span class="cl">			<span class="nx">PluginVersion</span> <span class="kt">string</span> <span class="s">`json:&#34;plugin_version&#34;`</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// IsDraft 是否为草稿版本</span>
</span></span><span class="line"><span class="cl">			<span class="nx">IsDraft</span> <span class="kt">bool</span> <span class="s">`json:&#34;is_draft&#34;`</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// FCSetting 函数调用设置</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 定义调用该工作流时的请求和响应参数结构</span>
</span></span><span class="line"><span class="cl">			<span class="nx">FCSetting</span> <span class="o">*</span><span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// RequestParameters 请求参数列表</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// 定义调用工作流时需要传入的参数</span>
</span></span><span class="line"><span class="cl">				<span class="nx">RequestParameters</span> <span class="p">[]</span><span class="o">*</span><span class="nx">workflow</span><span class="p">.</span><span class="nx">APIParameter</span> <span class="s">`json:&#34;request_params&#34;`</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// ResponseParameters 响应参数列表</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// 定义工作流执行完成后返回的参数</span>
</span></span><span class="line"><span class="cl">				<span class="nx">ResponseParameters</span> <span class="p">[]</span><span class="o">*</span><span class="nx">workflow</span><span class="p">.</span><span class="nx">APIParameter</span> <span class="s">`json:&#34;response_params&#34;`</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="s">`json:&#34;fc_setting,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="s">`json:&#34;workflowList,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="s">`json:&#34;workflowFCParam,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// PluginFCParam 插件函数调用参数配置</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 配置当前工作流可以调用的插件API列表及其参数设置</span>
</span></span><span class="line"><span class="cl">	<span class="nx">PluginFCParam</span> <span class="o">*</span><span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// PluginList 可调用的插件列表</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 每个插件项包含插件标识、API信息和函数调用设置</span>
</span></span><span class="line"><span class="cl">		<span class="nx">PluginList</span> <span class="p">[]</span><span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// PluginID 插件唯一标识符</span>
</span></span><span class="line"><span class="cl">			<span class="nx">PluginID</span> <span class="kt">string</span> <span class="s">`json:&#34;plugin_id&#34;`</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// ApiId API接口唯一标识符</span>
</span></span><span class="line"><span class="cl">			<span class="nx">ApiId</span> <span class="kt">string</span> <span class="s">`json:&#34;api_id&#34;`</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// ApiName API接口名称</span>
</span></span><span class="line"><span class="cl">			<span class="nx">ApiName</span> <span class="kt">string</span> <span class="s">`json:&#34;api_name&#34;`</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// PluginVersion 插件版本号</span>
</span></span><span class="line"><span class="cl">			<span class="nx">PluginVersion</span> <span class="kt">string</span> <span class="s">`json:&#34;plugin_version&#34;`</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// IsDraft 是否为草稿版本</span>
</span></span><span class="line"><span class="cl">			<span class="nx">IsDraft</span> <span class="kt">bool</span> <span class="s">`json:&#34;is_draft&#34;`</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// FCSetting 函数调用设置</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 定义调用该插件API时的请求和响应参数结构</span>
</span></span><span class="line"><span class="cl">			<span class="nx">FCSetting</span> <span class="o">*</span><span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// RequestParameters 请求参数列表</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// 定义调用插件API时需要传入的参数</span>
</span></span><span class="line"><span class="cl">				<span class="nx">RequestParameters</span> <span class="p">[]</span><span class="o">*</span><span class="nx">workflow</span><span class="p">.</span><span class="nx">APIParameter</span> <span class="s">`json:&#34;request_params&#34;`</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// ResponseParameters 响应参数列表</span>
</span></span><span class="line"><span class="cl">				<span class="c1">// 定义插件API执行完成后返回的参数</span>
</span></span><span class="line"><span class="cl">				<span class="nx">ResponseParameters</span> <span class="p">[]</span><span class="o">*</span><span class="nx">workflow</span><span class="p">.</span><span class="nx">APIParameter</span> <span class="s">`json:&#34;response_params&#34;`</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="s">`json:&#34;fc_setting,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="s">`json:&#34;pluginFCParam,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// KnowledgeFCParam 知识库函数调用参数配置</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 配置当前工作流的知识库检索功能及其全局设置</span>
</span></span><span class="line"><span class="cl">	<span class="nx">KnowledgeFCParam</span> <span class="o">*</span><span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// GlobalSetting 知识库检索全局设置</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 定义知识库检索的通用配置参数</span>
</span></span><span class="line"><span class="cl">		<span class="nx">GlobalSetting</span> <span class="o">*</span><span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// SearchMode 搜索模式</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 定义知识库检索使用的搜索算法模式</span>
</span></span><span class="line"><span class="cl">			<span class="nx">SearchMode</span> <span class="kt">int64</span> <span class="s">`json:&#34;search_mode&#34;`</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// TopK 返回结果数量</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 定义知识库检索返回的最大结果数量</span>
</span></span><span class="line"><span class="cl">			<span class="nx">TopK</span> <span class="kt">int64</span> <span class="s">`json:&#34;top_k&#34;`</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// MinScore 最小相似度分数</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// 定义知识库检索结果的最小相似度阈值</span>
</span></span><span class="line"><span class="cl">			<span class="nx">MinScore</span> <span class="kt">float64</span> <span class="s">`json:&#34;min_score&#34;`</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// UseNL2SQL 是否启用自然语言转SQL功能</span>
</span></span><span class="line"><span class="cl">			<span class="nx">UseNL2SQL</span> <span class="kt">bool</span> <span class="s">`json:&#34;use_nl2_sql&#34;`</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// UseRewrite 是否启用查询重写功能</span>
</span></span><span class="line"><span class="cl">			<span class="nx">UseRewrite</span> <span class="kt">bool</span> <span class="s">`json:&#34;use_rewrite&#34;`</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// UseRerank 是否启用结果重排序功能</span>
</span></span><span class="line"><span class="cl">			<span class="nx">UseRerank</span> <span class="kt">bool</span> <span class="s">`json:&#34;use_rerank&#34;`</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// NoRecallReplyCustomizePrompt 无召回结果时的自定义回复提示词</span>
</span></span><span class="line"><span class="cl">			<span class="nx">NoRecallReplyCustomizePrompt</span> <span class="kt">string</span> <span class="s">`json:&#34;no_recall_reply_customize_prompt&#34;`</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// NoRecallReplyMode 无召回结果时的回复模式</span>
</span></span><span class="line"><span class="cl">			<span class="nx">NoRecallReplyMode</span> <span class="kt">int64</span> <span class="s">`json:&#34;no_recall_reply_mode&#34;`</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="s">`json:&#34;global_setting,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// KnowledgeList 可检索的知识库列表</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 定义当前工作流可以检索的知识库集合</span>
</span></span><span class="line"><span class="cl">		<span class="nx">KnowledgeList</span> <span class="p">[]</span><span class="o">*</span><span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// ID 知识库唯一标识符</span>
</span></span><span class="line"><span class="cl">			<span class="nx">ID</span> <span class="kt">string</span> <span class="s">`json:&#34;id&#34;`</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="s">`json:&#34;knowledgeList,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="s">`json:&#34;knowledgeFCParam,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol>
<li>子工作流调用</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;workflowFCParam&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;workflowList&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;workflow_id&#34;</span><span class="p">:</span> <span class="s2">&#34;7509120431183544356&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;workflow_version&#34;</span><span class="p">:</span> <span class="s2">&#34;v0.0.1&#34;</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;plugin_id&#34;</span><span class="p">:</span> <span class="s2">&#34;7509121334769795126&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;is_draft&#34;</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;fc_setting&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&#34;request_params&#34;</span><span class="p">:</span> <span class="p">[</span><span class="err">...</span><span class="p">],</span>  <span class="c1">// 调用参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>          <span class="nt">&#34;response_params&#34;</span><span class="p">:</span> <span class="p">[</span><span class="err">...</span><span class="p">]</span>  <span class="c1">// 返回参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="2">
<li>插件API调用</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;pluginFCParam&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;pluginList&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;plugin_id&#34;</span><span class="p">:</span> <span class="s2">&#34;7509353177339133952&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;api_id&#34;</span><span class="p">:</span> <span class="s2">&#34;7509353598782816256&#34;</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;api_name&#34;</span><span class="p">:</span> <span class="s2">&#34;周公解梦&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;plugin_version&#34;</span><span class="p">:</span> <span class="s2">&#34;0&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;fc_setting&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&#34;request_params&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">            <span class="p">{</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;title&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&#34;desc&#34;</span><span class="p">:</span> <span class="s2">&#34;查询解梦标题，例如：梦见蛇&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&#34;type&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">              <span class="nt">&#34;is_required&#34;</span><span class="p">:</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">          <span class="p">],</span>
</span></span><span class="line"><span class="cl">          <span class="nt">&#34;response_params&#34;</span><span class="p">:</span> <span class="p">[</span><span class="err">...</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">]</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="3">
<li>知识库检索</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-json" data-lang="json"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nt">&#34;knowledgeFCParam&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;knowledgeList&#34;</span><span class="p">:</span> <span class="p">[</span>
</span></span><span class="line"><span class="cl">      <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;id&#34;</span><span class="p">:</span> <span class="s2">&#34;7512369185624686592&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="nt">&#34;name&#34;</span><span class="p">:</span> <span class="s2">&#34;旅游景点&#34;</span>
</span></span><span class="line"><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">],</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&#34;global_setting&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;top_k&#34;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="c1">// 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>      <span class="nt">&#34;min_score&#34;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;search_mode&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;use_rerank&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;use_rewrite&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;use_nl2_sql&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;no_recall_reply_mode&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="nt">&#34;no_recall_reply_customize_prompt&#34;</span><span class="p">:</span> <span class="s2">&#34;抱歉，您的问题超出了我的知识范围&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span></code></pre></div><h4 id="114blockinput结构">1.1.4 BlockInput结构<a hidden class="anchor" aria-hidden="true" href="#114blockinput结构">#</a></h4>
<p><code>BlockInput</code>是工作流系统中的数据绑定核心，它解决了一个关键问题：如何在工作流节点之间传递和配置数据。<code>BlockInput = &quot;这个输入框里放什么数据，从哪里来&quot;</code></p>
<pre class="mermaid">graph TD
    A[BlockInput 块输入配置] --> B[Type: 数据类型]
    A --> C[AssistType: 辅助类型]
    A --> D[Schema: 结构定义]
    A --> E[Value: 输入值配置]
    
    E --> F[BlockInputValue]
    F --> G[Type: 值类型]
    F --> H[Content: 具体内容]
    F --> I[RawMeta: 元数据]
    
    G --> G1[literal: 字面值]
    G --> G2[ref: 节点引用]
    G --> G3[object_ref: 对象引用]
    
    H --> H1[静态文本/数值]
    H --> H2[BlockInputReference]
    
    H2 --> J[BlockID: 源节点ID]
    H2 --> K[Name: 字段名称]
    H2 --> L[Path: 访问路径]
    H2 --> M[Source: 引用源类型]
    
    M --> M1[block-output: 节点输出]
    M --> M2[global_variable_app: 应用变量]
    M --> M3[global_variable_system: 系统变量]
    M --> M4[global_variable_user: 用户变量]
    
    N[实际使用场景] --> N1[静态配置: 固定值]
    N --> N2[动态绑定: 引用其他节点]
    N --> N3[模板渲染: 变量替换]
    N --> N4[复杂对象: 嵌套结构]
    
    style A fill:#e1f5fe
    style F fill:#fff3e0
    style H2 fill:#f3e5f5
    style N fill:#e8f5e8
</pre>

<p><code>BlockInput</code>结构如下所示</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">BlockInput</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Type</span>       <span class="nx">VariableType</span>     <span class="c1">// 数据类型：string、number、object等</span>
</span></span><span class="line"><span class="cl">    <span class="nx">AssistType</span> <span class="nx">AssistType</span>       <span class="c1">// 辅助类型：更具体的类型描述</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Schema</span>     <span class="kt">any</span>              <span class="c1">// 结构定义：复杂对象的内部结构</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Value</span>      <span class="o">*</span><span class="nx">BlockInputValue</span> <span class="c1">// 值配置：具体的数据来源</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>三种数据流来源：常量<code>literal</code>、节点引用<code>ref</code>、对象引用 <code>Object Ref</code></p>
<ol>
<li>常量<code>literal</code></li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="s">&#34;type&#34;</span><span class="p">:</span> <span class="s">&#34;string&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="s">&#34;value&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;type&#34;</span><span class="p">:</span> <span class="s">&#34;literal&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;content&#34;</span><span class="p">:</span> <span class="s">&#34;Hello World&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;rawMeta&#34;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#34;type&#34;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="2">
<li>节点引用<code>ref</code> (最常用的)</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="s">&#34;type&#34;</span><span class="p">:</span> <span class="s">&#34;string&#34;</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">  <span class="s">&#34;value&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;type&#34;</span><span class="p">:</span> <span class="s">&#34;ref&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;content&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="s">&#34;blockID&#34;</span><span class="p">:</span> <span class="s">&#34;100001&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="s">&#34;name&#34;</span><span class="p">:</span> <span class="s">&#34;output&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="s">&#34;source&#34;</span><span class="p">:</span> <span class="s">&#34;block-output&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><ol start="3">
<li> 对象引用</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="s">&#34;type&#34;</span><span class="p">:</span> <span class="s">&#34;object&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="s">&#34;schema&#34;</span><span class="p">:</span> <span class="p">[{</span><span class="s">&#34;name&#34;</span><span class="p">:</span> <span class="s">&#34;name&#34;</span><span class="p">,</span> <span class="s">&#34;type&#34;</span><span class="p">:</span> <span class="s">&#34;string&#34;</span><span class="p">}],</span>
</span></span><span class="line"><span class="cl">  <span class="s">&#34;value&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;type&#34;</span><span class="p">:</span> <span class="s">&#34;object_ref&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s">&#34;content&#34;</span><span class="p">:</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">      <span class="s">&#34;blockID&#34;</span><span class="p">:</span> <span class="s">&#34;100001&#34;</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">      <span class="s">&#34;name&#34;</span><span class="p">:</span> <span class="s">&#34;person&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">      <span class="s">&#34;source&#34;</span><span class="p">:</span> <span class="s">&#34;block-output&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="115知识库节点rag">1.1.5 知识库节点 (RAG)<a hidden class="anchor" aria-hidden="true" href="#115知识库节点rag">#</a></h4>
<h5 id="rag完整流程图">RAG完整流程图<a hidden class="anchor" aria-hidden="true" href="#rag完整流程图">#</a></h5>
<p>一个完整的RAG流程如下：</p>
<p>查询重写优化 （小模型）-&gt; 自然语言转SQL （NL2SQL）-&gt; 向量检索 (语义搜索/混合搜索/全量搜索) -&gt; 相似度过滤 (最小相似度阈值) -&gt; 结果重排序 (Rerank) -&gt; TopK结果截取 -&gt; 构建新的上下文提示词</p>
<pre class="mermaid">graph LR
    A[用户输入查询] --> B[查询预处理]
    
    B --> B1[UseRewrite: 查询重写]
    B1 --> B2[优化查询语义]
    B2 --> B3[UseNL2SQL: 自然语言转SQL]
    
    B3 --> C[向量检索阶段]
    C --> C1[文档向量化]
    C --> C2[查询向量化] 
    C1 --> C3[向量相似度计算]
    C2 --> C3
    
    C3 --> D[SearchMode: 搜索策略]
    D --> D1[0: 语义搜索<br/>Semantic Search]
    D --> D2[1: 混合搜索<br/>Hybrid Search]
    D --> D3[20: 全文搜索<br/>Full-text Search]
    
    D1 --> E[初步结果筛选]
    D2 --> E
    D3 --> E
    
    E --> E1[MinScore: 相似度过滤]
    E1 --> E2[过滤低质量结果]
    
    E2 --> F[UseRerank: 结果重排序]
    F --> F1[深度语义匹配]
    F1 --> F2[重新排序结果]
    
    F2 --> G[TopK: 结果截取]
    G --> G1[选择前K个最佳结果]
    
    G1 --> H{是否有合适结果?}
    H -->|有| I[构建增强上下文]
    H -->|无| J[NoRecallReplyMode处理]
    
    J --> J1[0: 使用自定义提示词]
    J --> J2[1: 其他处理模式]
    J1 --> K[返回无结果回复]
    J2 --> K
    
    I --> L[RAG生成阶段]
    L --> L1[组合查询+检索内容]
    L1 --> L2[LLM生成增强回答]
    
    L2 --> M[返回最终答案]
    K --> M
    
    style A fill:#e1f5fe
    style B fill:#fff3e0
    style C fill:#f3e5f5
    style D fill:#e8f5e8
    style F fill:#fce4ec
    style L fill:#e0f2f1
</pre>

<h5 id="向量检索规则">向量检索规则<a hidden class="anchor" aria-hidden="true" href="#向量检索规则">#</a></h5>
<pre class="mermaid">graph TD
    A[用户查询] --> B{SearchMode选择}
    
    B -->|0: 语义搜索| C[Semantic Search]
    B -->|1: 混合搜索| D[Hybrid Search]  
    B -->|20: 全文搜索| E[Full-text Search]
    
    C --> C1[Step1: 查询向量化]
    C1 --> C2[Embedding Model]
    C2 --> C3[Query Vector]
    
    C3 --> C4[Step2: 文档向量匹配]
    C4 --> C5[向量数据库]
    C5 --> C6[余弦相似度计算]
    
    D --> D1[Step1: 向量搜索路径]
    D --> D2[Step2: 关键词搜索路径]
    
    D1 --> D3[Embedding检索]
    D2 --> D4[BM25算法]
    D3 --> D5[结果融合算法]
    D4 --> D5
    
    E --> E1[Step1: 分词处理]
    E1 --> E2[分词器]
    E2 --> E3[Step2: 倒排索引]
    E3 --> E4[搜索引擎]
    E4 --> E5[TF-IDF评分]
    
    C6 --> F[语义理解强]
    D5 --> G[平衡精确性和语义]
    E5 --> H[关键词精确匹配]
    
    F --> I[最终检索结果]
    G --> I
    H --> I
    
    style C fill:#e1f5fe
    style D fill:#fff3e0
    style E fill:#f3e5f5
    style I fill:#e8f5e8
</pre>

<ol>
<li>
<p>语义搜索 （准）: 使用 Embedding 模型计算向量相似度，理解深层语义，处理同义词和概念匹配。</p>
</li>
<li>
<p>混合搜索 （全面）: 结合向量搜索 + BM25 关键词搜索，平衡语义理解和精确匹配。</p>
</li>
<li>
<p>全文搜索 （快）: 传统的倒排索引和TF-IDF，精确的关键词匹配，速度快</p>
</li>
</ol>
<p>【算法说明】</p>
<ul>
<li>Embedding向量检索：将文本通过编码器转为向量和DB中的向量计算cos相似度最后返回TopK的结果</li>
</ul>
<pre class="mermaid">graph TD
    A[文本输入] --> B[Embedding检索流程]
    
    B --> C[第一阶段: 向量化]
    C --> C1[分词和预处理]
    C1 --> C2[Transformer编码器]
    C2 --> C3[池化操作]
    C3 --> C4[归一化处理]
    C4 --> C5[生成向量表示]
    
    B --> D[第二阶段: 索引构建]
    D --> D1[向量维度优化]
    D1 --> D2[索引结构选择]
    D2 --> D3[HNSW/IVF/LSH]
    D3 --> D4[分布式存储]
    
    B --> E[第三阶段: 相似度检索]
    E --> E1[查询向量化]
    E1 --> E2[近似最近邻搜索]
    E2 --> E3[相似度计算]
    E3 --> E4[TopK结果返回]
    
    F[技术栈] --> F1[模型: BERT/Sentence-BERT]
    F --> F2[向量DB: Pinecone/Milvus/ElasticSearch]
    F --> F3[相似度: 余弦/点积/欧氏]
    F --> F4[索引: HNSW/IVF]
    
    style C fill:#e1f5fe
    style D fill:#fff3e0
    style E fill:#f3e5f5
    style F fill:#e8f5e8
</pre>

<ul>
<li>
<p>倒排索引：将文档切分成独立的词汇单元，建立从词汇到文档的映射索引</p>
</li>
<li>
<p>TF-IDF (词频-逆文档频率)：TF（词频）： 计算一个词在文档中出现的词次数， 用于衡量词汇的重要性。IDF （逆文档频率）：衡量词汇在整个语料库中的重要性。 </p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">TF</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="n">词汇t在文档d中出现的次数</span> <span class="o">/</span> <span class="n">文档d的总词数</span>
</span></span><span class="line"><span class="cl"><span class="n">IDF</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">=</span> <span class="n">log</span><span class="p">(</span><span class="n">文档总数</span> <span class="o">/</span> <span class="n">包含词汇t的文档数</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">TF</span><span class="o">-</span><span class="n">IDF</span> <span class="o">=</span> <span class="n">sigmoid</span> <span class="p">(</span><span class="n">TF</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="o">*</span> <span class="n">IDF</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
</span></span></code></pre></div><p>缺点：不能考虑词汇的位置，忽略了词汇的相关性；不利于稀疏性 （短文档很多词汇 <code>TF-IDF=0</code>）</p>
<ul>
<li>BM25 算法：在 <code>TF-IDF</code> (词频-逆文档频率) 基础上，解决了词频饱和问题和文档长度归一化问题。</li>
</ul>
<h5 id="rerank规则">ReRank 规则<a hidden class="anchor" aria-hidden="true" href="#rerank规则">#</a></h5>
<p>Rerank就是根据多个检索方式得到的结果进行整合，然后根据RRF算法重新排序的过程</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">RRF</span><span class="p">:</span> <span class="n">score</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">rank</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span> <span class="c1"># 默认 k = 60 </span>
</span></span></code></pre></div><p>rerank模型的时序图</p>
<pre class="mermaid">sequenceDiagram
    participant User as 用户
    participant RS as 检索服务<br/>RetrieveService
    participant QR as 查询重写<br/>QueryRewriter
    participant VS as 向量检索<br/>VectorStore
    participant ES as 全文检索<br/>ElasticSearch
    participant NL as NL2SQL检索<br/>NL2SQLEngine
    participant RK as 重排序器<br/>Reranker
    participant API as Rerank API<br/>VikingDB

    Note over User, API: 1. 初始化检索请求
    User->>RS: 发起检索请求<br/>(query, knowledgeIDs, strategy)
    RS->>RS: 构建检索上下文<br/>(RetrieveContext)

    Note over User, API: 2. 查询重写 (可选)
    alt 启用查询重写 && 有对话历史
        RS->>QR: 基于对话历史重写查询
        QR-->>RS: 返回重写后的查询
    end

    Note over User, API: 3. 并行多通道检索
    par 向量检索
        alt 语义检索 || 混合检索
            RS->>VS: 向量相似度检索
            VS->>VS: 1. 查询文本向量化
            VS->>VS: 2. 计算余弦相似度
            VS->>VS: 3. 返回TopK相似文档
            VS-->>RS: 向量检索结果<br/>(score: 0.0-1.0)
        end
    and 全文检索
        alt 全文检索 || 混合检索
            RS->>ES: 关键词匹配检索
            ES->>ES: 1. 分词和索引匹配
            ES->>ES: 2. 计算BM25分数
            ES->>ES: 3. 返回匹配文档
            ES-->>RS: ES检索结果<br/>(score: BM25)
        end
    and NL2SQL检索
        alt 启用NL2SQL
            RS->>NL: 自然语言转SQL查询
            NL->>NL: 1. 解析查询意图
            NL->>NL: 2. 生成SQL语句
            NL->>NL: 3. 执行结构化查询
            NL-->>RS: NL2SQL结果<br/>(score: 相关性分数)
        end
    end

    Note over User, API: 4. Rerank重排序
    RS->>RS: 整合多通道检索结果
    Note right of RS: 根据检索策略收集结果:<br/>- SearchTypeSemantic: 仅向量结果<br/>- SearchTypeFullText: 仅ES结果<br/>- SearchTypeHybrid: 向量+ES结果<br/>- 如启用NL2SQL: 额外添加NL2SQL结果

    RS->>RK: 调用Rerank服务
    Note right of RK: 传入参数:<br/>- Query: 原始查询或重写后查询<br/>- Data: 多通道检索结果数组<br/>- TopN: 最终返回数量

    alt VikingDB Reranker (深度学习模型)
        RK->>RK: 1. 扁平化所有检索结果
        RK->>RK: 2. 构造rerank请求<br/>{query, content, title}
        RK->>API: HTTP POST请求<br/>/api/knowledge/service/rerank
        API->>API: 1. 使用base-multilingual-rerank模型
        API->>API: 2. 计算query-document相关性分数
        API-->>RK: 返回每个文档的新分数<br/>{scores: [0.8, 0.6, 0.9, ...]}
        RK->>RK: 3. 按新分数降序排序
        RK->>RK: 4. 截取TopN结果
    else RRF Reranker (排名融合算法)
        RK->>RK: 1. 为每个通道的结果按排名计算分数
        Note right of RK: RRF公式: score = 1/(rank + k)<br/>其中k=60为默认参数
        RK->>RK: 2. 同一文档取最高分数
        RK->>RK: 3. 按分数降序排序
        RK->>RK: 4. 截取TopN结果
    end

    RK-->>RS: 返回重排序结果<br/>{sortedData, tokenUsage}

    Note over User, API: 5. 结果过滤与封装
    RS->>RS: 1. 应用最小分数阈值过滤<br/>(score < minScore的文档被移除)
    RS->>RS: 2. 更新文档分数为rerank分数
    RS->>RS: 3. 封装最终检索结果

    RS-->>User: 返回最终检索结果<br/>(按相关性排序的文档列表)
</pre>

<h5 id="知识库节点结构">知识库节点结构<a hidden class="anchor" aria-hidden="true" href="#知识库节点结构">#</a></h5>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Knowledge 知识库节点配置</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 用于配置独立的知识库检索节点，定义数据源参数和处理策略</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 与LLM节点中的KnowledgeFCParam不同，这是专门的知识库检索步骤</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Knowledge</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// DatasetParam 数据集参数配置</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 定义知识库的数据源配置，包括数据库连接、文件路径等信息</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 每个Param包含具体的数据源配置项</span>
</span></span><span class="line"><span class="cl">	<span class="nx">DatasetParam</span> <span class="p">[]</span><span class="o">*</span><span class="nx">Param</span> <span class="s">`json:&#34;datasetParam,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// StrategyParam 知识库处理策略参数</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 定义文档解析、分块、索引等各个环节的处理策略和参数</span>
</span></span><span class="line"><span class="cl">	<span class="nx">StrategyParam</span> <span class="nx">StrategyParam</span> <span class="s">`json:&#34;strategyParam,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// StrategyParam 知识库处理策略参数配置</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 定义知识库从文档解析到向量索引的完整处理流程策略</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">StrategyParam</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ParsingStrategy 文档解析策略配置</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 定义如何解析和提取不同类型文档的内容</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ParsingStrategy</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// ParsingType 解析类型</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 定义文档解析的方式，如自动识别、手动指定等</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 常见值：auto（自动识别）、manual（手动指定）、custom（自定义）</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ParsingType</span> <span class="kt">string</span> <span class="s">`json:&#34;parsingType,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// ImageExtraction 是否提取图片</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 控制是否从文档中提取图片内容进行处理</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// true表示提取图片，false表示忽略图片内容</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ImageExtraction</span> <span class="kt">bool</span> <span class="s">`json:&#34;imageExtraction&#34;`</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// TableExtraction 是否提取表格</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 控制是否从文档中提取表格结构和数据</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// true表示解析表格结构，false表示将表格视为普通文本</span>
</span></span><span class="line"><span class="cl">		<span class="nx">TableExtraction</span> <span class="kt">bool</span> <span class="s">`json:&#34;tableExtraction&#34;`</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// ImageOcr 是否启用图片OCR识别</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 控制是否对提取的图片进行光学字符识别</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// true表示对图片进行OCR文字识别，false表示忽略图片中的文字</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ImageOcr</span> <span class="kt">bool</span> <span class="s">`json:&#34;imageOcr&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="s">`json:&#34;parsingStrategy,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// ChunkStrategy 文档分块策略配置</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 定义如何将长文档切分成适合向量化的小块</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ChunkStrategy</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// ChunkType 分块类型</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 定义文档分块的策略类型</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 常见值：fixed（固定长度）、semantic（语义分块）、sentence（句子分块）</span>
</span></span><span class="line"><span class="cl">		<span class="nx">ChunkType</span> <span class="kt">string</span> <span class="s">`json:&#34;chunkType,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// SeparatorType 分隔符类型</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 定义用于分块的分隔符类型</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 常见值：auto（自动选择）、newline（换行符）、paragraph（段落）、custom（自定义）</span>
</span></span><span class="line"><span class="cl">		<span class="nx">SeparatorType</span> <span class="kt">string</span> <span class="s">`json:&#34;separatorType,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Separator 自定义分隔符</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 当SeparatorType为custom时，指定具体的分隔符字符串</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Separator</span> <span class="kt">string</span> <span class="s">`json:&#34;separator,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// MaxToken 最大令牌数</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 定义每个文档块的最大token数量，控制块的大小</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 通常设置为模型的上下文窗口大小，如512、1024等</span>
</span></span><span class="line"><span class="cl">		<span class="nx">MaxToken</span> <span class="kt">int64</span> <span class="s">`json:&#34;maxToken,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Overlap 重叠比例</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 定义相邻文档块之间的重叠比例，避免语义信息在边界处丢失</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 取值范围0.0-1.0，常见值为0.1-0.2（10%-20%重叠）</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Overlap</span> <span class="kt">float64</span> <span class="s">`json:&#34;overlap,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="s">`json:&#34;chunkStrategy,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// IndexStrategy 索引策略配置</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 定义向量索引的构建策略，如索引类型、参数等</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 具体结构依赖于使用的向量数据库类型（如HNSW、IVF等）</span>
</span></span><span class="line"><span class="cl">	<span class="nx">IndexStrategy</span> <span class="kt">any</span> <span class="s">`json:&#34;indexStrategy&#34;`</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="12如何从画布转换为后端类如何转换为执行态">1.2 如何从画布转换为后端类？如何转换为执行态？<a hidden class="anchor" aria-hidden="true" href="#12如何从画布转换为后端类如何转换为执行态">#</a></h3>
<p>前端传入画布的 DSL语言（JSON）给后端之后，会解析为上方的后端结构。画布中的每个节点都会变成 <code>canvas.go</code>中的 <code>Node</code>结构体。但是转换后的 <code>Node</code>结构体只是一个存储态，如果需要执行工作流还需要将 <code>Node</code>结构体从存储态转为运行态。后端 schema 的 <code>NodeSchema</code>结构体就是 针对用于表达工作流的运行态的</p>
<h4 id="121转换流程图">1.2.1 转换流程图<a hidden class="anchor" aria-hidden="true" href="#121转换流程图">#</a></h4>
<pre class="mermaid">graph TD
    A[Canvas画布] --> B[CanvasToWorkflowSchema]
    B --> C[移除孤立节点]
    C --> D[遍历Canvas Nodes]
    
    D --> E{节点类型判断}
    E -->|子工作流| F[toSubWorkflowNodeSchema]
    E -->|普通节点| G[获取NodeAdaptor]
    
    G --> H[调用Adaptor.Adapt方法]
    H --> I{节点有子节点?}
    I -->|是| J[递归转换子节点]
    I -->|否| K[转换输入输出类型]
    
    J --> L[设置层次关系]
    L --> K
    K --> M[设置异常处理配置]
    M --> N[生成NodeSchema]
    
    F --> N
    N --> O[收集所有NodeSchema]
    O --> P[转换连接边]
    P --> Q[标准化端口]
    Q --> R[构建分支信息]
    R --> S[WorkflowSchema]
    
    subgraph "NodeAdaptor转换细节"
        H1[解析节点配置] --> H2[转换输入参数]
        H2 --> H3[转换输出定义]
        H3 --> H4[设置节点特定Config]
        H4 --> H5[调用SetInputsForNodeSchema]
        H5 --> H6[调用SetOutputTypesForNodeSchema]
    end
    
    H --> H1
    
    subgraph "类型转换细节"
        T1[CanvasBlockInputToTypeInfo] --> T2[解析基础类型]
        T2 --> T3[处理复杂对象类型]
        T3 --> T4[处理数组类型]
        T4 --> T5[处理文件类型]
        T5 --> T6[生成TypeInfo]
        
        U1[CanvasBlockInputToFieldInfo] --> U2[分析数据来源]
        U2 --> U3{来源类型}
        U3 -->|静态值| U4[创建LiteralFieldInfo]
        U3 -->|节点引用| U5[创建ReferenceFieldInfo]
        U3 -->|模板字符串| U6[创建TemplateFieldInfo]
        U4 --> U7[生成FieldInfo]
        U5 --> U7
        U6 --> U7
    end
    
    K --> T1
    K --> U1
    
    style A fill:#e1f5fe
    style S fill:#c8e6c9
    style H fill:#fff3e0
    style N fill:#fce4ec
</pre>

<h4 id="122转换后的nodeschema结构">1.2.2 转换后的NodeSchema结构<a hidden class="anchor" aria-hidden="true" href="#122转换后的nodeschema结构">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// NodeSchema 工作流节点的统一描述和配置结构</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 包含实例化一个节点所需的所有信息，是Canvas Node转换后的后端执行结构</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">NodeSchema</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Key 节点在Eino图中的唯一标识符</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 节点在执行过程中可能需要这个信息，例如：</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// - 使用此Key查询工作流状态中属于当前节点的数据</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Key</span> <span class="nx">vo</span><span class="p">.</span><span class="nx">NodeKey</span> <span class="s">`json:&#34;key&#34;`</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Name 节点在Canvas画布上指定的显示名称</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 节点可能会在Canvas上显示这个名称作为输入/输出的一部分</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Name</span> <span class="kt">string</span> <span class="s">`json:&#34;name&#34;`</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Type 节点的类型标识</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 对应entity.NodeType枚举，决定节点的具体行为和功能</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Type</span> <span class="nx">entity</span><span class="p">.</span><span class="nx">NodeType</span> <span class="s">`json:&#34;type&#34;`</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Configs 节点特定的配置信息</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 每个节点类型定义自己的配置结构体，不包含字段映射或静态值信息</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 这些配置是节点实现的内部配置，与工作流编排无关</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 实际类型应该实现两个接口：</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// - NodeAdaptor: 提供从vo.Node到NodeSchema的转换</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// - NodeBuilder: 提供从NodeSchema到实际节点实例的实例化</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Configs</span> <span class="kt">any</span> <span class="s">`json:&#34;configs,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// InputTypes 节点输入字段的类型信息映射</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 键为字段名，值为对应的类型信息，用于类型检查和验证</span>
</span></span><span class="line"><span class="cl">	<span class="nx">InputTypes</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">vo</span><span class="p">.</span><span class="nx">TypeInfo</span> <span class="s">`json:&#34;input_types,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// InputSources 节点输入字段的映射信息</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 定义每个输入字段的数据来源，如来自其他节点的输出或静态值</span>
</span></span><span class="line"><span class="cl">	<span class="nx">InputSources</span> <span class="p">[]</span><span class="o">*</span><span class="nx">vo</span><span class="p">.</span><span class="nx">FieldInfo</span> <span class="s">`json:&#34;input_sources,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// OutputTypes 节点输出字段的类型信息映射</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 键为字段名，值为对应的类型信息，用于下游节点的类型推导</span>
</span></span><span class="line"><span class="cl">	<span class="nx">OutputTypes</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">vo</span><span class="p">.</span><span class="nx">TypeInfo</span> <span class="s">`json:&#34;output_types,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// OutputSources 节点输出字段的映射信息</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 注意：仅适用于复合节点，如NodeTypeBatch或NodeTypeLoop</span>
</span></span><span class="line"><span class="cl">	<span class="nx">OutputSources</span> <span class="p">[]</span><span class="o">*</span><span class="nx">vo</span><span class="p">.</span><span class="nx">FieldInfo</span> <span class="s">`json:&#34;output_sources,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// ExceptionConfigs 节点的异常处理策略配置</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 包含超时、重试、错误处理类型等异常处理相关设置</span>
</span></span><span class="line"><span class="cl">	<span class="nx">ExceptionConfigs</span> <span class="o">*</span><span class="nx">ExceptionConfig</span> <span class="s">`json:&#34;exception_configs,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// StreamConfigs 节点的流式处理特性配置</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 定义节点是否支持流式输入/输出等流处理能力</span>
</span></span><span class="line"><span class="cl">	<span class="nx">StreamConfigs</span> <span class="o">*</span><span class="nx">StreamConfig</span> <span class="s">`json:&#34;stream_configs,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// SubWorkflowBasic 子工作流的基本信息</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 仅当节点类型为NodeTypeSubWorkflow时使用</span>
</span></span><span class="line"><span class="cl">	<span class="nx">SubWorkflowBasic</span> <span class="o">*</span><span class="nx">entity</span><span class="p">.</span><span class="nx">WorkflowBasic</span> <span class="s">`json:&#34;sub_workflow_basic,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// SubWorkflowSchema 子工作流的完整Schema信息</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 仅当节点类型为NodeTypeSubWorkflow时使用，包含子工作流的完整定义</span>
</span></span><span class="line"><span class="cl">	<span class="nx">SubWorkflowSchema</span> <span class="o">*</span><span class="nx">WorkflowSchema</span> <span class="s">`json:&#34;sub_workflow_schema,omitempty&#34;`</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// FullSources 节点输入字段映射来源的完整信息</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 包含更详细的信息，如字段是否为流式字段，或字段是否为包含子字段映射的对象</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 用于需要处理流式输入的节点</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 在NodeMeta中设置InputSourceAware = true来启用此功能</span>
</span></span><span class="line"><span class="cl">	<span class="nx">FullSources</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">SourceInfo</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Lambda 直接设置节点为Eino Lambda</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 注意：不可序列化，仅用于内部测试</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Lambda</span> <span class="o">*</span><span class="nx">compose</span><span class="p">.</span><span class="nx">Lambda</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h4 id="123转换结构前后对比">1.2.3 转换结构前后对比<a hidden class="anchor" aria-hidden="true" href="#123转换结构前后对比">#</a></h4>
<pre class="mermaid">graph LR
    subgraph "前端Canvas结构"
        A[Canvas画布]
        A --> B[Node节点]
        A --> C[Edge连接]
        
        B --> D[ID: string]
        B --> E[Type: string]
        B --> F[Data配置]
        
        F --> G[Meta元数据]
        F --> H[Inputs输入]
        F --> I[Outputs输出]
        
        H --> J[InputParameters参数列表]
        H --> K[LLMParam模型参数]
        H --> L[SettingOnError错误处理]
        
        J --> M[Param参数]
        M --> N[Name: string]
        M --> O[Input: BlockInput]
        
        O --> P[Type: VariableType]
        O --> Q[Value: BlockInputValue]
        
        Q --> R[Type: literal/ref/object_ref]
        Q --> S[Content: any]
        
        I --> T[Variable变量]
        T --> U[Name: string]
        T --> V[Type: VariableType]
        T --> W[Schema: any]
    end
    
    subgraph "转换过程"
        X[CanvasToWorkflowSchema] --> Y[NodeToNodeSchema]
        Y --> Z[NodeAdaptor.Adapt]
        Z --> AA[SetInputsForNodeSchema]
        Z --> BB[SetOutputTypesForNodeSchema]
        AA --> CC[CanvasBlockInputToTypeInfo]
        AA --> DD[CanvasBlockInputToFieldInfo]
        BB --> EE[CanvasVariableToTypeInfo]
    end
    
    subgraph "后端NodeSchema结构"
        FF[WorkflowSchema工作流]
        FF --> GG[NodeSchema节点]
        FF --> HH[Connection连接]
        FF --> II[Branch分支]
        
        GG --> JJ[Key: NodeKey]
        GG --> KK[Type: NodeType枚举]
        GG --> LL[Configs: 节点配置]
        
        GG --> MM[InputTypes类型映射]
        GG --> NN[InputSources来源映射]
        GG --> OO[OutputTypes输出类型]
        
        MM --> PP["map[string]*TypeInfo"]
        NN --> QQ["[]*FieldInfo"]
        OO --> RR["map[string]*TypeInfo"]
        
        QQ --> SS[FieldInfo字段信息]
        SS --> TT[Path: FieldPath]
        SS --> UU[Source: 数据来源]
        SS --> VV[Type: Literal/Reference/Template]
        
        PP --> WW[TypeInfo类型信息]
        WW --> XX[Type: DataType枚举]
        WW --> YY[Properties: 对象属性]
        WW --> ZZ[ElemTypeInfo: 数组元素类型]
        
        GG --> AAA[ExceptionConfigs异常配置]
        AAA --> BBB[TimeoutMS: 超时时间]
        AAA --> CCC[MaxRetry: 重试次数]
        AAA --> DDD[ProcessType: 处理类型]
    end
    
    A -.转换.-> FF
    B -.适配器转换.-> GG
    C -.标准化.-> HH
    O -.类型转换.-> WW
    Q -.来源分析.-> SS
    
    style A fill:#e3f2fd
    style FF fill:#e8f5e8
    style X fill:#fff3e0
    style Y fill:#fff3e0
    style Z fill:#fff3e0
</pre>

<p>【转换过程】</p>
<p><code>canvas</code>到 <code>NodeSchema</code>的转换过程是Coze Studio工作流系统中的核心架构设计，它通过适配器模式将前端面向用户的可视化画布结构转换为后端面向执行的标准化 <code>Schema</code>结构。在这个过程中，前端的 <code>Canvas</code>包含了用户在画布上拖拽配置的 <code>Node</code>节点和 <code>Edge</code>连接，每个<code>Node</code>节点包含字符串类型的<code>ID</code>和<code>Type</code>、用户配置的<code>Data</code>数据（包括输入参数、输出定义、元数据等），这些数据以灵活的 `any `类型和嵌套结构存储以适应前端的动态配置需求；而转换后的<code>NodeSchema</code>则采用强类型的结构化设计，将<strong>节点类型</strong>转换为<strong>枚举</strong>、将<strong>输入输出</strong>转换为 <code>TypeInfo</code>和<code>FieldInfo</code>的映射关系、将<strong>数据来源分析</strong>为<strong>具体的引用路径</strong>，并添加了执行时需要的 <strong>异常处理配置</strong>、<strong>流式处理配置</strong>等运行时信息。这个转换过程之所以必要，是因为前端Canvas需要保持高度的灵活性和可扩展性来支持用户的各种配置操作和UI交互，而后端执行引擎则需要严格的类型安全、明确的数据流向和优化的执行性能，两者的设计目标和约束条件完全不同，因此需要通过这个转换层来实现前后端的解耦，同时确保用户在画布上的每一个配置都能准确无误地转换为可执行的工作流逻辑，并且这种转换过程还支持复杂的节点类型（如子工作流、批处理节点）、数据类型推导、字段映射分析等高级特性，为整个工作流系统的稳定运行和功能扩展提供了坚实的基础。</p>
<h3 id="13工作流执行过程分析">1.3 工作流执行过程分析<a hidden class="anchor" aria-hidden="true" href="#13工作流执行过程分析">#</a></h3>
<h5 id="工作流执行图细节">工作流执行图 (细节)<a hidden class="anchor" aria-hidden="true" href="#工作流执行图细节">#</a></h5>
<pre class="mermaid">graph TD
    A[Canvas画布] --> B{保存/运行工作流}
    
    B --> C[画布结构验证]
    C --> D[连接关系验证]
    C --> E[闭环检测]
    C --> F[节点配置验证]
    C --> G[变量引用验证]
    C --> H[嵌套流程验证]
    C --> I[全局变量验证]
    C --> J[子工作流终止计划验证]
    
    D --> K{验证通过?}
    E --> K
    F --> K
    G --> K
    H --> K
    I --> K
    J --> K
    
    K -->|否| L[返回验证错误]
    L --> M[前端显示错误信息]
    
    K -->|是| N[Canvas转换为WorkflowSchema]
    N --> O[移除孤立节点]
    O --> P[遍历Canvas Nodes]
    
    P --> Q{节点类型判断}
    Q -->|子工作流| R[递归解析子工作流Canvas]
    Q -->|批处理节点| S[解析批处理模式]
    Q -->|普通节点| T[获取NodeAdaptor]
    
    R --> U[toSubWorkflowNodeSchema]
    S --> V[parseBatchMode生成批处理结构]
    T --> W[调用Adaptor.Adapt方法]
    
    U --> X[设置异常处理配置]
    V --> X
    W --> X
    
    X --> Y{节点有子节点?}
    Y -->|是| Z[递归转换子节点]
    Y -->|否| AA[转换输入输出类型]
    
    Z --> BB[设置层次关系映射]
    BB --> AA
    
    AA --> CC[SetInputsForNodeSchema]
    AA --> DD[SetOutputTypesForNodeSchema]
    
    CC --> EE[CanvasBlockInputToTypeInfo]
    CC --> FF[CanvasBlockInputToFieldInfo]
    DD --> GG[CanvasVariableToTypeInfo]
    
    EE --> HH[解析基础类型]
    EE --> II[处理复杂对象类型]
    EE --> JJ[处理数组类型]
    EE --> KK[处理文件类型]
    
    FF --> LL[分析数据来源]
    LL --> MM{来源类型}
    MM -->|静态值| NN[创建LiteralFieldInfo]
    MM -->|节点引用| OO[创建ReferenceFieldInfo]
    MM -->|模板字符串| PP[创建TemplateFieldInfo]
    
    HH --> QQ[生成NodeSchema]
    II --> QQ
    JJ --> QQ
    KK --> QQ
    NN --> QQ
    OO --> QQ
    PP --> QQ
    GG --> QQ
    
    QQ --> RR[收集所有NodeSchema]
    RR --> SS[转换连接边EdgeToConnection]
    SS --> TT[标准化端口normalizePorts]
    TT --> UU[构建分支信息BuildBranches]
    UU --> VV[生成完整WorkflowSchema]
    
    VV --> WW[节点实例化]
    WW --> XX[NodeBuilder.Build]
    XX --> YY[创建具体节点实例]
    YY --> ZZ[工作流执行引擎]
    
    subgraph "验证器详细功能"
        D1[ValidateConnections<br/>检查节点连接完整性]
        E1[DetectCycles<br/>检测工作流中的循环依赖]
        F1[节点配置验证<br/>检查必填字段和参数合法性]
        G1[CheckRefVariable<br/>验证变量引用的有效性]
        H1[ValidateNestedFlows<br/>检查批处理/循环嵌套限制]
        I1[CheckGlobalVariables<br/>验证全局变量类型匹配]
        J1[CheckSubWorkFlowTerminatePlan<br/>验证子工作流终止策略]
    end
    
    D -.-> D1
    E -.-> E1
    F -.-> F1
    G -.-> G1
    H -.-> H1
    I -.-> I1
    J -.-> J1
    
    subgraph "NodeAdaptor转换细节"
        W1[解析节点特定配置] --> W2[转换输入参数类型]
        W2 --> W3[转换输出定义类型]
        W3 --> W4[设置节点内部Config]
        W4 --> W5[调用通用类型转换函数]
    end
    
    W -.-> W1
    
    subgraph "执行时节点类型"
        YY1[InvokableNode<br/>普通执行节点]
        YY2[StreamableNode<br/>流式处理节点]
        YY3[TransformableNode<br/>数据转换节点]
        YY4[CollectableNode<br/>数据收集节点]
    end
    
    YY -.-> YY1
    YY -.-> YY2
    YY -.-> YY3
    YY -.-> YY4
    
    style A fill:#e3f2fd
    style C fill:#ffebee
    style K fill:#fff3e0
    style VV fill:#e8f5e8
    style ZZ fill:#f3e5f5
    style L fill:#ffcdd2
</pre>

<ul>
<li>
<p><strong>前端交互层</strong>：前端 <code>Canvas</code>层是用户交互的起点，<code>Canvas</code>画布承载着用户的可视化配置，其中包含 <code>Node</code>（以<code>vo.Node</code>结构体表示）和<code>Edge</code>连接关系，这里的关键问题是&quot;节点样式：哪些固定字段？表单形式？&quot;，实际上每个节点都有标准化的元数据定义（如节点类型、显示名称、图标等固定字段）和动态的配置表单（根据节点类型展示不同的参数配置界面），前端<code>schema</code>采用灵活的JSON结构来适应各种节点类型的配置需求。</p>
</li>
<li>
<p><strong>验证层</strong>：验证层通过<code>CanvasValidator</code>对画布结构进行全面检查，包括节点连接完整性、循环依赖检测、配置合法性验证等多个维度，确保只有结构正确的工作流才能进入后续的转换和执行阶段，如果验证失败，系统会返回具体的错误信息给前端，帮助用户快速定位和修正问题。</p>
</li>
<li>
<p><strong>转换层</strong>：转换层是整个架构的核心枢纽，负责&quot;后端保存，workflow运行&quot;的关键转换过程，通过<code>CanvasToWorkflowSchema</code>函数协调整个转换流程，其中最重要的是<code>NodeType</code>到节点<code>Config</code>的转换，这通过<code>NodeAdaptor</code>接口实现，每个节点类型都有对应的适配器负责将前端的灵活配置转换为后端的强类型<code>NodeSchema</code>结构，实现了&quot;前端schema -&gt; 后端schema&quot;的标准化转换。</p>
</li>
<li>
<p><strong>节点实例化层</strong>：实例化层通过<code>NodeBuilder</code>接口将抽象的<code>NodeSchema</code>转换为具体的可执行节点实例，这里的关键是<code>NodeSchema.Configs</code>字段必须实现<code>NodeBuilder</code>接口，从而能够根据配置信息创建实际的节点对象，实现了&quot;后端schema -&gt; 节点实例&quot;的最终转换，为执行层提供了统一的节点实例接口。</p>
</li>
<li>
<p><strong>执行层</strong>：执行层是整个流程的最终目标，节点实例通过实现<code>InvokableNode</code>等执行接口来提供具体的业务逻辑处理能力，工作流引擎负责按照既定的执行顺序调度各个节点，处理数据流转和状态管理，最终产生业务执行结果并返回给用户。</p>
</li>
</ul>
<h2 id="工作流校验">工作流校验<a hidden class="anchor" aria-hidden="true" href="#工作流校验">#</a></h2>
<h3 id="21工作流验证流程">2.1 工作流验证流程<a hidden class="anchor" aria-hidden="true" href="#21工作流验证流程">#</a></h3>
<h4 id="211核心验证流程">2.1.1 核心验证流程<a hidden class="anchor" aria-hidden="true" href="#211核心验证流程">#</a></h4>
<pre class="mermaid">graph LR
    A[画布预处理] --> B[连接验证] --> C[循环检测] --> D[嵌套验证] --> E[变量检查] --> F[全局变量] --> G[终止策略]
</pre>

<h4 id="212完整验证流程">2.1.2 完整验证流程<a hidden class="anchor" aria-hidden="true" href="#212完整验证流程">#</a></h4>
<pre class="mermaid">%% 点击 “绘图” 按钮即可预览
graph LR
    A["1. 画布预处理<br/>• JSON反序列化<br/>• 清理孤立节点<br/>• 创建验证器实例"] --> H["2. 连接关系验证<br/>ValidateConnections"]
    H --> H1["• 检查节点连接完整性<br/>• 验证端口连接正确性<br/>• 检查分支节点完整性"]
    H1 --> I{发现问题?}
    I -->|是| Z["返回验证错误"]
    I -->|否| J["3. 循环依赖检测<br/>DetectCycles"]
    
    J --> J1["• 构建依赖关系图<br/>• DFS算法检测环<br/>• 标识循环路径"]
    J1 --> K{发现循环?}
    K -->|是| Z
    K -->|否| L["4. 嵌套流程验证<br/>ValidateNestedFlows"]
    
    L --> L1["• 检查批处理节点嵌套<br/>• 验证循环节点嵌套<br/>• 防止过深嵌套"]
    L1 --> M{嵌套违规?}
    M -->|是| Z
    M -->|否| N["5. 引用变量检查<br/>CheckRefVariable"]
    
    N --> N1["• 验证变量可达性<br/>• 检查参数名规范<br/>• 验证作用域正确性"]
    N1 --> O{变量引用错误?}
    O -->|是| Z
    O -->|否| P["6. 全局变量验证<br/>CheckGlobalVariables"]
    
    P --> P1["• 验证变量类型匹配<br/>• 检查数组元素类型<br/>• 验证变量声明"]
    P1 --> Q{全局变量错误?}
    Q -->|是| Z
    Q -->|否| R["7. 子工作流终止策略<br/>CheckSubWorkFlowTerminatePlanType"]
    
    R --> R1["• 验证终止计划配置<br/>• 检查版本一致性<br/>• 验证子工作流存在性"]
    R1 --> S{终止策略错误?}
    S -->|是| Z
    S -->|否| T["主工作流验证完成"]
    
    T --> U["子工作流递归验证"]
    U --> U1["• 解析画布获取子工作流<br/>• 筛选项目级工作流<br/>• 批量获取工作流信息"]
    U1 --> U2["对每个子工作流<br/>重复验证流程"]
    U2 --> V["汇总所有验证结果"]
    
    V --> W["错误信息转换<br/>• Issue -> ValidateErrorData<br/>• 节点错误/路径错误分类"]
    W --> X["返回验证结果<br/>ValidateTreeResponse"]
    
    style A fill:#e1f5fe
    style H fill:#e8f5e8
    style J fill:#e8f5e8
    style L fill:#e8f5e8
    style N fill:#e8f5e8
    style P fill:#e8f5e8
    style R fill:#e8f5e8
    style U fill:#fff8e1
    style Z fill:#ffebee
</pre>

<h4 id="213工作流验证流程技术实现总结">2.1.3 工作流验证流程技术实现总结<a hidden class="anchor" aria-hidden="true" href="#213工作流验证流程技术实现总结">#</a></h4>
<p>Coze Studio 的工作流验证采用<strong>分层递进式验证架构</strong>，从 API 层的 <code>ValidateTree</code> 接口开始，经过应用服务层的参数预处理，最终调用领域服务层的核心验证引擎 <code>validateWorkflowTree</code>。验证流程包含七个关键步骤：</p>
<p><strong>1. 画布预处理阶段</strong> - 首先将 JSON 格式的画布结构反序列化为内存对象，然后调用 <code>adaptor.PruneIsolatedNodes</code> 清理没有连接关系的孤立节点，最后创建配置完整的 <code>CanvasValidator</code> 验证器实例并执行可达性分析，构建节点间的连通关系图。</p>
<p><strong>2. 连接关系验证</strong> - <code>ValidateConnections</code> 方法通过遍历所有节点和边，构建出度映射表和端口映射表来实现。对于每个节点，检查其输出端口是否正确连接，特别是分支节点（如条件判断、错误处理）必须确保所有期望的端口都有连接。算法会递归验证嵌套节点的连接关系，确保数据流的完整性。</p>
<p><strong>3. 循环依赖检测</strong> - <code>DetectCycles</code> 使用深度优先搜索（DFS）算法实现。首先构建反向依赖关系图（<code>controlSuccessors</code>），然后对每个未访问的节点启动 DFS 遍历。在遍历过程中维护当前路径栈，当发现路径中已存在的节点时，即检测到循环依赖，算法会提取并返回完整的循环路径。</p>
<p><strong>4. 嵌套流程验证</strong> - <code>ValidateNestedFlows</code> 通过检查可达性分析结果中的 <code>nestedReachability</code> 结构实现。如果一个节点既有嵌套结构，又在其嵌套结构中还有更深层的嵌套（即 <code>len(nestedReachableNodes.nestedReachability) &gt; 0</code>），则判定为违反嵌套规则，防止批处理和循环节点的过度嵌套导致执行异常。</p>
<p><strong>5. 引用变量检查</strong> - <code>CheckRefVariable</code> 采用递归作用域分析算法。定义内部函数 <code>inputBlockVerify</code> 解析每个输入参数的引用信息，检查引用的节点是否在当前或父级作用域的可达范围内。通过 <code>combinedReachable</code> 映射表合并当前层级和父级可达节点，实现作用域继承机制。同时验证参数名称的规范性（必须以字母开头，只能包含字母数字下划线）。</p>
<p><strong>6. 全局变量验证</strong> - <code>CheckGlobalVariables</code> 首先收集所有变量分配节点（<code>NodeTypeVariableAssigner</code>）的变量定义，然后通过 <code>VariablesMetaGetter</code> 获取应用或智能体的变量元数据进行对比。验证包括基础类型匹配和数组元素类型的深度检查，确保工作流中使用的全局变量与系统定义一致。</p>
<p><strong>7. 子工作流终止策略验证</strong> - <code>CheckSubWorkFlowTerminatePlanType</code> 通过递归收集所有子工作流节点，分别获取草稿版本和已发布版本的画布信息。对每个子工作流，查找其结束节点的终止计划配置，与当前节点的终止类型进行匹配验证，确保子工作流的输出处理策略与调用方期望一致。</p>
<p>整个验证过程采用<strong>快速失败策略</strong>，任何步骤发现问题立即返回错误信息，同时支持<strong>递归子工作流验证</strong>，通过 <code>getAllSubWorkflowIdentities</code> 提取所有子工作流标识，对每个子工作流重复执行完整的验证流程，最终汇总所有验证结果，确保整个工作流树的结构完整性、逻辑正确性和执行安全性。</p>


  </div>



  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://swimmingliu.cn/tags/java/">Java</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://swimmingliu.cn/posts/job/leetcode-hot100-notes/">
    <span class="title">Next »</span>
    <br>
    <span>Leetcode Hot100 刷题笔记</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2023-2025 <a href="https://swimmingliu.cn/">SwimmingLiu&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
    <span>
        <a href="https://beian.miit.gov.cn/">浙ICP备2024056260号</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>


  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script>

