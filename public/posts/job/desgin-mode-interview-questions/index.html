<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>设计模式面试题笔记 | SwimmingLiu&#39;s Blog</title>
<meta name="keywords" content="Java, Design Mode">
<meta name="description" content="1. 单例模式有哪几种实现？如何保证线程安全？
首先，单例模式和工厂模式都是一种设计模式。单例模式当中，一个类只允许创建一个对象(或者说实例)， 那这个类就是单例类。单例类是不可以被继承的，也没有了多态的特性。
【单例类的实现方式】
常规单例模式有五种写法，但是编写代码的过程当中，要注意以下几点：

构造器需要私有化
暴露一个公共获取单例对象的接口 （obj.getInstance()）
是否支持懒加载 延迟加载
是否线程安全

五种写法为：


饿汉式： 类加载的时候，就一起把 instance 静态实例创建好了，所以创建的过程市线程安全的。
饿汉式的单例模式虽然不支持懒加载，有点浪费资源。但其实不会占用太多资源，并且如果一个实例初始化的过程比较复杂，就应该放在启动的时候来处理，避免运行时卡顿或发生问题， 满足fail-fast 失败快速解决的设计原则
public class EagerSingleton {  
    private static Singleton instance = new Singleton();  
    private Singleton (){}  
    public static Singleton getInstance() {  
    	return instance;  
    }  
}


懒汉式：相较于饿汉式的方式，修改成延迟加载的模式。注意getInstance()方法没有上锁的话，在大量线程并发请求的时候，可能创建多个实例。
public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  
    public synchronized static Singleton getInstance() {  
        if (instance == null) {  
            instance = new Singleton();  
        }  
        return instance;  
    }  
}


双重检查锁：饿汉式锁不支持延迟加载，然后懒汉式锁的粒度比较大，不支持高并发。双重检查锁可以实现既延迟加载，又支持高并发。其实就是在判断了没有实例之后，再进行上锁，创建实例。 但是实例必须用volatile 修饰，不然new 操作创建对象时，容易出现重排序的问题。">
<meta name="author" content="SwimmingLiu">
<link rel="canonical" href="https://swimmingliu.cn/posts/job/desgin-mode-interview-questions/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.6ecbb0040febd20e47edd88a662c19f1ea945bf7427774b86594271d18f88faf.css" integrity="sha256-bsuwBA/r0g5H7diKZiwZ8eqUW/dCd3S4ZZQnHRj4j68=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<link rel="apple-touch-icon" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<link rel="mask-icon" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://swimmingliu.cn/posts/job/desgin-mode-interview-questions/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ],
            
            throwOnError: false
        });
    });
</script>

<meta property="og:url" content="https://swimmingliu.cn/posts/job/desgin-mode-interview-questions/">
  <meta property="og:site_name" content="SwimmingLiu&#39;s Blog">
  <meta property="og:title" content="设计模式面试题笔记">
  <meta property="og:description" content="1. 单例模式有哪几种实现？如何保证线程安全？ 首先，单例模式和工厂模式都是一种设计模式。单例模式当中，一个类只允许创建一个对象(或者说实例)， 那这个类就是单例类。单例类是不可以被继承的，也没有了多态的特性。
【单例类的实现方式】
常规单例模式有五种写法，但是编写代码的过程当中，要注意以下几点：
构造器需要私有化 暴露一个公共获取单例对象的接口 （obj.getInstance()） 是否支持懒加载 延迟加载 是否线程安全 五种写法为：
饿汉式： 类加载的时候，就一起把 instance 静态实例创建好了，所以创建的过程市线程安全的。
饿汉式的单例模式虽然不支持懒加载，有点浪费资源。但其实不会占用太多资源，并且如果一个实例初始化的过程比较复杂，就应该放在启动的时候来处理，避免运行时卡顿或发生问题， 满足fail-fast 失败快速解决的设计原则
public class EagerSingleton { private static Singleton instance = new Singleton(); private Singleton (){} public static Singleton getInstance() { return instance; } } 懒汉式：相较于饿汉式的方式，修改成延迟加载的模式。注意getInstance()方法没有上锁的话，在大量线程并发请求的时候，可能创建多个实例。
public class Singleton { private static Singleton instance; private Singleton (){} public synchronized static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 双重检查锁：饿汉式锁不支持延迟加载，然后懒汉式锁的粒度比较大，不支持高并发。双重检查锁可以实现既延迟加载，又支持高并发。其实就是在判断了没有实例之后，再进行上锁，创建实例。 但是实例必须用volatile 修饰，不然new 操作创建对象时，容易出现重排序的问题。">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-03-07T21:44:36+08:00">
    <meta property="article:modified_time" content="2025-03-07T21:44:36+08:00">
    <meta property="article:tag" content="Java">
    <meta property="article:tag" content="Design Mode">
      <meta property="og:image" content="https://swimmingliu.cn/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://swimmingliu.cn/papermod-cover.png">
<meta name="twitter:title" content="设计模式面试题笔记">
<meta name="twitter:description" content="1. 单例模式有哪几种实现？如何保证线程安全？
首先，单例模式和工厂模式都是一种设计模式。单例模式当中，一个类只允许创建一个对象(或者说实例)， 那这个类就是单例类。单例类是不可以被继承的，也没有了多态的特性。
【单例类的实现方式】
常规单例模式有五种写法，但是编写代码的过程当中，要注意以下几点：

构造器需要私有化
暴露一个公共获取单例对象的接口 （obj.getInstance()）
是否支持懒加载 延迟加载
是否线程安全

五种写法为：


饿汉式： 类加载的时候，就一起把 instance 静态实例创建好了，所以创建的过程市线程安全的。
饿汉式的单例模式虽然不支持懒加载，有点浪费资源。但其实不会占用太多资源，并且如果一个实例初始化的过程比较复杂，就应该放在启动的时候来处理，避免运行时卡顿或发生问题， 满足fail-fast 失败快速解决的设计原则
public class EagerSingleton {  
    private static Singleton instance = new Singleton();  
    private Singleton (){}  
    public static Singleton getInstance() {  
    	return instance;  
    }  
}


懒汉式：相较于饿汉式的方式，修改成延迟加载的模式。注意getInstance()方法没有上锁的话，在大量线程并发请求的时候，可能创建多个实例。
public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  
    public synchronized static Singleton getInstance() {  
        if (instance == null) {  
            instance = new Singleton();  
        }  
        return instance;  
    }  
}


双重检查锁：饿汉式锁不支持延迟加载，然后懒汉式锁的粒度比较大，不支持高并发。双重检查锁可以实现既延迟加载，又支持高并发。其实就是在判断了没有实例之后，再进行上锁，创建实例。 但是实例必须用volatile 修饰，不然new 操作创建对象时，容易出现重排序的问题。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚 Posts",
      "item": "https://swimmingliu.cn/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "💻 Job",
      "item": "https://swimmingliu.cn/posts/job/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "设计模式面试题笔记",
      "item": "https://swimmingliu.cn/posts/job/desgin-mode-interview-questions/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "设计模式面试题笔记",
  "name": "设计模式面试题笔记",
  "description": "1. 单例模式有哪几种实现？如何保证线程安全？ 首先，单例模式和工厂模式都是一种设计模式。单例模式当中，一个类只允许创建一个对象(或者说实例)， 那这个类就是单例类。单例类是不可以被继承的，也没有了多态的特性。\n【单例类的实现方式】\n常规单例模式有五种写法，但是编写代码的过程当中，要注意以下几点：\n构造器需要私有化 暴露一个公共获取单例对象的接口 （obj.getInstance()） 是否支持懒加载 延迟加载 是否线程安全 五种写法为：\n饿汉式： 类加载的时候，就一起把 instance 静态实例创建好了，所以创建的过程市线程安全的。\n饿汉式的单例模式虽然不支持懒加载，有点浪费资源。但其实不会占用太多资源，并且如果一个实例初始化的过程比较复杂，就应该放在启动的时候来处理，避免运行时卡顿或发生问题， 满足fail-fast 失败快速解决的设计原则\npublic class EagerSingleton { private static Singleton instance = new Singleton(); private Singleton (){} public static Singleton getInstance() { return instance; } } 懒汉式：相较于饿汉式的方式，修改成延迟加载的模式。注意getInstance()方法没有上锁的话，在大量线程并发请求的时候，可能创建多个实例。\npublic class Singleton { private static Singleton instance; private Singleton (){} public synchronized static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 双重检查锁：饿汉式锁不支持延迟加载，然后懒汉式锁的粒度比较大，不支持高并发。双重检查锁可以实现既延迟加载，又支持高并发。其实就是在判断了没有实例之后，再进行上锁，创建实例。 但是实例必须用volatile 修饰，不然new 操作创建对象时，容易出现重排序的问题。\n",
  "keywords": [
    "Java", "Design Mode"
  ],
  "articleBody": "1. 单例模式有哪几种实现？如何保证线程安全？ 首先，单例模式和工厂模式都是一种设计模式。单例模式当中，一个类只允许创建一个对象(或者说实例)， 那这个类就是单例类。单例类是不可以被继承的，也没有了多态的特性。\n【单例类的实现方式】\n常规单例模式有五种写法，但是编写代码的过程当中，要注意以下几点：\n构造器需要私有化 暴露一个公共获取单例对象的接口 （obj.getInstance()） 是否支持懒加载 延迟加载 是否线程安全 五种写法为：\n饿汉式： 类加载的时候，就一起把 instance 静态实例创建好了，所以创建的过程市线程安全的。\n饿汉式的单例模式虽然不支持懒加载，有点浪费资源。但其实不会占用太多资源，并且如果一个实例初始化的过程比较复杂，就应该放在启动的时候来处理，避免运行时卡顿或发生问题， 满足fail-fast 失败快速解决的设计原则\npublic class EagerSingleton { private static Singleton instance = new Singleton(); private Singleton (){} public static Singleton getInstance() { return instance; } } 懒汉式：相较于饿汉式的方式，修改成延迟加载的模式。注意getInstance()方法没有上锁的话，在大量线程并发请求的时候，可能创建多个实例。\npublic class Singleton { private static Singleton instance; private Singleton (){} public synchronized static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 双重检查锁：饿汉式锁不支持延迟加载，然后懒汉式锁的粒度比较大，不支持高并发。双重检查锁可以实现既延迟加载，又支持高并发。其实就是在判断了没有实例之后，再进行上锁，创建实例。 但是实例必须用volatile 修饰，不然new 操作创建对象时，容易出现重排序的问题。\npublic class DclSingleton { // volatile如果不加可能会出现半初始化的对象 // 现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）,为了兼容性我们加上 private volatile static Singleton singleton; private Singleton (){} public static Singleton getInstance() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } 静态内部类：利用Java的内部类，再调用getInstance()方法的时候，直接返回内部类的实例。他会再调用方法之后，创建内部类的实例对象。实例的唯一性和创建过程的线程安全性，都有JVM来保证。这种方法既是线程安全的，又能够做延迟加载。\npublic class InnerSingleton { /** 私有化构造器 */ private Singleton() { } /** 对外提供公共的访问方法 */ public static Singleton getInstance() { return SingletonHolder.INSTANCE; } /** 写一个静态内部类，里面实例化外部类 */ private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } } 枚举：通过Java枚举类型本身的特性，保证实例创建线程的安全性和实例的唯一性。\n// 使用枚举实现单例模式 public enum Singleton { INSTANCE; // 单例中的方法示例 public void doSomething() { System.out.println(\"单例方法执行\"); } } // 使用方法： Singleton.INSTANCE.doSomething(); 也可以用单例项作为枚举的成员变量，累加器可以像下面这样编写：\npublic enum GlobalCounter { INSTANCE; private AtomicLong atomicLong = new AtomicLong(0); public long getNumber() { return atomicLong.incrementAndGet(); } } 【单例模式的安全问题】\n反射入侵：如果想要阻止其他人构造实例，仅仅私有化构造器还是不够的，因为我们可以利用反射机制来获取私有构造器进行构造。如果要避免这种情况发生，可以再构造器当中进行判断实例是否已存在，避免多次利用构造器构造实例\npublic class Singleton { private volatile static Singleton singleton; private Singleton (){ if(singleton != null) throw new RuntimeException(\"实例：【\" + this.getClass().getName() + \"】已经存在，该实例只允许实例化一次\"); } public static Singleton getInstance() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } // 利用反射机制来入侵构造实例 @Test public void testReflect() throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException { Class\u003cDclSingleton\u003e clazz = DclSingleton.class; Constructor\u003cDclSingleton\u003e constructor = clazz.getDeclaredConstructor(); constructor.setAccessible(true); boolean flag = DclSingleton.getInstance() == constructor.newInstance(); log.info(\"flag -\u003e {}\",flag); } 序列化与反序列化：如果单例存到文件流当中，再进行反序列话，也不是同一个实例。但是可以用readResolve()的方法，将返回值作为反序列化的结果，而不会克隆一个新的实例，保证jvm当中只有一个实例存在。\n@Test public void testSerialize() throws IllegalAccessException, NoSuchMethodException, IOException, ClassNotFoundException { // 获取单例并序列化 Singleton singleton = Singleton.getInstance(); FileOutputStream fout = new FileOutputStream(\"D://singleton.txt\"); ObjectOutputStream out = new ObjectOutputStream(fout); out.writeObject(singleton); // 将实例反序列化出来 FileInputStream fin = new FileInputStream(\"D://singleton.txt\"); ObjectInputStream in = new ObjectInputStream(fin); Object o = in.readObject(); log.info(\"他们是同一个实例吗？{}\",o == singleton); // 如果直接获取，反序列化后的不是同一个实例 } // 添加readResolve()来解决序列化和反序列化问题 public class Singleton implements Serializable { // 省略其他的内容 public static Singleton getInstance() { } // 需要加这么一个方法 public Object readResolve(){ return singleton; } } 【为什么要用单例模式】\n为了全局唯一：系统中如配置类、全局计数器等类型，应该都都只能保存一份数据，不应该有多份数据。\n配置类：系统仅有一个配置文件，加载到内存后映射成唯一的配置实例 全局计数器：用于数据统计、生成全局递增id 等功能，必须要是唯一的，否则可能导致统计无效、ID 重复等问题。 // 全局id生成器 public class GlobalCounter { private AtomicLong atomicLong = new AtomicLong(0); private static final GlobalCounter instance = new GlobalCounter(); // 私有化无参构造器 private GlobalCounter() {} public static GlobalCounter getInstance() { return instance; } public long getId() { return atomicLong.incrementAndGet(); } } // 查看当前的统计数量 long courrentNumber = GlobalCounter.getInstance().getId(); 处理资源访问冲突：假如需要日志输出的功能，可以使用单例i面资源访问冲突\npublic class Logger { private String basePath = \"D://log/\"; private static Logger instance = new Logger(); private FileWriter writer; private Logger() { File file = new File(basePath); try { writer = new FileWriter(file, true); //true表示追加写入 } catch (IOException e) { throw new RuntimeException(e); } } public static Logger getInstance(){ //确保全局只有一个logger实例对象 return instance; } public void log(String message) { try { writer.write(message); } catch (IOException e) { throw new RuntimeException(e); } } public void setBasePath(String basePath) { this.basePath = basePath; } } 【单例模式存在的问题】\n无法支持面向对象编程OOP： OOP 的三大特性是封装、继承、多态。单例把构造函数私有化了，不支持继承和多态。所以无法对它进行拓展。 很难横向拓展：单例类只能有一个对象实例，如果后面需要进行拓展，创建多个实例。必须修改源码，无法友好拓展。 【不同作用范围的单例模式】\n线程级别单例：单例类对象是进程唯一的，如果想要线程唯一。在不使用ThreadLocal的时候，可以采用ConCurrentHashMap 的方式，用线程id为key， 实例为value。每个线程的存取都从共享的 map 当中进行操作。\npublic class Connection { private static final ConcurrentHashMap\u003cLong, Connection\u003e instances = new ConcurrentHashMap\u003c\u003e(); private Connection() {} public static Connection getInstance() { Long currentThreadId = Thread.currentThread().getId(); instances.putIfAbsent(currentThreadId, new Connection()); return instances.get(currentThreadId); } } 容器级别的单例：将单例的作用范围由进程切换到一个容器，可能会更加方便我们进行单例对象的管理。这也是Spring 的核心思想。Spring 提供一个单例容器，确保一个实例是容器级别的单例，并且在容器启动时完成初始化。具体优势如下：\n所有的bean 都以单例的形式存放在容器中，避免大量的对象被创建，造成JVM 内存抖动严重，频繁GC。 程序启动时，初始化单例bean， 满足fast-fail，将所有构建过程的异常暴露在启动时，而非运行时。 缓存了所有单例bean，启动的过程相当于预热的过程，运行时不必进行对象创建，效率更高。 容器管理bean的生命周期，结合依赖注入使得解耦更加彻底、扩展性更好。 2. 什么是策略模式？一般用在什么场景？ 策略模式是行为设计模式的一种，通过定义一系列的算法类。允许在运行时动态选择算法，从而实现更加灵活的代码结构。该模式用于组织和调用这些算法，让程序结构变得更加灵活，具有更好的维护性和扩展性。\n策略模式一般用于当一个功能存在多种算法的时候，需要根据不同的情况使用不同的计算算法(都封装成类的)。这样就可以避免利用大量的if-else 或者 switch-else\n【为什么要用策略模式】\n避免程序存在判断或选择分支语句：当程序存在大量的 if-else 或者 switch-else 判断语句，代码可能变得难以维护 避免破坏现有功能：当算法的实现经常变更或需要拓展的时候，直接修改代码可能会破坏现有功能。 【策略模式的场景】\n多种算法可互换：需要动态选择算法，例如排序算法的选择。有很多种排序算法，可以把不同的排序方式封装成一个独立的算法类 (快速排序、归并排序、直接插入排序等) 避免条件语句：采用策略模式替换掉代码当中的大量if-else 或 switch 语句 与上下文独立：客户端不需要知道具体的实现细节，只需以来抽象策略。 【策略模式典型应用场景】\n支付系统：支持多种支付方式，比如微信、支付宝、信用卡 数据压缩：提供不同的压缩算法 日志策略：根据日志级别动态选择记录策略 【策略模式的组成】\nStrategy 策略：用来约束一系列具体的策略算法。Context 上下文使用这个接口来调用具体的策略实现定义的算法。如果多个算法具有公共功能的化，把Strategy 实现为抽象类，然后把多个算法的功能实现到Stragy 里面。 (比如多种排序算法，都放在 Strategy 抽象类里面) ConcreteStrategy 具体策略： 具体的策略实现，负责实现Strategy 策略的接口 (多种排序算法的具体实现) Context 上下文：上下文是负责和具体的策略类交互，通常上下文会吃有一个真正的策略实现 (就是调用哪个排序方法，比如说 main 函数) 3. 什么是模板方法模式？一般用在什么场景？ 模板方法就是在抽象类里面定义好算法的骨架，具体步骤在子类实现。\n【模板方法特点】\n算法骨架：在基类中定义一个算法的固定执行步骤，具体实现步骤交给子类实现 复用代码：子类复用基类中定义的公共逻辑，只需要实现特定的逻辑 遵循开闭规则：模板方法是扩展开放，修改闭合的 【典型使用场景】\n数据请求处理: 读取数据、处理数据、输出结果 Web请求处理：解析请求、处理逻辑、返回响应 String Template 字符串模板 String name = \"World\"; String greeting = STR.\"Hello, \\{name}!\"; System.out.println(greeting); // 输出: Hello, World! 4. 谈谈你了解的最常见的几种设计模式，说说他们的应用场景 【常见的设计模式】\n单例模式：保证系统中一个类只有一个实例对象，比如全局配置、全局计数器、数据库连接池 策略模式：封装一组算法让他们之间能够相互替代，避免大量的if-else 和 switch-case 语句，比如用户选择不同的支付策略，或者调用不同的排序算法。 模板模式：提炼核心流程封装成一个方法，比如像支付逻辑(参数校验、调起支付接口、修改支付状态)，除了调起支付接口以外，其他的流程基本一致。所以可以封装成模板方法，然后把调起支付接口的操作，在具体实现方法当中重写该方法。 简单工厂模式：获取不同的对象时可以使用，将对象的创建逻辑抽离复用。 外观模式：为子系统提供一组统一接口，隐藏内部实现细节，方便子系统直接调用，而无需关注实现细节(比如高德和百度的 SDK) 代理模式：通过创建代理对象来控制哦对实际对象的访问，例如Sping AOP切面编程采用代理模式来动态生成增强目标对象的代理 (通过 JDK 动态代理或者CGLIB代理) 。Sping AOP 默认优先使用 JDK 动态代理。当目标类未实现接口时，才会切换为 CGLIB 动态代理。 【Spring中的设计模式】\n5. 你认为好的代码应该是什么样的？ 【通俗易懂的讲】\n清晰易懂，保持简洁和易读性：代码简洁、直观，函数和变量命名都有意义，可读性非常强，有合理的注释。 高内聚低耦合：高内聚是指代码模块内部功能集中，每个模块都有单一职责。低耦合指的是不同模块之间的依赖关系尽量松散，修改一个模块的时候，其他模块受到的影响比较小。 可测试：每个模块都设计为独立的、可验证的单元，编写单元测试用例的时候，能够确保代码的正确性并且发现潜在问题。 易于扩展，遵循开闭原则：代码具有一定灵活性，能在不破坏现有功能的情况下，方便进行扩展和修改。 符合团队规范：代码风格和团队整体代码规范统一，有助于协助团队协作和代码审查。 减少硬编码、魔法值：尽量避免硬编码和魔法值的现象，方便后续进行修改。 【好代码具备以下特性】\n设计原则 代码特性 结果 单一职责 类或模块职责单一 降低类的复杂度，增强可读性和维护性 开闭原则 对扩展开放，对修改关闭 提高扩展性，减少对已有代码的修改 高内聚低耦合 模块职责明确，依赖关系松散 增强代码的可维护性和扩展性 接口隔离原则 接口小且专用 减少无关实现代码，增强接口的灵活性 依赖倒置 依赖于抽象而非具体实现 降低模块间的耦合度，提高代码灵活性 合成复用原则 优先使用组合而非继承 提高灵活性，避免继承导致的高聚合 里氏替换原则 子类可以无缝替换父类 确保继承体系的正确性，增强代码的稳定性 迪米特法则 减少类之间的依赖 降低耦合度，增强模块独立性 6. 工厂模式和抽象工厂模式有什么区别？ 【工厂模式】\n对象：创建一种类型的产品对象，比如让google创建安卓系统， 不同品牌的手机厂商(工厂子类)就可以根据安卓系统当中的功能，重写出其他的os 系统，比如鸿蒙系统、澎湃系统等等 工厂结构：有且只有一个抽象的工厂类，定义创建产品的抽象方法，然后具体的工厂子类去实现这个方法来实际创建具体的产品。比如 android 系统的源码是大家都可以看到的，其他厂商也可以根据android 系统的设计，重新实现部分函数，修改成其他的功能。 使用场景：当创建过程比较复杂，想把对象创建和使用分离时常用，比如创建数据库连接对象等简单的单一产品创建创建适用。 【抽象工厂模式】\n对象：用于创建一系列相关的产品对象，比如创建手机的时候，需要连带创建配套的充电器、耳机等配套产品 工厂结构：抽象工厂类定义了多个抽象创建方法，分别用于创建一系列相关的产品。更具体的工厂子类要实现这些抽象方法，提供一整套的具体产品的创建。 使用场景：当系统要创建多个相互依赖或者关联的对象的时候，确保这些对象搭配合理。比如游戏开发中创建不同风格(比如科技风格、古风)的角色、武器、场景等一整套相关的元素时，就适合用抽象工厂模式。 // 抽象产品A public interface ProductA { void use(); } // 具体产品A1 -\u003e 手机 public class ConcreteProductA1 implements ProductA { @Override public void use() { System.out.println(\"Using ConcreteProductA1\"); } } // 具体产品A2 -\u003e 电脑 public class ConcreteProductA2 implements ProductA { @Override public void use() { System.out.println(\"Using ConcreteProductA2\"); } } // 抽象产品B public interface ProductB { void eat(); } // 具体产品B1 -\u003e 手机充电线 public class ConcreteProductB1 implements ProductB { @Override public void eat() { System.out.println(\"Eating ConcreteProductB1\"); } } // 具体产品B2 -\u003e 电脑充电线 public class ConcreteProductB2 implements ProductB { @Override public void eat() { System.out.println(\"Eating ConcreteProductB2\"); } } // 抽象工厂 -\u003e 把两个相互关联的抽象产品一起创建 public interface AbstractFactory { ProductA createProductA(); ProductB createProductB(); } // 具体工厂1 public class ConcreteFactory1 implements AbstractFactory { @Override public ProductA createProductA() { return new ConcreteProductA1(); } @Override public ProductB createProductB() { return new ConcreteProductB1(); } } // 具体工厂2 public class ConcreteFactory2 implements AbstractFactory { @Override public ProductA createProductA() { return new ConcreteProductA2(); } @Override public ProductB createProductB() { return new ConcreteProductB2(); } } // 使用抽象工厂创建产品 public class Client { public static void main(String[] args) { AbstractFactory factory1 = new ConcreteFactory1(); ProductA productA1 = factory1.createProductA(); ProductB productB1 = factory1.createProductB(); productA1.use(); productB1.eat(); AbstractFactory factory2 = new ConcreteFactory2(); ProductA productA2 = factory2.createProductA(); ProductB productB2 = factory2.createProductB(); productA2.use(); productB2.eat(); } } ",
  "wordCount" : "913",
  "inLanguage": "en",
  "image": "https://swimmingliu.cn/papermod-cover.png","datePublished": "2025-03-07T21:44:36+08:00",
  "dateModified": "2025-03-07T21:44:36+08:00",
  "author":[{
    "@type": "Person",
    "name": "SwimmingLiu"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://swimmingliu.cn/posts/job/desgin-mode-interview-questions/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "SwimmingLiu's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://swimmingliu.cn/images/swimmingliu_icon.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://swimmingliu.cn/" accesskey="h" title="𝓢𝔀𝓲𝓶𝓶𝓲𝓷𝓰𝓛𝓲𝓾&#39;𝓼 𝓑𝓵𝓸𝓰 (Alt + H)">
                <img src="https://swimmingliu.cn/images/swimmingliu_icon.png" alt="" aria-label="logo"
                    height="30">𝓢𝔀𝓲𝓶𝓶𝓲𝓷𝓰𝓛𝓲𝓾&#39;𝓼 𝓑𝓵𝓸𝓰</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://swimmingliu.cn/index.html" title="🏡 Home">
                    <span>🏡 Home</span>
                </a>
            </li>
            <li>
                <a href="https://swimmingliu.cn/search/" title="🔍 Search">
                    <span>🔍 Search</span>
                </a>
            </li>
            <li>
                <a href="https://swimmingliu.cn/posts/" title="🗒️ Posts">
                    <span>🗒️ Posts</span>
                </a>
            </li>
            <li>
                <a href="https://swimmingliu.cn/archives/" title="📃 Archive">
                    <span>📃 Archive</span>
                </a>
            </li>
            <li>
                <a href="https://swimmingliu.cn/tags/" title="📑 Tags">
                    <span>📑 Tags</span>
                </a>
            </li>
            <li>
                <a href="https://bento.me/swimmingliu" title="👨🏻‍🎓 About Me">
                    <span>👨🏻‍🎓 About Me</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
            <li>
                <a href="https://www.emojisearch.app/" title="Emoji">
                    <span>Emoji</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://swimmingliu.cn/">Home</a>&nbsp;»&nbsp;<a href="https://swimmingliu.cn/posts/">📚 Posts</a>&nbsp;»&nbsp;<a href="https://swimmingliu.cn/posts/job/">💻 Job</a></div>
    <h1 class="post-title entry-hint-parent">
      设计模式面试题笔记
    </h1>
    <div class="post-meta"><span title='2025-03-07 21:44:36 +0800 CST'>March 7, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;SwimmingLiu

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#1-%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8f%e6%9c%89%e5%93%aa%e5%87%a0%e7%a7%8d%e5%ae%9e%e7%8e%b0%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8" aria-label="1. 单例模式有哪几种实现？如何保证线程安全？">1. 单例模式有哪几种实现？如何保证线程安全？</a></li>
                <li>
                    <a href="#2-%e4%bb%80%e4%b9%88%e6%98%af%e7%ad%96%e7%95%a5%e6%a8%a1%e5%bc%8f%e4%b8%80%e8%88%ac%e7%94%a8%e5%9c%a8%e4%bb%80%e4%b9%88%e5%9c%ba%e6%99%af" aria-label="2. 什么是策略模式？一般用在什么场景？">2. 什么是策略模式？一般用在什么场景？</a></li>
                <li>
                    <a href="#3-%e4%bb%80%e4%b9%88%e6%98%af%e6%a8%a1%e6%9d%bf%e6%96%b9%e6%b3%95%e6%a8%a1%e5%bc%8f%e4%b8%80%e8%88%ac%e7%94%a8%e5%9c%a8%e4%bb%80%e4%b9%88%e5%9c%ba%e6%99%af" aria-label="3. 什么是模板方法模式？一般用在什么场景？">3. 什么是模板方法模式？一般用在什么场景？</a></li>
                <li>
                    <a href="#4-%e8%b0%88%e8%b0%88%e4%bd%a0%e4%ba%86%e8%a7%a3%e7%9a%84%e6%9c%80%e5%b8%b8%e8%a7%81%e7%9a%84%e5%87%a0%e7%a7%8d%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f%e8%af%b4%e8%af%b4%e4%bb%96%e4%bb%ac%e7%9a%84%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" aria-label="4. 谈谈你了解的最常见的几种设计模式，说说他们的应用场景">4. 谈谈你了解的最常见的几种设计模式，说说他们的应用场景</a></li>
                <li>
                    <a href="#5-%e4%bd%a0%e8%ae%a4%e4%b8%ba%e5%a5%bd%e7%9a%84%e4%bb%a3%e7%a0%81%e5%ba%94%e8%af%a5%e6%98%af%e4%bb%80%e4%b9%88%e6%a0%b7%e7%9a%84" aria-label="5. 你认为好的代码应该是什么样的？">5. 你认为好的代码应该是什么样的？</a></li>
                <li>
                    <a href="#6-%e5%b7%a5%e5%8e%82%e6%a8%a1%e5%bc%8f%e5%92%8c%e6%8a%bd%e8%b1%a1%e5%b7%a5%e5%8e%82%e6%a8%a1%e5%bc%8f%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="6. 工厂模式和抽象工厂模式有什么区别？">6. 工厂模式和抽象工厂模式有什么区别？</a>
                </li>
            </ul>
        </div>
    </details>
</div>
  <div class="post-content"><h2 id="1-单例模式有哪几种实现如何保证线程安全">1. 单例模式有哪几种实现？如何保证线程安全？<a hidden class="anchor" aria-hidden="true" href="#1-单例模式有哪几种实现如何保证线程安全">#</a></h2>
<p>首先，单例模式和工厂模式都是一种设计模式。单例模式当中，一个类只允许创建一个对象(或者说实例)， 那这个类就是单例类。单例类是不可以被继承的，也没有了多态的特性。</p>
<p><strong>【单例类的实现方式】</strong></p>
<p>常规单例模式有五种写法，但是编写代码的过程当中，要注意以下几点：</p>
<ol>
<li>构造器需要私有化</li>
<li>暴露一个公共获取单例对象的接口 （<code>obj.getInstance()</code>）</li>
<li>是否支持懒加载 <code>延迟加载</code></li>
<li>是否线程安全</li>
</ol>
<p>五种写法为：</p>
<ol>
<li>
<p><strong>饿汉式</strong>： 类加载的时候，就一起把 <code>instance</code> 静态实例创建好了，所以创建的过程市线程安全的。</p>
<p>饿汉式的单例模式虽然不支持懒加载，有点浪费资源。但其实不会占用太多资源，并且如果一个实例初始化的过程比较复杂，就应该放在启动的时候来处理，避免运行时卡顿或发生问题， 满足<code>fail-fast</code> 失败快速解决的设计原则</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">EagerSingleton</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">Singleton</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Singleton</span><span class="p">();</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="nf">Singleton</span><span class="w"> </span><span class="p">(){}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">Singleton</span><span class="w"> </span><span class="nf">getInstance</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    	</span><span class="k">return</span><span class="w"> </span><span class="n">instance</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p><strong>懒汉式</strong>：相较于饿汉式的方式，修改成延迟加载的模式。注意<code>getInstance()</code>方法没有上锁的话，在大量线程并发请求的时候，可能创建多个实例。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Singleton</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">Singleton</span><span class="w"> </span><span class="n">instance</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="nf">Singleton</span><span class="w"> </span><span class="p">(){}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">synchronized</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">Singleton</span><span class="w"> </span><span class="nf">getInstance</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">instance</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Singleton</span><span class="p">();</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">instance</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p><strong>双重检查锁</strong>：饿汉式锁不支持延迟加载，然后懒汉式锁的粒度比较大，不支持高并发。双重检查锁可以实现既延迟加载，又支持高并发。其实就是在判断了没有实例之后，再进行上锁，创建实例。 但是实例必须用<code>volatile</code> 修饰，不然<code>new</code> 操作创建对象时，容易出现重排序的问题。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">DclSingleton</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// volatile如果不加可能会出现半初始化的对象</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序）,为了兼容性我们加上</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">volatile</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">Singleton</span><span class="w"> </span><span class="n">singleton</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="nf">Singleton</span><span class="w"> </span><span class="p">(){}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">Singleton</span><span class="w"> </span><span class="nf">getInstance</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">singleton</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">synchronized</span><span class="w"> </span><span class="p">(</span><span class="n">Singleton</span><span class="p">.</span><span class="na">class</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">singleton</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">singleton</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Singleton</span><span class="p">();</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">singleton</span><span class="p">;</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p><strong>静态内部类</strong>：利用Java的内部类，再调用<code>getInstance()</code>方法的时候，直接返回内部类的实例。他会再调用方法之后，创建内部类的实例对象。实例的唯一性和创建过程的线程安全性，都有JVM来保证。这种方法既是线程安全的，又能够做延迟加载。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">InnerSingleton</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/** 私有化构造器 */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="nf">Singleton</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/** 对外提供公共的访问方法 */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">Singleton</span><span class="w"> </span><span class="nf">getInstance</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">SingletonHolder</span><span class="p">.</span><span class="na">INSTANCE</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/** 写一个静态内部类，里面实例化外部类 */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">class</span> <span class="nc">SingletonHolder</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Singleton</span><span class="w"> </span><span class="n">INSTANCE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Singleton</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p><strong>枚举</strong>：通过Java枚举类型本身的特性，保证实例创建线程的安全性和实例的唯一性。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 使用枚举实现单例模式</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">enum</span><span class="w"> </span><span class="n">Singleton</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">INSTANCE</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 单例中的方法示例</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">doSomething</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;单例方法执行&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 使用方法：</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Singleton</span><span class="p">.</span><span class="na">INSTANCE</span><span class="p">.</span><span class="na">doSomething</span><span class="p">();</span><span class="w">
</span></span></span></code></pre></div><p>也可以用单例项作为枚举的成员变量，累加器可以像下面这样编写：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">enum</span><span class="w"> </span><span class="n">GlobalCounter</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">INSTANCE</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">AtomicLong</span><span class="w"> </span><span class="n">atomicLong</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AtomicLong</span><span class="p">(</span><span class="n">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="nf">getNumber</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">atomicLong</span><span class="p">.</span><span class="na">incrementAndGet</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
</ol>
<p><strong>【单例模式的安全问题】</strong></p>
<ol>
<li>
<p><strong>反射入侵</strong>：如果想要阻止其他人构造实例，仅仅私有化构造器还是不够的，因为我们可以利用反射机制来获取私有构造器进行构造。如果要避免这种情况发生，可以再构造器当中进行判断实例是否已存在，避免多次利用构造器构造实例</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Singleton</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">volatile</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">Singleton</span><span class="w"> </span><span class="n">singleton</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="nf">Singleton</span><span class="w"> </span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="n">singleton</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">RuntimeException</span><span class="p">(</span><span class="s">&#34;实例：【&#34;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="o">+</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">getClass</span><span class="p">().</span><span class="na">getName</span><span class="p">()</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;】已经存在，该实例只允许实例化一次&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">Singleton</span><span class="w"> </span><span class="nf">getInstance</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">singleton</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kd">synchronized</span><span class="w"> </span><span class="p">(</span><span class="n">Singleton</span><span class="p">.</span><span class="na">class</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">singleton</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">singleton</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Singleton</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">singleton</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 利用反射机制来入侵构造实例</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="nd">@Test</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">testReflect</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">NoSuchMethodException</span><span class="p">,</span><span class="w"> </span><span class="n">InvocationTargetException</span><span class="p">,</span><span class="w"> </span><span class="n">InstantiationException</span><span class="p">,</span><span class="w"> </span><span class="n">IllegalAccessException</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Class</span><span class="o">&lt;</span><span class="n">DclSingleton</span><span class="o">&gt;</span><span class="w"> </span><span class="n">clazz</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DclSingleton</span><span class="p">.</span><span class="na">class</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Constructor</span><span class="o">&lt;</span><span class="n">DclSingleton</span><span class="o">&gt;</span><span class="w"> </span><span class="n">constructor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">clazz</span><span class="p">.</span><span class="na">getDeclaredConstructor</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">constructor</span><span class="p">.</span><span class="na">setAccessible</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">boolean</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DclSingleton</span><span class="p">.</span><span class="na">getInstance</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">constructor</span><span class="p">.</span><span class="na">newInstance</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">log</span><span class="p">.</span><span class="na">info</span><span class="p">(</span><span class="s">&#34;flag -&gt; {}&#34;</span><span class="p">,</span><span class="n">flag</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p><strong>序列化与反序列化</strong>：如果单例存到文件流当中，再进行反序列话，也不是同一个实例。但是可以用<code>readResolve()</code>的方法，将返回值作为反序列化的结果，而不会克隆一个新的实例，保证jvm当中只有一个实例存在。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Test</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">testSerialize</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">IllegalAccessException</span><span class="p">,</span><span class="w"> </span><span class="n">NoSuchMethodException</span><span class="p">,</span><span class="w"> </span><span class="n">IOException</span><span class="p">,</span><span class="w"> </span><span class="n">ClassNotFoundException</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 获取单例并序列化</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Singleton</span><span class="w"> </span><span class="n">singleton</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Singleton</span><span class="p">.</span><span class="na">getInstance</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">FileOutputStream</span><span class="w"> </span><span class="n">fout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">FileOutputStream</span><span class="p">(</span><span class="s">&#34;D://singleton.txt&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">ObjectOutputStream</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ObjectOutputStream</span><span class="p">(</span><span class="n">fout</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">out</span><span class="p">.</span><span class="na">writeObject</span><span class="p">(</span><span class="n">singleton</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 将实例反序列化出来</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">FileInputStream</span><span class="w"> </span><span class="n">fin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">FileInputStream</span><span class="p">(</span><span class="s">&#34;D://singleton.txt&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">ObjectInputStream</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ObjectInputStream</span><span class="p">(</span><span class="n">fin</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Object</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">in</span><span class="p">.</span><span class="na">readObject</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">log</span><span class="p">.</span><span class="na">info</span><span class="p">(</span><span class="s">&#34;他们是同一个实例吗？{}&#34;</span><span class="p">,</span><span class="n">o</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">singleton</span><span class="p">);</span><span class="w"> </span><span class="c1">// 如果直接获取，反序列化后的不是同一个实例</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 添加readResolve()来解决序列化和反序列化问题</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Singleton</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Serializable</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 省略其他的内容</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">Singleton</span><span class="w"> </span><span class="nf">getInstance</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 需要加这么一个方法</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="nf">readResolve</span><span class="p">(){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">singleton</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
</ol>
<p><strong>【为什么要用单例模式】</strong></p>
<ol>
<li>
<p><strong>为了全局唯一</strong>：系统中如配置类、全局计数器等类型，应该都都只能保存一份数据，不应该有多份数据。</p>
<ul>
<li>配置类：系统仅有一个配置文件，加载到内存后映射成唯一的配置实例</li>
<li>全局计数器：用于数据统计、生成全局递增<code>id</code> 等功能，必须要是唯一的，否则可能导致统计无效、<code>ID</code> 重复等问题。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 全局id生成器</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">GlobalCounter</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">AtomicLong</span><span class="w"> </span><span class="n">atomicLong</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AtomicLong</span><span class="p">(</span><span class="n">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">GlobalCounter</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">GlobalCounter</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 私有化无参构造器</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="nf">GlobalCounter</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">GlobalCounter</span><span class="w"> </span><span class="nf">getInstance</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">instance</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">long</span><span class="w"> </span><span class="nf">getId</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">atomicLong</span><span class="p">.</span><span class="na">incrementAndGet</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 查看当前的统计数量</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kt">long</span><span class="w"> </span><span class="n">courrentNumber</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GlobalCounter</span><span class="p">.</span><span class="na">getInstance</span><span class="p">().</span><span class="na">getId</span><span class="p">();</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p><strong>处理资源访问冲突</strong>：假如需要日志输出的功能，可以使用单例i面资源访问冲突</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Logger</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">basePath</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;D://log/&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">Logger</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Logger</span><span class="p">();</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">FileWriter</span><span class="w"> </span><span class="n">writer</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="nf">Logger</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">File</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">File</span><span class="p">(</span><span class="n">basePath</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">writer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">FileWriter</span><span class="p">(</span><span class="n">file</span><span class="p">,</span><span class="w"> </span><span class="kc">true</span><span class="p">);</span><span class="w"> </span><span class="c1">//true表示追加写入</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">IOException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">RuntimeException</span><span class="p">(</span><span class="n">e</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">Logger</span><span class="w"> </span><span class="nf">getInstance</span><span class="p">(){</span><span class="w"> </span><span class="c1">//确保全局只有一个logger实例对象</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">instance</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">log</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">message</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">writer</span><span class="p">.</span><span class="na">write</span><span class="p">(</span><span class="n">message</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">IOException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">RuntimeException</span><span class="p">(</span><span class="n">e</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">setBasePath</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">basePath</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">basePath</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">basePath</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
</ol>
<p><strong>【单例模式存在的问题】</strong></p>
<ol>
<li><strong>无法支持面向对象编程<code>OOP</code></strong>： <code>OOP</code> 的三大特性是<strong>封装、继承、多态</strong>。单例把构造函数私有化了，不支持继承和多态。所以无法对它进行拓展。</li>
<li><strong>很难横向拓展</strong>：单例类只能有一个对象实例，如果后面需要进行拓展，创建多个实例。必须修改源码，无法友好拓展。</li>
</ol>
<p><strong>【不同作用范围的单例模式】</strong></p>
<ol>
<li>
<p>线程级别单例：单例类对象是进程唯一的，如果想要线程唯一。在不使用<code>ThreadLocal</code>的时候，可以采用<code>ConCurrentHashMap</code> 的方式，用线程<code>id</code>为<code>key</code>， 实例为<code>value</code>。每个线程的存取都从共享的 <code>map</code> 当中进行操作。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Connection</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">ConcurrentHashMap</span><span class="o">&lt;</span><span class="n">Long</span><span class="p">,</span><span class="w"> </span><span class="n">Connection</span><span class="o">&gt;</span><span class="w"> </span><span class="n">instances</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ConcurrentHashMap</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="nf">Connection</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">Connection</span><span class="w"> </span><span class="nf">getInstance</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Long</span><span class="w"> </span><span class="n">currentThreadId</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">getId</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">instances</span><span class="p">.</span><span class="na">putIfAbsent</span><span class="p">(</span><span class="n">currentThreadId</span><span class="p">,</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Connection</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">instances</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">currentThreadId</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p><strong>容器级别的单例</strong>：将单例的作用范围由进程切换到一个容器，可能会更加方便我们进行单例对象的管理。这也是<code>Spring</code> 的核心思想。<code>Spring</code> 提供一个单例容器，确保一个实例是容器级别的单例，并且在容器启动时完成初始化。具体优势如下：</p>
<ul>
<li>所有的<code>bean</code> 都以单例的形式存放在容器中，避免大量的对象被创建，造成<code>JVM</code> 内存抖动严重，频繁<code>GC</code>。</li>
<li>程序启动时，初始化单例<code>bean</code>， 满足<code>fast-fail</code>，将所有构建过程的异常暴露在启动时，而非运行时。</li>
<li>缓存了所有单例<code>bean</code>，启动的过程相当于预热的过程，运行时不必进行对象创建，效率更高。</li>
<li>容器管理<code>bean</code>的生命周期，结合依赖注入使得解耦更加彻底、扩展性更好。</li>
</ul>
</li>
</ol>
<h2 id="2-什么是策略模式一般用在什么场景">2. 什么是策略模式？一般用在什么场景？<a hidden class="anchor" aria-hidden="true" href="#2-什么是策略模式一般用在什么场景">#</a></h2>
<p>策略模式是行为设计模式的一种，通过定义一系列的算法类。允许在运行时动态选择算法，从而实现更加灵活的代码结构。该模式用于组织和调用这些算法，让程序结构变得更加灵活，具有更好的维护性和扩展性。</p>
<p>策略模式一般用于当一个功能存在多种算法的时候，需要根据不同的情况使用不同的计算算法(都封装成类的)。这样就可以避免利用大量的<code>if-else</code> 或者 <code>switch-else</code></p>
<p><strong>【为什么要用策略模式】</strong></p>
<ul>
<li><strong>避免程序存在判断或选择分支语句</strong>：当程序存在大量的 <code>if-else</code> 或者 <code>switch-else</code> 判断语句，代码可能变得难以维护</li>
<li><strong>避免破坏现有功能</strong>：当算法的实现经常变更或需要拓展的时候，直接修改代码可能会破坏现有功能。</li>
</ul>
<p><strong>【策略模式的场景】</strong></p>
<ul>
<li><strong>多种算法可互换</strong>：需要动态选择算法，例如排序算法的选择。有很多种排序算法，可以把不同的排序方式封装成一个独立的算法类 (快速排序、归并排序、直接插入排序等)</li>
<li><strong>避免条件语句</strong>：采用策略模式替换掉代码当中的大量<code>if-else</code> 或 <code>switch</code> 语句</li>
<li><strong>与上下文独立</strong>：客户端不需要知道具体的实现细节，只需以来抽象策略。</li>
</ul>
<p><strong>【策略模式典型应用场景】</strong></p>
<ul>
<li><strong>支付系统</strong>：支持多种支付方式，比如微信、支付宝、信用卡</li>
<li><strong>数据压缩</strong>：提供不同的压缩算法</li>
<li><strong>日志策略</strong>：根据日志级别动态选择记录策略</li>
</ul>
<p><strong>【策略模式的组成】</strong></p>
<ul>
<li><strong><code>Strategy</code> 策略</strong>：用来约束一系列具体的策略算法。<code>Context</code> 上下文使用这个接口来调用具体的策略实现定义的算法。如果多个算法具有公共功能的化，把<code>Strategy</code> 实现为抽象类，然后把多个算法的功能实现到<code>Stragy</code> 里面。 (比如多种排序算法，都放在 <code>Strategy</code> 抽象类里面)</li>
<li><strong><code>ConcreteStrategy</code> 具体策略</strong>： 具体的策略实现，负责实现<code>Strategy</code> 策略的接口 (多种排序算法的具体实现)</li>
<li><strong><code>Context</code> 上下文</strong>：上下文是负责和具体的策略类交互，通常上下文会吃有一个真正的策略实现 (就是调用哪个排序方法，比如说 <code>main</code> 函数)</li>
</ul>
<p><img alt="策略模式的组成" loading="lazy" src="https://oss.swimmingliu.cn/f649bf1f-fb59-11ef-8f2a-c858c0c1deba"></p>
<h2 id="3-什么是模板方法模式一般用在什么场景">3. 什么是模板方法模式？一般用在什么场景？<a hidden class="anchor" aria-hidden="true" href="#3-什么是模板方法模式一般用在什么场景">#</a></h2>
<p>模板方法就是在抽象类里面定义好算法的骨架，具体步骤在子类实现。</p>
<p><strong>【模板方法特点】</strong></p>
<ol>
<li><strong>算法骨架</strong>：在基类中定义一个算法的固定执行步骤，具体实现步骤交给子类实现</li>
<li><strong>复用代码</strong>：子类复用基类中定义的公共逻辑，只需要实现特定的逻辑</li>
<li><strong>遵循开闭规则</strong>：模板方法是扩展开放，修改闭合的</li>
</ol>
<p><strong>【典型使用场景】</strong></p>
<ul>
<li><strong>数据请求处理</strong>: 读取数据、处理数据、输出结果</li>
<li><strong>Web请求处理</strong>：解析请求、处理逻辑、返回响应</li>
<li><strong><code>String Template</code> 字符串模板</strong></li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;World&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">String</span><span class="w"> </span><span class="n">greeting</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">STR</span><span class="p">.</span><span class="s">&#34;Hello, \{name}!&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">greeting</span><span class="p">);</span><span class="w"> </span><span class="c1">// 输出: Hello, World!</span><span class="w">
</span></span></span></code></pre></div><h2 id="4-谈谈你了解的最常见的几种设计模式说说他们的应用场景">4. 谈谈你了解的最常见的几种设计模式，说说他们的应用场景<a hidden class="anchor" aria-hidden="true" href="#4-谈谈你了解的最常见的几种设计模式说说他们的应用场景">#</a></h2>
<p><strong>【常见的设计模式】</strong></p>
<ul>
<li><strong>单例模式</strong>：保证系统中一个类只有一个实例对象，比如全局配置、全局计数器、数据库连接池</li>
<li><strong>策略模式</strong>：封装一组算法让他们之间能够相互替代，避免大量的<code>if-else</code> 和 <code>switch-case</code> 语句，比如用户选择不同的支付策略，或者调用不同的排序算法。</li>
<li><strong>模板模式</strong>：提炼核心流程封装成一个方法，比如像支付逻辑(参数校验、调起支付接口、修改支付状态)，除了调起支付接口以外，其他的流程基本一致。所以可以封装成模板方法，然后把调起支付接口的操作，在具体实现方法当中重写该方法。</li>
<li><strong>简单工厂模式</strong>：获取不同的对象时可以使用，将对象的创建逻辑抽离复用。</li>
<li><strong>外观模式</strong>：为子系统提供一组统一接口，隐藏内部实现细节，方便子系统直接调用，而无需关注实现细节(比如高德和百度的 <code>SDK</code>)</li>
<li><strong>代理模式</strong>：通过创建代理对象来控制哦对实际对象的访问，例如<code>Sping AOP</code>切面编程采用代理模式来动态生成增强目标对象的代理 (通过 <code>JDK</code> 动态代理或者<code>CGLIB</code>代理) 。<code>Sping AOP</code> 默认优先使用 JDK 动态代理。当目标类未实现接口时，才会切换为 CGLIB 动态代理。</li>
</ul>
<p><strong>【Spring中的设计模式】</strong></p>
<p><img alt="Spring中的设计模式" loading="lazy" src="https://oss.swimmingliu.cn/f6a094ff-fb59-11ef-b5d7-c858c0c1deba"></p>
<h2 id="5-你认为好的代码应该是什么样的">5. 你认为好的代码应该是什么样的？<a hidden class="anchor" aria-hidden="true" href="#5-你认为好的代码应该是什么样的">#</a></h2>
<p><strong>【通俗易懂的讲】</strong></p>
<ul>
<li><strong>清晰易懂，保持简洁和易读性</strong>：代码简洁、直观，函数和变量命名都有意义，可读性非常强，有合理的注释。</li>
<li><strong>高内聚低耦合</strong>：高内聚是指代码模块内部功能集中，每个模块都有单一职责。低耦合指的是不同模块之间的依赖关系尽量松散，修改一个模块的时候，其他模块受到的影响比较小。</li>
<li><strong>可测试</strong>：每个模块都设计为独立的、可验证的单元，编写单元测试用例的时候，能够确保代码的正确性并且发现潜在问题。</li>
<li><strong>易于扩展，遵循开闭原则</strong>：代码具有一定灵活性，能在不破坏现有功能的情况下，方便进行扩展和修改。</li>
<li><strong>符合团队规范</strong>：代码风格和团队整体代码规范统一，有助于协助团队协作和代码审查。</li>
<li><strong>减少硬编码、魔法值</strong>：尽量避免硬编码和魔法值的现象，方便后续进行修改。</li>
</ul>
<p><strong>【好代码具备以下特性】</strong></p>
<table>
  <thead>
      <tr>
          <th>设计原则</th>
          <th>代码特性</th>
          <th>结果</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>单一职责</td>
          <td>类或模块职责单一</td>
          <td>降低类的复杂度，增强可读性和维护性</td>
      </tr>
      <tr>
          <td>开闭原则</td>
          <td>对扩展开放，对修改关闭</td>
          <td>提高扩展性，减少对已有代码的修改</td>
      </tr>
      <tr>
          <td>高内聚低耦合</td>
          <td>模块职责明确，依赖关系松散</td>
          <td>增强代码的可维护性和扩展性</td>
      </tr>
      <tr>
          <td>接口隔离原则</td>
          <td>接口小且专用</td>
          <td>减少无关实现代码，增强接口的灵活性</td>
      </tr>
      <tr>
          <td>依赖倒置</td>
          <td>依赖于抽象而非具体实现</td>
          <td>降低模块间的耦合度，提高代码灵活性</td>
      </tr>
      <tr>
          <td>合成复用原则</td>
          <td>优先使用组合而非继承</td>
          <td>提高灵活性，避免继承导致的高聚合</td>
      </tr>
      <tr>
          <td>里氏替换原则</td>
          <td>子类可以无缝替换父类</td>
          <td>确保继承体系的正确性，增强代码的稳定性</td>
      </tr>
      <tr>
          <td>迪米特法则</td>
          <td>减少类之间的依赖</td>
          <td>降低耦合度，增强模块独立性</td>
      </tr>
  </tbody>
</table>
<h2 id="6-工厂模式和抽象工厂模式有什么区别">6. 工厂模式和抽象工厂模式有什么区别？<a hidden class="anchor" aria-hidden="true" href="#6-工厂模式和抽象工厂模式有什么区别">#</a></h2>
<p><strong>【工厂模式】</strong></p>
<ul>
<li><strong>对象</strong>：创建一种类型的产品对象，比如让google创建安卓系统， 不同品牌的手机厂商(工厂子类)就可以根据安卓系统当中的功能，重写出其他的<code>os</code> 系统，比如鸿蒙系统、澎湃系统等等</li>
<li><strong>工厂结构</strong>：有且只有一个抽象的工厂类，定义创建产品的抽象方法，然后具体的工厂子类去实现这个方法来实际创建具体的产品。比如 <code>android</code> 系统的源码是大家都可以看到的，其他厂商也可以根据<code>android</code> 系统的设计，重新实现部分函数，修改成其他的功能。</li>
<li><strong>使用场景</strong>：当创建过程比较复杂，想把对象创建和使用分离时常用，比如创建数据库连接对象等简单的单一产品创建创建适用。</li>
</ul>
<p><strong>【抽象工厂模式】</strong></p>
<ul>
<li><strong>对象</strong>：用于创建一系列相关的产品对象，比如创建手机的时候，需要连带创建配套的充电器、耳机等配套产品</li>
<li><strong>工厂结构</strong>：抽象工厂类定义了多个抽象创建方法，分别用于创建一系列相关的产品。更具体的工厂子类要实现这些抽象方法，提供一整套的具体产品的创建。</li>
<li><strong>使用场景</strong>：当系统要创建多个相互依赖或者关联的对象的时候，确保这些对象搭配合理。比如游戏开发中创建不同风格(比如科技风格、古风)的角色、武器、场景等一整套相关的元素时，就适合用抽象工厂模式。</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 抽象产品A</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">interface</span> <span class="nc">ProductA</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">use</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 具体产品A1 -&gt; 手机</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">ConcreteProductA1</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">ProductA</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">use</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Using ConcreteProductA1&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 具体产品A2 -&gt; 电脑</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">ConcreteProductA2</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">ProductA</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">use</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Using ConcreteProductA2&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 抽象产品B</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">interface</span> <span class="nc">ProductB</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">eat</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 具体产品B1 -&gt; 手机充电线</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">ConcreteProductB1</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">ProductB</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">eat</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Eating ConcreteProductB1&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 具体产品B2 -&gt; 电脑充电线</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">ConcreteProductB2</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">ProductB</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">eat</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;Eating ConcreteProductB2&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 抽象工厂 -&gt; 把两个相互关联的抽象产品一起创建</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">interface</span> <span class="nc">AbstractFactory</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">ProductA</span><span class="w"> </span><span class="nf">createProductA</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">ProductB</span><span class="w"> </span><span class="nf">createProductB</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 具体工厂1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">ConcreteFactory1</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">AbstractFactory</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">ProductA</span><span class="w"> </span><span class="nf">createProductA</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ConcreteProductA1</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">ProductB</span><span class="w"> </span><span class="nf">createProductB</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ConcreteProductB1</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 具体工厂2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">ConcreteFactory2</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">AbstractFactory</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">ProductA</span><span class="w"> </span><span class="nf">createProductA</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ConcreteProductA2</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">ProductB</span><span class="w"> </span><span class="nf">createProductB</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ConcreteProductB2</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 使用抽象工厂创建产品</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Client</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">AbstractFactory</span><span class="w"> </span><span class="n">factory1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ConcreteFactory1</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">ProductA</span><span class="w"> </span><span class="n">productA1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factory1</span><span class="p">.</span><span class="na">createProductA</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">ProductB</span><span class="w"> </span><span class="n">productB1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factory1</span><span class="p">.</span><span class="na">createProductB</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">productA1</span><span class="p">.</span><span class="na">use</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">productB1</span><span class="p">.</span><span class="na">eat</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">AbstractFactory</span><span class="w"> </span><span class="n">factory2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ConcreteFactory2</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">ProductA</span><span class="w"> </span><span class="n">productA2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factory2</span><span class="p">.</span><span class="na">createProductA</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">ProductB</span><span class="w"> </span><span class="n">productB2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">factory2</span><span class="p">.</span><span class="na">createProductB</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">productA2</span><span class="p">.</span><span class="na">use</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">productB2</span><span class="p">.</span><span class="na">eat</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div>

  </div>



  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://swimmingliu.cn/tags/java/">Java</a></li>
      <li><a href="https://swimmingliu.cn/tags/design-mode/">Design Mode</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://swimmingliu.cn/posts/job/computer-networks-interview-questions/">
    <span class="title">« Prev</span>
    <br>
    <span>计算机网络面试题笔记</span>
  </a>
  <a class="next" href="https://swimmingliu.cn/posts/job/java-juc-interview-questions/">
    <span class="title">Next »</span>
    <br>
    <span>(JUC) Java并发面试题笔记</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2023-2025 <a href="https://swimmingliu.cn/">SwimmingLiu&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
    <span>
        <a href="https://beian.miit.gov.cn/">浙ICP备2024056260号</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
