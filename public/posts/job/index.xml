<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>💻 Job on SwimmingLiu&#39;s Blog</title>
    <link>https://swimmingliu.cn/posts/job/</link>
    <description>Recent content in 💻 Job on SwimmingLiu&#39;s Blog</description>
    <image>
      <title>SwimmingLiu&#39;s Blog</title>
      <url>https://swimmingliu.cn/papermod-cover.png</url>
      <link>https://swimmingliu.cn/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.146.4</generator>
    <language>en</language>
    <lastBuildDate>Sat, 22 Mar 2025 21:45:41 +0800</lastBuildDate>
    <atom:link href="https://swimmingliu.cn/posts/job/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>JVM 面试题笔记</title>
      <link>https://swimmingliu.cn/posts/job/java-jvm-interview-questions/</link>
      <pubDate>Sat, 22 Mar 2025 21:45:41 +0800</pubDate>
      <guid>https://swimmingliu.cn/posts/job/java-jvm-interview-questions/</guid>
      <description>&lt;p&gt;&lt;code&gt;JVM&lt;/code&gt; 全局构架图如下，包含 &lt;code&gt;JVM&lt;/code&gt; 的全部内容&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;JVM-全局结构图&#34; loading=&#34;lazy&#34; src=&#34;https://oss.swimmingliu.cn/695c3cf0-098e-11f0-a8ba-c858c0c1deba&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-jvm-的内存区域是如何划分的&#34;&gt;1. JVM 的内存区域是如何划分的？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;JVM&lt;/code&gt; 内存当中，运行时数据的区域包含堆、方法区（元空间）、虚拟机栈、本地方法栈、程序计数器。另外，其他的内存区域属于本地内存，本地内存就包括直接内存，直接内存是非运行时数据区的一部分。
其中，堆和方法区（元空间） 是线程共享的，虚拟机栈、本地方法栈、程序计数器都是线程私有的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【注意】&lt;/strong&gt; &lt;code&gt;JVM&lt;/code&gt; 规范对于运行时数据区域的规定是很宽松的。就拿堆来说，堆可以是连续空间，也可以是不连续空间。堆的大小可以固定，也可以再运行时按照需求进行扩展。虚拟机实现者可以使用任何&lt;strong&gt;垃圾回收算法&lt;/strong&gt;管理堆，甚至完全不进行垃圾回收也是可以的。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;JVM内存区域&#34; loading=&#34;lazy&#34; src=&#34;https://oss.swimmingliu.cn/6ebff0fa-07e8-11f0-86bd-c858c0c1debd&#34;&gt;&lt;/p&gt;
&lt;p&gt;下面逐一介绍不同部分的功能和作用&lt;/p&gt;
&lt;p&gt;首先是线程私有的部分，&lt;strong&gt;程序计数器&lt;/strong&gt;、&lt;strong&gt;虚拟机栈&lt;/strong&gt;、&lt;strong&gt;本地方法栈&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【程序计数器】&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：程序计数器就是记录当前所执行的字节码的行号。字节码解释器通过改变程序计数器的值，来选取下一条需要执行的字节码指令。它的生命周期随着线程的创建而创建，随着线程的结束而死亡。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：分支、循环、跳转、异常处理、线程恢复这些功能都需要依赖程序计数器完成。比如线程切换上下文中，从 &lt;code&gt;A线程&lt;/code&gt; 先切换到 &lt;code&gt;B线程&lt;/code&gt;，然后从 &lt;code&gt;B线程&lt;/code&gt; 恢复到 &lt;code&gt;A线程&lt;/code&gt; 的过程当中，为了 &lt;code&gt;A线程&lt;/code&gt; 能够恢复到正确的执行位置，就需要读取 &lt;code&gt;A线程&lt;/code&gt; 程序计数器的值，来确认切换线程前执行的位置在哪里。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;为什么是线程私有&lt;/strong&gt;：因为线程切换的过程当中，每个线程都需要一个程序计数器来记录自己的程序执行位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;【注意】&lt;/strong&gt; 程序计数器是唯一一个不会出现 &lt;code&gt;OOM&lt;/code&gt; 内存不足的内存区域，因为他就只是存储一个值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【虚拟机栈】&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：虚拟机栈按照先进后出的方案存储的是非本地方法的调用对应的&lt;strong&gt;栈帧&lt;/strong&gt;。每一次方法调用的时候会被压入栈中，方法结束的时候会被弹出栈中。栈帧中包含&lt;strong&gt;局部变量表&lt;/strong&gt;、&lt;strong&gt;操作次数栈&lt;/strong&gt;（存储操作数和临时计算结果）、&lt;strong&gt;动态链接&lt;/strong&gt;、&lt;strong&gt;方法的返回地址&lt;/strong&gt;。虚拟机的生命周期随着线程的创建而创建，随着线程的结束而死亡。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：存储非本地方法的栈帧，支持方法的调用和返回。当栈深度超过虚拟机允许的最大深度，会抛出 &lt;code&gt;StackOverflowError&lt;/code&gt; 栈溢出异常。如果虚拟机栈无法动态扩展或申请到足够的内存，会抛出 &lt;code&gt;OutOfMemoryError&lt;/code&gt; 内存不足异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;JVM-虚拟机栈-完整结构&#34; loading=&#34;lazy&#34; src=&#34;https://oss.swimmingliu.cn/6f22fcdc-07e8-11f0-92ef-c858c0c1debd&#34;&gt;&lt;/p&gt;
&lt;p&gt;栈帧中包含&lt;strong&gt;局部变量表&lt;/strong&gt;、&lt;strong&gt;操作次数栈&lt;/strong&gt;（存储操作数和临时变量）、&lt;strong&gt;动态链接&lt;/strong&gt;、&lt;strong&gt;方法的返回地址&lt;/strong&gt;。其中，局部变量表存放的是所有的局部变量，或者其出对应的地址（数组）。动态链接就是当前类常量池的引用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;局部变量表&lt;/strong&gt;：存放&lt;strong&gt;方法参数传入的形参值&lt;/strong&gt;，&lt;strong&gt;方法内的局部变量&lt;/strong&gt;、&lt;strong&gt;方法的 &lt;code&gt;this&lt;/code&gt; 引用&lt;/strong&gt;。内部结构主要存放了编译期可知的各种数据类型（&lt;code&gt;boolean&lt;/code&gt;、&lt;code&gt;byte&lt;/code&gt;、&lt;code&gt;char&lt;/code&gt;、&lt;code&gt;short&lt;/code&gt;、&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;float&lt;/code&gt;、&lt;code&gt;long&lt;/code&gt;、&lt;code&gt;double&lt;/code&gt;）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作数栈&lt;/strong&gt;：主要作为&lt;strong&gt;方法调用的中转站&lt;/strong&gt;使用，用于存放&lt;strong&gt;方法执行过程中&lt;/strong&gt;产生的&lt;strong&gt;中间计算结果&lt;/strong&gt;。另外，&lt;strong&gt;计算过程中产生的临时变量&lt;/strong&gt;也会放在操作数栈中。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态链接&lt;/strong&gt;：主要作用是实现在&lt;strong&gt;当前方法中调用其他方法&lt;/strong&gt;。 &lt;code&gt;Class&lt;/code&gt; 文件的常量池里面保存有大量的符号引用，比如方法的符号引用。 当一个方法需要调用其他方法，需要将常量池中只想方法的符号引用转换为在内存地址当中的直接引用。动态链接的作用就是&lt;strong&gt;把常量池的符号引用转换为内存当中的直接引用&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;【本地方法栈】&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：本地方法栈和虚拟栈的结构是一样的。不同的是，本地方法栈是 &lt;code&gt;JVM&lt;/code&gt; 调用 &lt;code&gt;Native&lt;/code&gt; 方法的时候才会用到的，虚拟机栈是执行 &lt;code&gt;Java&lt;/code&gt; 自身的方法 (也就是字节码) 会用到的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：存储本地方法 (&lt;code&gt;Native&lt;/code&gt;) 栈帧，支持方法的调用和返回。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;【注意】&lt;/strong&gt; 在 &lt;code&gt;HotSpot&lt;/code&gt; 虚拟机当中，将本地方法栈和虚拟机栈合二为一了。&lt;/p&gt;</description>
    </item>
    <item>
      <title>计算机网络面试题笔记</title>
      <link>https://swimmingliu.cn/posts/job/computer-networks-interview-questions/</link>
      <pubDate>Thu, 13 Mar 2025 21:49:44 +0800</pubDate>
      <guid>https://swimmingliu.cn/posts/job/computer-networks-interview-questions/</guid>
      <description>&lt;h2 id=&#34;1-tcp-和-udp-有什么区别&#34;&gt;1. TCP 和 UDP 有什么区别？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;TCP&lt;/code&gt; 是一种可靠的、面向连接、基于字节流传输的传输协议，能够保证数据的顺序，但是其延迟比较大。一般适用于需要数据完整性和顺序的场景，比如文件传输、邮件、&lt;code&gt;Web&lt;/code&gt; 网站。
&lt;code&gt;UDP&lt;/code&gt; 是一种不可靠的、无连接、基于数据报传输的传输协议，不能保证数据的顺序，但是延迟比较小。一般适用于需要高性能要求和快速传输数据的应用，比如实时通讯、语音、视频、游戏等。&lt;/p&gt;
&lt;p&gt;【注意】&lt;code&gt;TCP&lt;/code&gt; 和 &lt;code&gt;UDP&lt;/code&gt; 都属于传输层&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;特性&lt;/th&gt;
          &lt;th&gt;TCP&lt;/th&gt;
          &lt;th&gt;UDP&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;连接方式&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;面向连接 (三次握手)&lt;/td&gt;
          &lt;td&gt;无连接&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;可靠性和顺序保证&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;可靠，保证数据按顺序送达&lt;/td&gt;
          &lt;td&gt;不可靠，不能保证数据的顺序，而不能保证安全送达&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;流量控制/拥塞控制&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;提供流量控制和拥塞控制&lt;/td&gt;
          &lt;td&gt;没有流量控制和拥塞控制&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;头部大小&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;头部较大 (&lt;code&gt;20&lt;/code&gt; ~ &lt;code&gt;80&lt;/code&gt; 字节)&lt;/td&gt;
          &lt;td&gt;较小 (只有 &lt;code&gt;8&lt;/code&gt; 字节)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;性能&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;较低，延迟大&lt;/td&gt;
          &lt;td&gt;较高，延迟小&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;是否支持广播&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;不支持广播&lt;/td&gt;
          &lt;td&gt;支持广播&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;数据传输模式&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;通过字节流传输&lt;/td&gt;
          &lt;td&gt;通过数据报传输&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;适用场景&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;文件传输、Web、邮件等需要可靠性的传输&lt;/td&gt;
          &lt;td&gt;实时通讯、语音、视频、游戏等高性能要求应用&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;基于两者的协议&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;1. &lt;strong&gt;HTTP协议&lt;/strong&gt;：超文本和多媒体内容的协议&lt;br /&gt;2. &lt;strong&gt;HTTPS协议&lt;/strong&gt;：基于HTTP协议上加了一层&lt;code&gt;SSL&lt;/code&gt; / &lt;code&gt;TSL&lt;/code&gt; 外壳，保证了数据传输的安全性&lt;br /&gt;3. &lt;strong&gt;FTP协议&lt;/strong&gt;： 文件传输协议，用来传文件到服务器的&lt;br /&gt;4. &lt;strong&gt;SMTP协议&lt;/strong&gt;：简单邮件协议，用于发送邮件的协议 (&lt;code&gt;POP3&lt;/code&gt; 协议： 负责邮件接受的协议)&lt;/td&gt;
          &lt;td&gt;1. &lt;strong&gt;HTTP 3.0 协议&lt;/strong&gt;: 基于 &lt;code&gt;UDP&lt;/code&gt; 的&lt;code&gt;QUIC&lt;/code&gt; 协议&lt;br /&gt;2. &lt;strong&gt;DHCP 协议&lt;/strong&gt;： 动态主机配置协议，动态配置 &lt;code&gt;IP&lt;/code&gt; 地址&lt;br /&gt;3. &lt;strong&gt;DNS&lt;/strong&gt; ：域名解析系统，将域名转变为机器刻度的 &lt;code&gt;IP&lt;/code&gt; 地址&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;【ISO 和 TCP/IP 模型】&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>设计模式面试题笔记</title>
      <link>https://swimmingliu.cn/posts/job/desgin-mode-interview-questions/</link>
      <pubDate>Fri, 07 Mar 2025 21:44:36 +0800</pubDate>
      <guid>https://swimmingliu.cn/posts/job/desgin-mode-interview-questions/</guid>
      <description>&lt;h2 id=&#34;1-单例模式有哪几种实现如何保证线程安全&#34;&gt;1. 单例模式有哪几种实现？如何保证线程安全？&lt;/h2&gt;
&lt;p&gt;首先，单例模式和工厂模式都是一种设计模式。单例模式当中，一个类只允许创建一个对象(或者说实例)， 那这个类就是单例类。单例类是不可以被继承的，也没有了多态的特性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【单例类的实现方式】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常规单例模式有五种写法，但是编写代码的过程当中，要注意以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;构造器需要私有化&lt;/li&gt;
&lt;li&gt;暴露一个公共获取单例对象的接口 （&lt;code&gt;obj.getInstance()&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;是否支持懒加载 &lt;code&gt;延迟加载&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;是否线程安全&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;五种写法为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;饿汉式&lt;/strong&gt;： 类加载的时候，就一起把 &lt;code&gt;instance&lt;/code&gt; 静态实例创建好了，所以创建的过程市线程安全的。&lt;/p&gt;
&lt;p&gt;饿汉式的单例模式虽然不支持懒加载，有点浪费资源。但其实不会占用太多资源，并且如果一个实例初始化的过程比较复杂，就应该放在启动的时候来处理，避免运行时卡顿或发生问题， 满足&lt;code&gt;fail-fast&lt;/code&gt; 失败快速解决的设计原则&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;EagerSingleton&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Singleton&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;instance&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Singleton&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Singleton&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Singleton&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;getInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    	&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;instance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;懒汉式&lt;/strong&gt;：相较于饿汉式的方式，修改成延迟加载的模式。注意&lt;code&gt;getInstance()&lt;/code&gt;方法没有上锁的话，在大量线程并发请求的时候，可能创建多个实例。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Singleton&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Singleton&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;instance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Singleton&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;synchronized&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Singleton&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;getInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;instance&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;instance&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Singleton&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;instance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;双重检查锁&lt;/strong&gt;：饿汉式锁不支持延迟加载，然后懒汉式锁的粒度比较大，不支持高并发。双重检查锁可以实现既延迟加载，又支持高并发。其实就是在判断了没有实例之后，再进行上锁，创建实例。 但是实例必须用&lt;code&gt;volatile&lt;/code&gt; 修饰，不然&lt;code&gt;new&lt;/code&gt; 操作创建对象时，容易出现重排序的问题。&lt;/p&gt;</description>
    </item>
    <item>
      <title>(JUC) Java并发面试题笔记</title>
      <link>https://swimmingliu.cn/posts/job/java-juc-interview-questions/</link>
      <pubDate>Wed, 05 Mar 2025 21:45:49 +0800</pubDate>
      <guid>https://swimmingliu.cn/posts/job/java-juc-interview-questions/</guid>
      <description>&lt;h2 id=&#34;1-什么是-java-内存模型jmm&#34;&gt;1. 什么是 Java 内存模型（JMM）？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;JMM&lt;/code&gt; 是 Java内存模型 ， 它是Java虚拟机 &lt;code&gt;JVM&lt;/code&gt; 定义的一种规范，用于描述多线程程序中的变量，像实例字段、静态字段和数组元素，他们如何在内存中存储和传递的规则。也就是规定线程啥时候从住内存里面读数据，啥时候把数据写回到住内存。&lt;code&gt;JMM&lt;/code&gt; 的核心目标是确保多线程环境下的&lt;strong&gt;可见性&lt;/strong&gt;、&lt;strong&gt;有序性&lt;/strong&gt;和&lt;strong&gt;原子性&lt;/strong&gt;, 避免硬件和编译器优化带来的不一致问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JMM&lt;/code&gt;  当中包含&lt;strong&gt;主内存&lt;/strong&gt; (所有线程共享) 和 &lt;strong&gt;工作内存&lt;/strong&gt; （每个线程私有）两种内存。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主内存&lt;/strong&gt;：主内存是Java堆内存的一部分，是线程共享的区域，存储全局变量，比如静态变量、实例字段、数组元素等等。线程不能直接操作主内存，必须通过工作内存间接访问。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工作内存&lt;/strong&gt;：每个线程私有的本地内存，缓存主内存的变量副本。线程对变量的读写操作均在工作内存种进行，修改后的结果需要同步会主内存。线程是通过内存屏障 ( &lt;code&gt;volatile&lt;/code&gt; 关键字) 或者 同步操作 ( &lt;code&gt;synchronized&lt;/code&gt; ) 实现主内存和工作内存的数据一致性的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;【可见性、有序性、原子性定义】&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;可见性&lt;/strong&gt;：确保一个线程对共享变量的修改，能够及时被另外一个线程看到。 &lt;code&gt;volatile&lt;/code&gt;就是用来保证可见性的，强制线程每次读写的时候，直接从主内存当中获取最新值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有序性&lt;/strong&gt;：指线程执行操作的顺序。JMM允许某些指令重排序之后再提高性能，但会保证线程内的操作顺序不会被破坏。通过&lt;code&gt;happens-before&lt;/code&gt; (线程A发生在线程B之前)的关系来保证跨线程的有序性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;原子性&lt;/strong&gt;：操作不可分割，线程不会在执行的过程当中被打断。例如, &lt;code&gt;synchronize&lt;/code&gt; 关键字能确保方法或代码块的原子性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;【JMM作用】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为不同的操作系统都有一套独立的内存模型，但是Java为了满足跨平台的特性，它需要定义一套内存模型屏蔽个操作系统之间的差异。我们可以利用JMM当中定义好的从Java源码到CPU指令的执行规范，也就是使用&lt;code&gt;synchronized&lt;/code&gt; 、&lt;code&gt;volatile&lt;/code&gt; 等关键字，还有&lt;code&gt;happens-before&lt;/code&gt;原则，就可以写出并发安全的代码了。
比如说，线程A和线程B同时操作 &lt;code&gt;变量-1&lt;/code&gt;，假如最开始&lt;code&gt;变量-1&lt;/code&gt; 是 &lt;code&gt;0&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，线程A和线程B都读取了&lt;code&gt;变量-1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;然后，线程B对取到的&lt;code&gt;变量-1&lt;/code&gt;自增为&lt;code&gt;1&lt;/code&gt;，并写回主内存&lt;/li&gt;
&lt;li&gt;此时，线程A对读取到的&lt;code&gt;变量-1&lt;/code&gt;也自增&lt;code&gt;1&lt;/code&gt;，并写回主内存。这就会导致线程B的操作失效了，出现并发安全问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果有JMM，我们就可以在线程A要修改数据之前,让它采用CAS乐观锁的方式进行修改。再次去读主内存当中的值，然后修改之后，再判断一下主内存的值是否发生变化。如果没有发生变化，就写回主内存。如果发生变化，就要进行自旋。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【注意】&lt;/strong&gt; 工作内存是每个线程独立的内存空间，其他线程都是看不到的。主内存是Java堆内存的一部分，所有的实例变量、静态变量和数组元素都存储在主内存当中。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;JMM架构图&#34; loading=&#34;lazy&#34; src=&#34;https://oss.swimmingliu.cn/49ddf552-f9c8-11ef-99c5-c858c0c1deba&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【内存间交互操作类型 (8种原子操作)】&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;lock 上锁&lt;/strong&gt;：把一个变量表示为一条线程独占的状态&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;unlock 解锁&lt;/strong&gt;： 把一个变量从独占状态中释放出来，释放后的变量才能被其他线程锁定&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;read 读取&lt;/strong&gt;： 从主内存当中读取一个变量到工作内存中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;load 载入&lt;/strong&gt;：把&lt;code&gt;read&lt;/code&gt;操作从主内存中得到的变量值放入工作内存的变量副本当中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;use 使用&lt;/strong&gt;：把工作内存当中的一个变量值传递给执行引擎&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;assign 赋值&lt;/strong&gt;：把一个从执行引擎接收到的值赋给工作内存中的变量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;store 存储&lt;/strong&gt;：把工作内存中的一个变量的值传送给主内存中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;write 写入&lt;/strong&gt;：把store操作从工作内存中得到的变量值放入主内存的变量中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;【volatile 特殊规则】&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统面试题笔记</title>
      <link>https://swimmingliu.cn/posts/job/operation-system-interview-questions/</link>
      <pubDate>Sat, 01 Mar 2025 09:49:44 +0800</pubDate>
      <guid>https://swimmingliu.cn/posts/job/operation-system-interview-questions/</guid>
      <description>&lt;h2 id=&#34;1-说说你知道的几种-io-模型&#34;&gt;1. 说说你知道的几种 I/O 模型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;【常见的五大I/O模型】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常见的五大I/O模式分别为: 同步阻塞I/O (Blocking I/O) &lt;code&gt;BIO&lt;/code&gt;、非阻塞I/O (Non-blocking I/O) &lt;code&gt;NIO&lt;/code&gt;、I/O多路复用、信号量驱动I/O、异步I/O &lt;code&gt;AIO&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们假如要烧水喝，看不同模型是怎么烧的水喝&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;strong&gt;I/O 模型&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;特性&lt;/th&gt;
          &lt;th&gt;烧水案例&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;同步阻塞I/O &lt;code&gt;BIO&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;数据从网卡到内核，再从内核到用户空间，都是阻塞操作。&lt;/td&gt;
          &lt;td&gt;自己动手烧水，一直盯着，等水烧开了，倒在杯子里喝。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;非阻塞I/O &lt;code&gt;NIO&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;数据从网卡到内核不阻塞，&lt;code&gt;read&lt;/code&gt;不到数据直接返回，但是从内核到用户空间会阻塞 (用户轮询&lt;code&gt;read&lt;/code&gt;)&lt;/td&gt;
          &lt;td&gt;自己动手烧水，隔两分钟看一下，水烧开没有。等水烧开了，倒在杯子里喝。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;I/O多路复用&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;只有一个线程查看多个连接是否有数据准备就绪 (看从网卡能不能&lt;code&gt;read&lt;/code&gt;到数据到内核)&lt;/td&gt;
          &lt;td&gt;找专门烧水的领居帮忙，他把水烧好了之后，会喊你来拿。但是你要自己倒在杯子里喝。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;信号驱动I/O&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;数据从网卡到内核之后会自动通知用户程序，然后让他&lt;code&gt;read&lt;/code&gt;读取数据&lt;/td&gt;
          &lt;td&gt;去烧水房烧水，全自动的，有个通知灯。水烧完了之后会按你家的门铃，但是有客人来了，也会按门铃&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;异步I/O &lt;code&gt;AIO&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;全程不阻塞，拷贝到用户空间之后直接回调。&lt;/td&gt;
          &lt;td&gt;和多路复用类似，但是烧完水之后不用自己倒水，他帮你倒好了，还吹凉了，你过来喝就行。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img alt=&#34;IO五种模型&#34; loading=&#34;lazy&#34; src=&#34;https://oss.swimmingliu.cn/3bbe065d-f63f-11ef-a797-c858c0c1deba&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【为什么会产生各种I/O】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下图是两个不同主机上，应用程序传递数据的过程，借助该过程来理解 &lt;code&gt;I/O&lt;/code&gt; 是如何产生的&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;DMA（直接内存访问）是一种不经过CPU直接在网络适配器（网卡）和主机内存之间进行数据传输的机制，用于提升数据传输效率。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt=&#34;两个主机的应用程序是如何通信的&#34; loading=&#34;lazy&#34; src=&#34;https://oss.swimmingliu.cn/c3fa5783-0332-11f0-9b6e-c858c0c1debd&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【同步阻塞 I/O &lt;code&gt;BIO&lt;/code&gt;】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同步阻塞I/O &lt;code&gt;BIO&lt;/code&gt; 的工作机制：应用程序被阻塞，直到数据复制到应用进程的缓冲区才返回。阻塞并意味着整个操作系统都被阻塞。其他程序还可以执行，不消耗CPU事件。同步阻塞 I/O &lt;code&gt;BIO&lt;/code&gt; 中，应用程序发起 &lt;code&gt;read&lt;/code&gt; 调用来读取数据之后，一直被阻塞，直到内核把数据copy到用户空间。该方案适合客户端连接数量不高的情况。下图的&lt;code&gt;read&lt;/code&gt; 和 &lt;code&gt;recvfrom&lt;/code&gt; 函数是一个意思。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;同步阻塞IO结构图&#34; loading=&#34;lazy&#34; src=&#34;https://oss.swimmingliu.cn/c5e8e28c-0332-11f0-bf73-c858c0c1debd&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【非阻塞式  I/O &lt;code&gt;NIO&lt;/code&gt;】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;非阻塞式  I/O &lt;code&gt;NIO&lt;/code&gt; 的工作机制：应用程序执行&lt;code&gt;read&lt;/code&gt; 系统调用之后，内核返回一个错误码。应用程序可以继续执行，但是需要不断的轮询 &lt;code&gt;read&lt;/code&gt; 来获取 I/O是否完成，这种方式称之为 &lt;strong&gt;轮询 &lt;code&gt;polling&lt;/code&gt;&lt;/strong&gt; 。等到数据准备就绪，从内核空间copy到用户空间的时候，进程才被阻塞，直到内核copy完成。该方案比较低效，会不停的消耗CPU资源。&lt;/p&gt;</description>
    </item>
    <item>
      <title>个人简历常问问题</title>
      <link>https://swimmingliu.cn/posts/job/personal-interview-hot-question/</link>
      <pubDate>Thu, 27 Feb 2025 10:52:54 +0800</pubDate>
      <guid>https://swimmingliu.cn/posts/job/personal-interview-hot-question/</guid>
      <description>&lt;p&gt;个人简历详情查看 -&amp;gt; &lt;a href=&#34;https://rxresu.me/dashboard/resumes&#34;&gt;个人简历页&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-异步秒杀机制的异步是如何实现的&#34;&gt;1. 异步秒杀机制的异步是如何实现的?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;【正常秒杀的顺序】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查询优惠券 -&amp;gt; 判断秒杀库存 -&amp;gt; 查询订单 -&amp;gt; 校验是否一人一单 -&amp;gt; 扣减库存 -&amp;gt; 创建订单&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【异步秒杀】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了实现用户异步下单，其实就是把是否能够下单的判断逻辑和下单的操作拆分开。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;采用Redis来判断是否有足够的库存和校验一人一单
&lt;ul&gt;
&lt;li&gt;如果满足条件，把用户、订单id、商品id保存到阻塞队列，直接给用户返回秒杀成功。&lt;/li&gt;
&lt;li&gt;如果不满足条件，直接返回秒杀失败。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;后台线程会去执行queue里边的消息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样就可以实现异步的秒杀下单了，那么如果实现判断秒杀库存和校验一人一单呢？&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;1653561657295&#34; loading=&#34;lazy&#34; src=&#34;https://oss.swimmingliu.cn/8f260a35-f4b5-11ef-a915-c858c0c1deba&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【秒杀库存 + 一人一单】&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户下单之后，判断redis当中的库存key的value是否大于&lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;value &amp;gt; 0&lt;/code&gt; -&amp;gt; 第2步&lt;/li&gt;
&lt;li&gt;&lt;code&gt;value &amp;lt;= 0&lt;/code&gt; -&amp;gt; 直接返回库存不足 （返回&lt;code&gt;1&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果库存充足，判断redis当中的秒杀商品key的 &lt;code&gt;set&lt;/code&gt; 集合是否已包含&lt;code&gt;userid&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;包含&lt;code&gt;userid&lt;/code&gt;， 说明用户已经下单了，直接返回当前用户已下单 (返回&lt;code&gt;2&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;不包含 &lt;code&gt;userid&lt;/code&gt; -&amp;gt; 第3步&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果用户没有下单，将用户的 &lt;code&gt;userid&lt;/code&gt; 存入 &lt;code&gt;set&lt;/code&gt; 里面 (返回&lt;code&gt;0&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;【注意】&lt;/strong&gt; 整个操作是原子性的，这样就确保了不会出现&lt;strong&gt;超卖现象和一人多单现象&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;-- 1.参数列表&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;-- 1.1.秒杀商品id&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;local&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;voucherId&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ARGV&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;-- 1.2.用户id&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;local&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;userId&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ARGV&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;-- 1.3.订单id&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;local&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;orderId&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ARGV&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;-- 2.数据key&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;-- 2.1.库存key&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;local&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stockKey&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;seckill:stock:&amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;..&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;voucherId&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;-- 2.2.秒杀商品订单key&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;local&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;orderKey&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;seckill:order:&amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;..&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;voucherId&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;-- 3.脚本业务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;-- 3.1.判断库存是否充足 get stockKey&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kr&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tonumber&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redis.call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;get&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stockKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;-- 3.2.库存不足，返回1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kr&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kr&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;-- 3.2.判断用户是否下单 SISMEMBER orderKey userId&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kr&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redis.call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;sismember&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;orderKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;userId&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;-- 3.3.存在，说明是重复下单，返回2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kr&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kr&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kr&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;【阻塞队列实现下单】&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Redis面试题笔记</title>
      <link>https://swimmingliu.cn/posts/job/redis-interview-questions/</link>
      <pubDate>Thu, 20 Feb 2025 21:21:45 +0800</pubDate>
      <guid>https://swimmingliu.cn/posts/job/redis-interview-questions/</guid>
      <description>&lt;h2 id=&#34;1-redis主从复制的原理&#34;&gt;1. Redis主从复制的原理&lt;/h2&gt;
&lt;p&gt;【&lt;strong&gt;主从复制的原理&lt;/strong&gt;】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同步：从节点向主节点发送&lt;code&gt;psync&lt;/code&gt;命令进行同步，从节点保存主节点返回的 &lt;code&gt;runid&lt;/code&gt; 和 &lt;code&gt; offset&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;全量复制：如果是第一次连接或者连接失败且&lt;code&gt;repl_backlog_buffer&lt;/code&gt; 缓存区不包含&lt;code&gt;slave_repl_offset&lt;/code&gt;， 则生成主节点的数据快照(RDB文件)发给从节点&lt;/li&gt;
&lt;li&gt;增量复制：全量复制完毕后，主从节点之间会保持长连接。如果连接没有断开或者&lt;code&gt;slave_repl_offset&lt;/code&gt;仍然在&lt;code&gt;repl_backlog_buffer&lt;/code&gt;中，则将后续的写操作传递给从节点，让数据保持一致。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;【全量复制细节】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;全量复制的过程是基于TCP长连接的，主要流程如下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从节点发送&lt;code&gt;psync ? -1&lt;/code&gt;表示需要建立连接进行同步，主节点返回主节点ID &lt;code&gt;runid&lt;/code&gt; 和 复制进度&lt;code&gt;offset&lt;/code&gt; (第一次同步用 -1 表示)。从节点接受之后，保存主节点的信息。&lt;/li&gt;
&lt;li&gt;主节点执行&lt;code&gt;bgsave&lt;/code&gt;命令生成数据快照RDB文件，然后将RDB文件发送给从节点。从节点接受文件后，清除现有的所有数据，然后加载RDB文件&lt;/li&gt;
&lt;li&gt;如果在制作数据快照RDB文件的过程当中，主节点接收到了新的写操作，主节点会将其记录在&lt;code&gt;repl buffer&lt;/code&gt; 里面。然后将&lt;code&gt;repl buffer&lt;/code&gt;当中的写操作发给从节点，让其数据保持一致。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt=&#34;Redis主从全量复制&#34; loading=&#34;lazy&#34; src=&#34;https://oss.swimmingliu.cn/ac630d4c-ef8d-11ef-a882-c858c0c1deba&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【增量复制细节】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果主从节点意外断开连接，为了保持数据的一致性，必须重新同步数据。如果使用全量复制来保持一致性的话，开销太大，所以采用增量复制。&lt;/p&gt;
&lt;p&gt;增量复制的具体流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;连接恢复后，从节点会发送&lt;code&gt;psync {runid} {offset}&lt;/code&gt;， 其中主节点ID &lt;code&gt;runid&lt;/code&gt; 和 复制进度&lt;code&gt;offset&lt;/code&gt;用于标识是哪一个服务器主机和复制进度。&lt;/li&gt;
&lt;li&gt;主节点收到&lt;code&gt;psync&lt;/code&gt; 命令之后，会用&lt;code&gt;conitnue&lt;/code&gt;响应告知从节点，采用增量复制同步数据&lt;/li&gt;
&lt;li&gt;最后，主节点根据&lt;code&gt;offset&lt;/code&gt;查找对应的进度，将断线期间未同步的写命令，发送给从节点。同时，主节点将所有的写命令写入&lt;code&gt;repl_backlog_buffer&lt;/code&gt;， 用于后续判断是采用增量复制还是全量复制。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;【注意】从节点 &lt;code&gt;psync&lt;/code&gt; 携带的 &lt;code&gt;offset&lt;/code&gt; 为 &lt;code&gt;slave_repl_offset&lt;/code&gt;。如果 &lt;code&gt;repl_backlog_buffer&lt;/code&gt;包含&lt;code&gt;slave_repl_offset&lt;/code&gt; 对应的部分，则采用增量复制，否则采用全量复制。&lt;code&gt;repl_backlog_buffer&lt;/code&gt;的默认缓冲区大小为&lt;code&gt;1M&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;Redis主从增量复制&#34; loading=&#34;lazy&#34; src=&#34;https://oss.swimmingliu.cn/ac9f21a3-ef8d-11ef-9016-c858c0c1deba&#34;&gt;&lt;/p&gt;
&lt;p&gt;【&lt;strong&gt;为什么要主从复制&lt;/strong&gt;】&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;备份数据&lt;/strong&gt;：主从复制实现了数据的热备份，是持久化之外的数据冗余方式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;故障恢复&lt;/strong&gt;：当主节点宕机之后，可以采用从节点提供服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;:  主从复制实现了读写分离，只有主节点支持读写操作，从节点只有读操作。在读多写少的场景下，可以提高Redis服务器的并发量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;Redis主从读写分离&#34; loading=&#34;lazy&#34; src=&#34;https://oss.swimmingliu.cn/acad0d12-ef8d-11ef-b17f-c858c0c1deba&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-redis集群的实现原理是什么&#34;&gt;2. Redis集群的实现原理是什么?&lt;/h2&gt;
&lt;p&gt;【&lt;strong&gt;Redis集群基本知识&lt;/strong&gt;】&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;: Redis集群由多个实例组成，每个实例存储部分数据 (每个实例之间的数据不重复) 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;【注】集群和主从节点不是一个东西，集群的某一个实例当中可能包含一个主节点 + 多个从节点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;为什么用&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;问题&lt;/th&gt;
          &lt;th&gt;解决方案&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;容量不足&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;数据分片，将数据分散不存到不同的主节点&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;高并发写入&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;数据分片，将写入请求分摊到多个主节点&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;主机宕机问题&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;自动切换主从节点，避免影响服务， 不需要手动修改客户端配置&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;节点通信协议&lt;/strong&gt;：Redis集群采用Gossip协议, 支持分布式信息传播、延迟低、效率高。采用去中心化思想，任意实例(主节点)都可以作为请求入口，节点间相互通信。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分片原理&lt;/strong&gt;： 采用哈希槽(Hash Slot)机制来分配数据，整个空间可以划分为&lt;strong&gt;16384&lt;/strong&gt; (16 * 1024)个槽。 每个Redis负责一定范围的哈希槽,数据的key经过哈希函数计算之后对&lt;strong&gt;16384&lt;/strong&gt;取余可定位到对应的节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;Redis集群架构图&#34; loading=&#34;lazy&#34; src=&#34;https://oss.swimmingliu.cn/acc54635-ef8d-11ef-971e-c858c0c1deba&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java集合面试题笔记</title>
      <link>https://swimmingliu.cn/posts/job/java-set-interview-questions/</link>
      <pubDate>Thu, 20 Feb 2025 21:20:50 +0800</pubDate>
      <guid>https://swimmingliu.cn/posts/job/java-set-interview-questions/</guid>
      <description>&lt;h2 id=&#34;1-说说-java-中-hashmap-的原理&#34;&gt;1. 说说 Java 中 HashMap 的原理？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;【HashMap定义】&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;结构：数组 + 链表 + 红黑树 (&lt;code&gt;JDK 1.8&lt;/code&gt; 之后)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;默认值：初始容量为16 (数组长度)，负载因子为 0.75。当存储的元素为 16 * 0.75 = 12个时，会触发&lt;code&gt;Resize()&lt;/code&gt; 扩容操作，容量 x 2 并重新分配位置。但是扩容是有一定开销的，频繁扩容会影响性能。另外，&lt;code&gt;TREEIFY_THRESHOLD&lt;/code&gt; 转换为红黑树的默认链表长度阈值为 8, &lt;code&gt;UNTREEIFY_THRESHOLD&lt;/code&gt; 从红黑树转换为链表的阈值为 6。 两个阈值采用不同值的原因是防止刚转换为红黑树，又变成链表，反复横跳，消耗资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数组下标位置计算方法：首先使用key的&lt;code&gt;hashCode()&lt;/code&gt;方法计算下标位置，然后通过  &lt;code&gt;indexFor()&lt;/code&gt; (&lt;code&gt;JDK 1.7&lt;/code&gt; 以前) 计算下标值。 &lt;code&gt;JDK 1.7&lt;/code&gt;后，为了提高计算效率采用 &lt;code&gt;(len - 1) &amp;amp; hash&lt;/code&gt; 来确定下标值。&lt;/p&gt;
&lt;p&gt;【注】数组的长度&lt;code&gt;len&lt;/code&gt; 是2的幂次方时，&lt;code&gt;(len - 1) &amp;amp; hash&lt;/code&gt; 等价于 &lt;code&gt;hash % len&lt;/code&gt;。 这也是为什么数组长度必须是2的幂次方。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;HashMap底层结构&#34; loading=&#34;lazy&#34; src=&#34;https://oss.swimmingliu.cn/65f25922-ef8d-11ef-827a-c858c0c1deba&#34;&gt;&lt;/p&gt;
&lt;p&gt;【&lt;strong&gt;HashMap线程不安全&lt;/strong&gt;】&lt;/p&gt;
&lt;p&gt;为了保证HashMap的读写效率高，它的操作是非同步的，也就是说读写操作没有锁保护。所以多线程场景下是线程不安全的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【HashMap不同版本区别】&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JDK 1.7: 数组 + 链表，链表部分采用头插法，多线程会导致出现环形链表。扩容会计算每个元素hash值，并分配到新的位置，开销大。&lt;/li&gt;
&lt;li&gt;JDK 1.8：数组 + 链表 + 红黑树，采用高低位置来分配位置，即判断&lt;code&gt;(e.hash &amp;amp; oldCap) == 0&lt;/code&gt;， 减少了计算hash的次数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;【HashMap的PUT方法】&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java基础题面试笔记</title>
      <link>https://swimmingliu.cn/posts/job/java-basic-interview-questions/</link>
      <pubDate>Wed, 19 Feb 2025 15:18:58 +0800</pubDate>
      <guid>https://swimmingliu.cn/posts/job/java-basic-interview-questions/</guid>
      <description>&lt;h2 id=&#34;1-序列化和反序列化&#34;&gt;1. 序列化和反序列化&lt;/h2&gt;
&lt;p&gt;1.序列化和反序列化：把对象转换为字节流，用于存储和传输；读取字节流数据，重新创建对象。
2.序列化不包括静态对象：序列化和反序列化的本质是调用对象的&lt;code&gt;writeObject&lt;/code&gt;和&lt;code&gt;readObject&lt;/code&gt;方法,来实现将对象写入输出流和读取输入流。但是，静态变量不属于对象，所以调用这两个方法就没法儿让静态变量参与。&lt;/p&gt;
&lt;h2 id=&#34;2-什么是不可变类&#34;&gt;2. 什么是不可变类？&lt;/h2&gt;
&lt;p&gt;1.不可变类：初始化之后，就不能修改的类。
2.修饰方法：final 和 private 修饰所有类和变量
3.不可修改：不暴露set方法，只能通过重新创建对象替代修改功能(&lt;code&gt;String&lt;/code&gt;的replace方法)
4.优缺点：
优点：线程安全，缓存友好
缺点：频繁拼接和修改会浪费资源&lt;/p&gt;
&lt;h2 id=&#34;3-exception和error区别&#34;&gt;3. Exception和Error区别?&lt;/h2&gt;
&lt;p&gt;1.Exception和Error定义区别：Exception是可处理程序异常，Error是系统级不可回复错误
2.try-catch建议：
1.范围能小则小
2.Exception最好要写清楚具体是哪一个Exception(IOException)
3.null值等能用if判断的，不要用try-catch,因为异常比条件语句低效
4.finally不要直接return和处理返回值&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;Exception和Error区别&#34; loading=&#34;lazy&#34; src=&#34;https://oss.swimmingliu.cn/946b73cc-ef5d-11ef-95ab-c858c0c1deba&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-java-中的-hashcode-和-equals-方法之间有什么关系&#34;&gt;4. Java 中的 hashCode 和 equals 方法之间有什么关系？&lt;/h2&gt;
&lt;p&gt;1、&lt;code&gt;equals()&lt;/code&gt; 和 &lt;code&gt;hashCode()&lt;/code&gt; 的关系&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果两个对象&lt;code&gt;euqals()&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt;， 则其 &lt;code&gt;hashCode()&lt;/code&gt;一定相同&lt;/li&gt;
&lt;li&gt;如果两个对象&lt;code&gt;hashCode()&lt;/code&gt; 相同，其&lt;code&gt;equals()&lt;/code&gt;结果不一定为&lt;code&gt;true&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、为什么重写&lt;code&gt;equals()&lt;/code&gt;之后，一定要重写&lt;code&gt;hashCode()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当重写&lt;code&gt;equals()&lt;/code&gt; 之后，通常是重新定义了两个对象相等的逻辑。如果不重写&lt;code&gt;hashCode()&lt;/code&gt;方法， 则在散列集合（&lt;code&gt;HashMap&lt;/code&gt; 和 &lt;code&gt;HashSet&lt;/code&gt;）中，可能无法正确存储和检索，因为两个相同的对象可能有不同的&lt;code&gt;hash&lt;/code&gt;值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例如，下方Person类重写了&lt;code&gt;equals()&lt;/code&gt; 方法，但是没有重新&lt;code&gt;hashCode()&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Java&#34; data-lang=&#34;Java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;age&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;equals&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;||&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getClass&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getClass&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;person&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;age&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;age&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Objects&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equals&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;创建相同的对象，并添加到&lt;code&gt;HashSet&lt;/code&gt;中&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL面试题笔记</title>
      <link>https://swimmingliu.cn/posts/job/mysql-interview-questions/</link>
      <pubDate>Wed, 19 Feb 2025 15:16:42 +0800</pubDate>
      <guid>https://swimmingliu.cn/posts/job/mysql-interview-questions/</guid>
      <description>&lt;h2 id=&#34;1mysql-中的数据排序是怎么实现的&#34;&gt;1.MySQL 中的数据排序是怎么实现的？&lt;/h2&gt;
&lt;p&gt;1.&lt;strong&gt;排序方法&lt;/strong&gt;：索引排序和文件排序 (filesort)&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;索引排序&lt;/strong&gt;：如果&lt;code&gt;order by xxx&lt;/code&gt;的字段为索引字段，则利用索引进行排序。效率最高，索引默认有序。&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;文件排序 (filesort)&lt;/strong&gt;：内存排序(单路排序和双路排序)和磁盘排序，具体取决于排序数据的大小。其中，内存排序使用单路排序或双路排序，取决于&lt;code&gt;max_length_for_sort_data&lt;/code&gt;(默认为4096个字节)&lt;/p&gt;
&lt;p&gt;4.&lt;strong&gt;双路排序&lt;/strong&gt;：取&lt;code&gt;row_id&lt;/code&gt;(如果有主键，则为主键)和&lt;code&gt;select a,b,c order by xxx&lt;/code&gt;的&lt;code&gt;xxx&lt;/code&gt;字段放入&lt;code&gt;sort_buffer&lt;/code&gt;(排序缓存)中，将排序后的&lt;code&gt;row_id&lt;/code&gt;回表查询&lt;code&gt;a,b,c&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;5.&lt;strong&gt;单路排序&lt;/strong&gt;: 直接把要查的所有字段放入&lt;code&gt;sort_buffer&lt;/code&gt;里，排序后直接得到结果集合&lt;/p&gt;
&lt;p&gt;6.&lt;strong&gt;磁盘排序&lt;/strong&gt;（归并排序）:将数据分为多份文件，单独对文件进行排序，然后合并成一个有序的大文件&lt;/p&gt;
&lt;h2 id=&#34;2-mysql-的-change-buffer-是什么它有什么作用&#34;&gt;2. MySQL 的 Change Buffer 是什么？它有什么作用？&lt;/h2&gt;
&lt;p&gt;1.ChangeBuffer定义：Change Buffer是InnoDB缓冲当中的一块缓存区，用于暂存二级索引的修改，避免二级索引页修改产生的随机IO
2.ChangeBuffer注意事项：只能用于二级索引，不能用于其他任何索引，包括主键索引和唯一索引都不行。
3.如果ChangeBuffer挂了，更改操作未执行，是否会出现脏数据？
首先，ChangeBuffer也会保存在磁盘空间里面，redo log会记录Change Buffer当中的修改操作，确保数据一致性。&lt;/p&gt;
&lt;p&gt;知识拓展1：一级索引和二级索引区别&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;一级索引（聚簇索引）&lt;/strong&gt;：数据表的主键索引，数据和索引存储在同一B+树的叶子节点中。每个表只能有一个一级索引。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二级索引（非聚簇索引）&lt;/strong&gt;：除主键外的其他索引，叶子节点存储索引列的值和对应的主键值。通过二级索引查询时，需要先通过二级索引获取主键值，再通过主键值查询数据，这个过程称为“回表”。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;知识拓展2:  MySQL中有哪些常见索引？都有什么区别？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在MySQL中，索引是提高查询效率的关键工具。常见的索引类型包括主键索引、唯一索引、普通索引、全文索引和空间索引。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 主键索引（Primary Key Index）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：主键索引是一种特殊的唯一索引，用于唯一标识表中的每一行数据。每个表只能有一个主键索引，且主键列的值不能为空。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：主键索引的叶子节点存储完整的数据行，因此查询效率高。在InnoDB存储引擎中，主键索引是聚簇索引，数据存储与索引结构合并。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. 唯一索引（Unique Index）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：唯一索引确保索引列的每个值都是唯一的，但允许有空值。与主键索引类似，不同之处在于唯一索引允许列值为NULL。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：唯一索引的叶子节点存储索引列的值和对应的主键值。在InnoDB中，唯一索引是非聚簇索引，数据存储与索引结构分开。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3. 普通索引（Index）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：普通索引是最基本的索引类型，没有任何限制。索引列的值可以重复，也可以为NULL。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：普通索引的叶子节点存储索引列的值和对应的主键值。在InnoDB中，普通索引是非聚簇索引，数据存储与索引结构分开。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4. 全文索引（Fulltext Index）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：全文索引用于对文本数据进行全文搜索，适用于MyISAM存储引擎。它允许对文本字段进行复杂的搜索，如查找包含特定单词的记录。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：全文索引的叶子节点存储文档的词项信息。在MyISAM中，全文索引是非聚簇索引，数据存储与索引结构分开。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;5. 空间索引（Spatial Index）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：空间索引用于对地理空间数据进行索引，支持空间数据类型的快速查询。它适用于存储地理位置、地图等空间数据的表。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：空间索引的叶子节点存储空间数据的索引信息。在MyISAM中，空间索引是非聚簇索引，数据存储与索引结构分开。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主键索引&lt;/strong&gt;：用于唯一标识每一行数据，值不能为空。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;唯一索引&lt;/strong&gt;：确保索引列的值唯一，但允许有空值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;普通索引&lt;/strong&gt;：最基本的索引类型，允许重复和空值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;全文索引&lt;/strong&gt;：用于对文本数据进行全文搜索，适用于MyISAM存储引擎。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空间索引&lt;/strong&gt;：用于对地理空间数据进行索引，支持空间数据类型的快速查询。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;3-详细描述一条-sql-语句在-mysql-中的执行过程&#34;&gt;3. 详细描述一条 SQL 语句在 MySQL 中的执行过程。&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;连接器判断用户是否成功建立连接，数据库连接的权限校验&lt;/li&gt;
&lt;li&gt;连接器会查询缓存，&lt;code&gt;key&lt;/code&gt; 是 SQL 语句，&lt;code&gt;value&lt;/code&gt; 是查询结果。如果命中，直接返回查询结果。(MySQL 8.0之后，就移除这个功能了)。&lt;/li&gt;
&lt;li&gt;分析器分析SQL语法和词法是否有误&lt;/li&gt;
&lt;li&gt;优化器生成SQL的执行计划，确定使用的索引和调整where的执行顺序（包括连表顺序）&lt;/li&gt;
&lt;li&gt;执行器判断当前用户是否有权限查询该表，然后执行该SQL语句&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt=&#34;MySQL架构图&#34; loading=&#34;lazy&#34; src=&#34;https://oss.swimmingliu.cn/7457976c-ef5d-11ef-b738-c858c0c1deba&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java面试题-随手记</title>
      <link>https://swimmingliu.cn/posts/job/java-interview-questions-notes/</link>
      <pubDate>Fri, 27 Dec 2024 17:27:35 +0800</pubDate>
      <guid>https://swimmingliu.cn/posts/job/java-interview-questions-notes/</guid>
      <description>&lt;h2 id=&#34;-和-equals-区别&#34;&gt;== 和 equals 区别&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;==&lt;/code&gt; 基本类型(int, long, float, char, boolean) 值比较， 引用类型(String，List) 进行地址比较&lt;/p&gt;
&lt;p&gt;&lt;code&gt;equals&lt;/code&gt; 默认就是 &lt;code&gt;==&lt;/code&gt; ，但是部分引用类型(String，List)重写了该方法，进行值比较&lt;/p&gt;
&lt;h2 id=&#34;get-和-post-区别&#34;&gt;get 和 post 区别&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;特性&lt;/th&gt;
          &lt;th&gt;GET&lt;/th&gt;
          &lt;th&gt;POST&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;目的&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;获取资源，查询数据&lt;/td&gt;
          &lt;td&gt;提交数据，创建或更新资源&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;请求数据方式&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;参数通过 URL 查询字符串传递&lt;/td&gt;
          &lt;td&gt;数据通过请求体传递&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;数据暴露&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;数据暴露在 URL 中，较不安全&lt;/td&gt;
          &lt;td&gt;数据存储在请求体中，相对安全&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;数据大小限制&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;URL 长度有限制（约 2048 个字符）&lt;/td&gt;
          &lt;td&gt;没有数据大小限制&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;适用场景&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;获取数据，查询，展示资源&lt;/td&gt;
          &lt;td&gt;提交表单，上传文件，修改资源，发送敏感数据等&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;springmvc中reponsebodypathvariablerequestparameters在什么情况下使用&#34;&gt;SpringMVC中@ReponseBody、@PathVariable、@RequestParameters在什么情况下使用?&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;@ReponseBody&lt;/code&gt; 用于接受请求体数据，一般用于POST请求&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@PathVariable&lt;/code&gt; 用于接受路径参数，一般用户接受 &lt;code&gt;id&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@RequestParameters&lt;/code&gt; 用于接受请求参数，一般用于GET请求&lt;/p&gt;
&lt;h2 id=&#34;jvm堆的结构gc介绍和作用&#34;&gt;JVM堆的结构、GC介绍和作用&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.51cto.com/article/710705.html&#34;&gt;JVM堆结构的参考文章&lt;/a&gt; 、 &lt;a href=&#34;https://www.bilibili.com/video/BV1dt411u7wi&#34;&gt;GC垃圾回收过程&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;区域&lt;/th&gt;
          &lt;th&gt;主要用途&lt;/th&gt;
          &lt;th&gt;特点&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;新生代（Young Generation）&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;存储新创建的对象，快速垃圾回收&lt;/td&gt;
          &lt;td&gt;包含 Eden 区和两个 Survivor 区，采用复制算法进行回收&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;老年代（Old Generation）&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;存储长期存活的对象&lt;/td&gt;
          &lt;td&gt;回收频率较低，垃圾回收较耗时&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;永久代（Permanent Generation) (jdk 1.7）&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;存储类的元数据、方法字节码等&lt;/td&gt;
          &lt;td&gt;在 jdk 1.8 被 Metaspace 替代&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;元空间（jdk 1.8）&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;存储类的元数据&lt;/td&gt;
          &lt;td&gt;不再属于堆，使用本地内存，大小由系统限制&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;GC&lt;/code&gt; 是垃圾回收器， 作用是自动内存管理和避免内存泄漏&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
