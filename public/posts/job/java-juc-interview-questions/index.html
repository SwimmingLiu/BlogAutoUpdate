<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>(JUC) Java并发面试题笔记 | SwimmingLiu&#39;s Blog</title>
<meta name="keywords" content="Java, JUC">
<meta name="description" content="(JUC) Java并发面试题笔记
1. 什么是 Java 内存模型（JMM）？
JMM 是 Java内存模型 ， 它是Java虚拟机 JVM 定义的一种规范，用于描述多线程程序中的变量，像实例字段、静态字段和数组元素，他们如何在内存中存储和传递的规则。也就是规定线程啥时候从住内存里面读数据，啥时候把数据写回到住内存。JMM 的核心目标是确保多线程环境下的可见性、有序性和原子性, 避免硬件和编译器优化带来的不一致问题。
【可见性、有序性、原子性定义】

可见性：确保一个线程对共享变量的修改，能够及时被另外一个线程看到。 volatile就是用来保证可见性的，强制线程每次读写的时候，直接从主内存当中获取最新值。
有序性：指线程执行操作的顺序。JMM允许某些指令重排序之后再提高性能，但会保证线程内的操作顺序不会被破坏。通过happens-before (线程A发生在线程B之前)的关系来保证跨线程的有序性。
原子性：操作不可分割，线程不会在执行的过程当中被打断。例如, synchronize 关键字能确保方法或代码块的原子性

【JMM作用】
因为不同的操作系统都有一套独立的内存模型，但是Java为了满足跨平台的特性，它需要定义一套内存模型屏蔽个操作系统之间的差异。我们可以利用JMM当中定义好的从Java源码到CPU指令的执行规范，也就是使用synchronized 、volatile 等关键字，还有happens-before原则，就可以写出并发安全的代码了。
比如说，线程A和线程B同时操作 变量-1，假如最开始变量-1 是 0

首先，线程A和线程B都读取了变量-1
然后，线程B对取到的变量-1自增为1，并写回主内存
此时，线程A对读取到的变量-1也自增1，并写回主内存。这就会导致线程B的操作失效了，出现并发安全问题。

如果有JMM，我们就可以在线程A要修改数据之前,让它采用CAS乐观锁的方式进行修改。再次去读主内存当中的值，然后修改之后，再判断一下主内存的值是否发生变化。如果没有发生变化，就写回主内存。如果发生变化，就要进行自旋。
【注意】 工作内存是每个线程独立的内存空间，其他线程都是看不到的。主内存是Java堆内存的一部分，所有的实例变量、静态变量和数组元素都存储在主内存当中。

【内存间交互操作类型 (8种原子操作)】

lock 上锁：把一个变量表示为一条线程独占的状态
unlock 解锁： 把一个变量从独占状态中释放出来，释放后的变量才能被其他线程锁定
read 读取： 从主内存当中读取一个变量到工作内存中
load 载入：把read操作从主内存中得到的变量值放入工作内存的变量副本当中
use 使用：把工作内存当中的一个变量值传递给执行引擎
assign 赋值：把一个从执行引擎接收到的值赋给工作内存中的变量
store 存储：把工作内存中的一个变量的值传送给主内存中
write 写入：把store操作从工作内存中得到的变量值放入主内存的变量中

【volatile 特殊规则】

可见性：对于 volatile 修饰的变量的写操作会立即刷新到内存中，任何线程对这个volatile 变量的读操作都能立即看到最新的值。
禁止指令重排序： 在对 volatile 变量进行读/写操作的时候，会插入内存屏障，禁止指令重排序。也就是该变量的写操作不能与之前的读/写操作重排序，它的都操作不能与之后的读/写操作重排序。

【Happens-Before 原则】">
<meta name="author" content="SwimmingLiu">
<link rel="canonical" href="https://swimmingliu.cn/posts/job/java-juc-interview-questions/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.6ecbb0040febd20e47edd88a662c19f1ea945bf7427774b86594271d18f88faf.css" integrity="sha256-bsuwBA/r0g5H7diKZiwZ8eqUW/dCd3S4ZZQnHRj4j68=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<link rel="apple-touch-icon" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<link rel="mask-icon" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://swimmingliu.cn/posts/job/java-juc-interview-questions/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ],
            
            throwOnError: false
        });
    });
</script>

<meta property="og:url" content="https://swimmingliu.cn/posts/job/java-juc-interview-questions/">
  <meta property="og:site_name" content="SwimmingLiu&#39;s Blog">
  <meta property="og:title" content="(JUC) Java并发面试题笔记">
  <meta property="og:description" content="(JUC) Java并发面试题笔记 1. 什么是 Java 内存模型（JMM）？ JMM 是 Java内存模型 ， 它是Java虚拟机 JVM 定义的一种规范，用于描述多线程程序中的变量，像实例字段、静态字段和数组元素，他们如何在内存中存储和传递的规则。也就是规定线程啥时候从住内存里面读数据，啥时候把数据写回到住内存。JMM 的核心目标是确保多线程环境下的可见性、有序性和原子性, 避免硬件和编译器优化带来的不一致问题。
【可见性、有序性、原子性定义】
可见性：确保一个线程对共享变量的修改，能够及时被另外一个线程看到。 volatile就是用来保证可见性的，强制线程每次读写的时候，直接从主内存当中获取最新值。 有序性：指线程执行操作的顺序。JMM允许某些指令重排序之后再提高性能，但会保证线程内的操作顺序不会被破坏。通过happens-before (线程A发生在线程B之前)的关系来保证跨线程的有序性。 原子性：操作不可分割，线程不会在执行的过程当中被打断。例如, synchronize 关键字能确保方法或代码块的原子性 【JMM作用】
因为不同的操作系统都有一套独立的内存模型，但是Java为了满足跨平台的特性，它需要定义一套内存模型屏蔽个操作系统之间的差异。我们可以利用JMM当中定义好的从Java源码到CPU指令的执行规范，也就是使用synchronized 、volatile 等关键字，还有happens-before原则，就可以写出并发安全的代码了。 比如说，线程A和线程B同时操作 变量-1，假如最开始变量-1 是 0
首先，线程A和线程B都读取了变量-1 然后，线程B对取到的变量-1自增为1，并写回主内存 此时，线程A对读取到的变量-1也自增1，并写回主内存。这就会导致线程B的操作失效了，出现并发安全问题。 如果有JMM，我们就可以在线程A要修改数据之前,让它采用CAS乐观锁的方式进行修改。再次去读主内存当中的值，然后修改之后，再判断一下主内存的值是否发生变化。如果没有发生变化，就写回主内存。如果发生变化，就要进行自旋。
【注意】 工作内存是每个线程独立的内存空间，其他线程都是看不到的。主内存是Java堆内存的一部分，所有的实例变量、静态变量和数组元素都存储在主内存当中。
【内存间交互操作类型 (8种原子操作)】
lock 上锁：把一个变量表示为一条线程独占的状态 unlock 解锁： 把一个变量从独占状态中释放出来，释放后的变量才能被其他线程锁定 read 读取： 从主内存当中读取一个变量到工作内存中 load 载入：把read操作从主内存中得到的变量值放入工作内存的变量副本当中 use 使用：把工作内存当中的一个变量值传递给执行引擎 assign 赋值：把一个从执行引擎接收到的值赋给工作内存中的变量 store 存储：把工作内存中的一个变量的值传送给主内存中 write 写入：把store操作从工作内存中得到的变量值放入主内存的变量中 【volatile 特殊规则】
可见性：对于 volatile 修饰的变量的写操作会立即刷新到内存中，任何线程对这个volatile 变量的读操作都能立即看到最新的值。 禁止指令重排序： 在对 volatile 变量进行读/写操作的时候，会插入内存屏障，禁止指令重排序。也就是该变量的写操作不能与之前的读/写操作重排序，它的都操作不能与之后的读/写操作重排序。 【Happens-Before 原则】">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-03-05T21:45:49+08:00">
    <meta property="article:modified_time" content="2025-03-05T21:45:49+08:00">
    <meta property="article:tag" content="Java">
    <meta property="article:tag" content="JUC">
      <meta property="og:image" content="https://swimmingliu.cn/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://swimmingliu.cn/papermod-cover.png">
<meta name="twitter:title" content="(JUC) Java并发面试题笔记">
<meta name="twitter:description" content="(JUC) Java并发面试题笔记
1. 什么是 Java 内存模型（JMM）？
JMM 是 Java内存模型 ， 它是Java虚拟机 JVM 定义的一种规范，用于描述多线程程序中的变量，像实例字段、静态字段和数组元素，他们如何在内存中存储和传递的规则。也就是规定线程啥时候从住内存里面读数据，啥时候把数据写回到住内存。JMM 的核心目标是确保多线程环境下的可见性、有序性和原子性, 避免硬件和编译器优化带来的不一致问题。
【可见性、有序性、原子性定义】

可见性：确保一个线程对共享变量的修改，能够及时被另外一个线程看到。 volatile就是用来保证可见性的，强制线程每次读写的时候，直接从主内存当中获取最新值。
有序性：指线程执行操作的顺序。JMM允许某些指令重排序之后再提高性能，但会保证线程内的操作顺序不会被破坏。通过happens-before (线程A发生在线程B之前)的关系来保证跨线程的有序性。
原子性：操作不可分割，线程不会在执行的过程当中被打断。例如, synchronize 关键字能确保方法或代码块的原子性

【JMM作用】
因为不同的操作系统都有一套独立的内存模型，但是Java为了满足跨平台的特性，它需要定义一套内存模型屏蔽个操作系统之间的差异。我们可以利用JMM当中定义好的从Java源码到CPU指令的执行规范，也就是使用synchronized 、volatile 等关键字，还有happens-before原则，就可以写出并发安全的代码了。
比如说，线程A和线程B同时操作 变量-1，假如最开始变量-1 是 0

首先，线程A和线程B都读取了变量-1
然后，线程B对取到的变量-1自增为1，并写回主内存
此时，线程A对读取到的变量-1也自增1，并写回主内存。这就会导致线程B的操作失效了，出现并发安全问题。

如果有JMM，我们就可以在线程A要修改数据之前,让它采用CAS乐观锁的方式进行修改。再次去读主内存当中的值，然后修改之后，再判断一下主内存的值是否发生变化。如果没有发生变化，就写回主内存。如果发生变化，就要进行自旋。
【注意】 工作内存是每个线程独立的内存空间，其他线程都是看不到的。主内存是Java堆内存的一部分，所有的实例变量、静态变量和数组元素都存储在主内存当中。

【内存间交互操作类型 (8种原子操作)】

lock 上锁：把一个变量表示为一条线程独占的状态
unlock 解锁： 把一个变量从独占状态中释放出来，释放后的变量才能被其他线程锁定
read 读取： 从主内存当中读取一个变量到工作内存中
load 载入：把read操作从主内存中得到的变量值放入工作内存的变量副本当中
use 使用：把工作内存当中的一个变量值传递给执行引擎
assign 赋值：把一个从执行引擎接收到的值赋给工作内存中的变量
store 存储：把工作内存中的一个变量的值传送给主内存中
write 写入：把store操作从工作内存中得到的变量值放入主内存的变量中

【volatile 特殊规则】

可见性：对于 volatile 修饰的变量的写操作会立即刷新到内存中，任何线程对这个volatile 变量的读操作都能立即看到最新的值。
禁止指令重排序： 在对 volatile 变量进行读/写操作的时候，会插入内存屏障，禁止指令重排序。也就是该变量的写操作不能与之前的读/写操作重排序，它的都操作不能与之后的读/写操作重排序。

【Happens-Before 原则】">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚 Posts",
      "item": "https://swimmingliu.cn/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "💻 Job",
      "item": "https://swimmingliu.cn/posts/job/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "(JUC) Java并发面试题笔记",
      "item": "https://swimmingliu.cn/posts/job/java-juc-interview-questions/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "(JUC) Java并发面试题笔记",
  "name": "(JUC) Java并发面试题笔记",
  "description": "(JUC) Java并发面试题笔记 1. 什么是 Java 内存模型（JMM）？ JMM 是 Java内存模型 ， 它是Java虚拟机 JVM 定义的一种规范，用于描述多线程程序中的变量，像实例字段、静态字段和数组元素，他们如何在内存中存储和传递的规则。也就是规定线程啥时候从住内存里面读数据，啥时候把数据写回到住内存。JMM 的核心目标是确保多线程环境下的可见性、有序性和原子性, 避免硬件和编译器优化带来的不一致问题。\n【可见性、有序性、原子性定义】\n可见性：确保一个线程对共享变量的修改，能够及时被另外一个线程看到。 volatile就是用来保证可见性的，强制线程每次读写的时候，直接从主内存当中获取最新值。 有序性：指线程执行操作的顺序。JMM允许某些指令重排序之后再提高性能，但会保证线程内的操作顺序不会被破坏。通过happens-before (线程A发生在线程B之前)的关系来保证跨线程的有序性。 原子性：操作不可分割，线程不会在执行的过程当中被打断。例如, synchronize 关键字能确保方法或代码块的原子性 【JMM作用】\n因为不同的操作系统都有一套独立的内存模型，但是Java为了满足跨平台的特性，它需要定义一套内存模型屏蔽个操作系统之间的差异。我们可以利用JMM当中定义好的从Java源码到CPU指令的执行规范，也就是使用synchronized 、volatile 等关键字，还有happens-before原则，就可以写出并发安全的代码了。 比如说，线程A和线程B同时操作 变量-1，假如最开始变量-1 是 0\n首先，线程A和线程B都读取了变量-1 然后，线程B对取到的变量-1自增为1，并写回主内存 此时，线程A对读取到的变量-1也自增1，并写回主内存。这就会导致线程B的操作失效了，出现并发安全问题。 如果有JMM，我们就可以在线程A要修改数据之前,让它采用CAS乐观锁的方式进行修改。再次去读主内存当中的值，然后修改之后，再判断一下主内存的值是否发生变化。如果没有发生变化，就写回主内存。如果发生变化，就要进行自旋。\n【注意】 工作内存是每个线程独立的内存空间，其他线程都是看不到的。主内存是Java堆内存的一部分，所有的实例变量、静态变量和数组元素都存储在主内存当中。\n【内存间交互操作类型 (8种原子操作)】\nlock 上锁：把一个变量表示为一条线程独占的状态 unlock 解锁： 把一个变量从独占状态中释放出来，释放后的变量才能被其他线程锁定 read 读取： 从主内存当中读取一个变量到工作内存中 load 载入：把read操作从主内存中得到的变量值放入工作内存的变量副本当中 use 使用：把工作内存当中的一个变量值传递给执行引擎 assign 赋值：把一个从执行引擎接收到的值赋给工作内存中的变量 store 存储：把工作内存中的一个变量的值传送给主内存中 write 写入：把store操作从工作内存中得到的变量值放入主内存的变量中 【volatile 特殊规则】\n可见性：对于 volatile 修饰的变量的写操作会立即刷新到内存中，任何线程对这个volatile 变量的读操作都能立即看到最新的值。 禁止指令重排序： 在对 volatile 变量进行读/写操作的时候，会插入内存屏障，禁止指令重排序。也就是该变量的写操作不能与之前的读/写操作重排序，它的都操作不能与之后的读/写操作重排序。 【Happens-Before 原则】\n",
  "keywords": [
    "Java", "JUC"
  ],
  "articleBody": "(JUC) Java并发面试题笔记 1. 什么是 Java 内存模型（JMM）？ JMM 是 Java内存模型 ， 它是Java虚拟机 JVM 定义的一种规范，用于描述多线程程序中的变量，像实例字段、静态字段和数组元素，他们如何在内存中存储和传递的规则。也就是规定线程啥时候从住内存里面读数据，啥时候把数据写回到住内存。JMM 的核心目标是确保多线程环境下的可见性、有序性和原子性, 避免硬件和编译器优化带来的不一致问题。\n【可见性、有序性、原子性定义】\n可见性：确保一个线程对共享变量的修改，能够及时被另外一个线程看到。 volatile就是用来保证可见性的，强制线程每次读写的时候，直接从主内存当中获取最新值。 有序性：指线程执行操作的顺序。JMM允许某些指令重排序之后再提高性能，但会保证线程内的操作顺序不会被破坏。通过happens-before (线程A发生在线程B之前)的关系来保证跨线程的有序性。 原子性：操作不可分割，线程不会在执行的过程当中被打断。例如, synchronize 关键字能确保方法或代码块的原子性 【JMM作用】\n因为不同的操作系统都有一套独立的内存模型，但是Java为了满足跨平台的特性，它需要定义一套内存模型屏蔽个操作系统之间的差异。我们可以利用JMM当中定义好的从Java源码到CPU指令的执行规范，也就是使用synchronized 、volatile 等关键字，还有happens-before原则，就可以写出并发安全的代码了。 比如说，线程A和线程B同时操作 变量-1，假如最开始变量-1 是 0\n首先，线程A和线程B都读取了变量-1 然后，线程B对取到的变量-1自增为1，并写回主内存 此时，线程A对读取到的变量-1也自增1，并写回主内存。这就会导致线程B的操作失效了，出现并发安全问题。 如果有JMM，我们就可以在线程A要修改数据之前,让它采用CAS乐观锁的方式进行修改。再次去读主内存当中的值，然后修改之后，再判断一下主内存的值是否发生变化。如果没有发生变化，就写回主内存。如果发生变化，就要进行自旋。\n【注意】 工作内存是每个线程独立的内存空间，其他线程都是看不到的。主内存是Java堆内存的一部分，所有的实例变量、静态变量和数组元素都存储在主内存当中。\n【内存间交互操作类型 (8种原子操作)】\nlock 上锁：把一个变量表示为一条线程独占的状态 unlock 解锁： 把一个变量从独占状态中释放出来，释放后的变量才能被其他线程锁定 read 读取： 从主内存当中读取一个变量到工作内存中 load 载入：把read操作从主内存中得到的变量值放入工作内存的变量副本当中 use 使用：把工作内存当中的一个变量值传递给执行引擎 assign 赋值：把一个从执行引擎接收到的值赋给工作内存中的变量 store 存储：把工作内存中的一个变量的值传送给主内存中 write 写入：把store操作从工作内存中得到的变量值放入主内存的变量中 【volatile 特殊规则】\n可见性：对于 volatile 修饰的变量的写操作会立即刷新到内存中，任何线程对这个volatile 变量的读操作都能立即看到最新的值。 禁止指令重排序： 在对 volatile 变量进行读/写操作的时候，会插入内存屏障，禁止指令重排序。也就是该变量的写操作不能与之前的读/写操作重排序，它的都操作不能与之后的读/写操作重排序。 【Happens-Before 原则】\n见下一个问题\n2. 什么是Java的 happens-before 规则? happens-before 原则就是 JMM 当中定义操作间顺序的规则，确保操作的有序性和可见性。\n程序次序规则：线程当中所有操作都是按程序代码的顺序发生 监视器锁规则：解锁操作发生在同一个锁的随后的加锁操作之前，说白了，先解锁，后上锁 volatile 变量规则： volatile 变量的写操作发生在对改变量随后的读操作之前，先写后读 线程启动规则：线程A对线程B的Thread.start() 调用发生在这个新线程的每一个操作之前 线程终止规则：线程A所有的操作都发生在其他线程检测到线程A终止之前 线程中断规则：对线程的中断操作 (Thread.interrupt()) 发生在被中断线程检测到的中断时间之前 (通过Thread.interrupted() 或 Thread.isInterrupted() 进行检测) 对象终结规则： 一个对象的构造函数执行结束发生在这个对象的finalize() 方法之前 传递性： 如果A happens-before B，B happens-before C, 则 A happens-before C 3. Java 的 synchronized 是怎么实现的？ 【实现原理】\nsynchronized 关键字是以来 JVM 的Monitor (监视器锁)和 Object Header (对象头) 实现的。其中，重量级所依赖于 Monitor 监视器锁， 轻量级锁和偏向锁都依赖于对象头 (Object Header)\n【不同使用场景的区别】\n修饰方法：会在修饰的方法的访问标志中增加一个 ACC_SYNCHRONIZED 标志，每当有一个线程访问该方法时， JVM回去检测该方法的访问标志。如果包含ACC_SYNCHRONIZED 标志， 线程必须获得该方法对应的对象监视器锁 (对象锁)，也就是Monitor 当中的owner执行该线程。 然后再执行该方法，保持同步性。 修饰代码块：在代码块的前后分别插入 monitorenter 和 monitorexit 字节码指令， 可以理解为加锁和解锁 【可重入性】\nsynchronized 是可以重入的，每次获取一次锁。如果是当前线程的锁，计数器加1，锁释放的时候，计数器减1。直到计数器减为 0 为止，锁才真正释放\n【synchronized 锁升级】\nsynchronized 锁分为三种，偏向锁，轻量级锁，重量级锁。其升级次序为偏向锁(一个线程) -\u003e 轻量级锁 (多个线程) -\u003e 重量级锁 (多个线程竞争激烈)\n偏向锁：当有线程第一次获取锁的时候， JVM 会采用修改锁对象的对象头，将该线程标记为偏向状态。对象头里面会记录线程ID 和 对应的epoch 偏向锁版本。后续该线程再获取锁，基本没啥开销。 轻量级锁：当有另外的线程尝试去获取已经被偏向的锁时，锁会升级为轻量级锁。此时，申请上锁的过程中，JVM会在当前线程的栈帧中创建一个锁记录Lock Record，让锁记录指向锁对象。然后用CAS 替换锁对象的Mark Word， 并将Mark Word 的值存入锁记录。如果替换成功，锁对象的Mark Word 就变成当前线程的所锁记录。使用 CAS 操作的目的是减少锁竞争的开销。 重量级锁：当 CAS 失败无法获取锁的时候，JVM判定其为多个线程竞争锁激烈。锁会升级成为重量锁，会使用操作系统的互斥量 Mutex 来实现线程的阻塞和环形。若果获取锁成功，线程会被放入Monitor的 owner 当中 【锁消除和锁粗化】\n锁消除：JVM判断对象是否只在当前线程使用，如果只在当前线程使用，则消除不必要加的锁 锁粗化：多个锁频繁操作出现时，JVM会将这些锁操作合并，见锁获取和释放的开销。 【参考材料】 黑马程序员-synchronized锁升级\n4. AQS了解过吗? AQS (Abstract Queued Synchronizer简称，抽象的队列式同步器), 它其实就是把跟锁相关的操作进行抽象和封装的一个工具类。将排队、入队、加锁、中断这些方法提供出来，方便其他相关JUC 锁的使用，具体的加锁时机、入队时机都需要实现类自己控制。 AQS 通过维护一个共享状态 state 和 一个先进先出 FIFO 的等待队列，来管理线程对共享资源的访问。共享状态 state 用 volatile 修饰，表示当前资源的状态，保证了可见性和有序性。在独占锁中 (ReentrantLock 或者 synchronized), state 为 0 表示未被占用，为1 表示已被占用。假如当前共享资源已经被占用，线程获取资源失败，会被加入到AQS 的等待队列里面。这个队列是一个变体的 CLH 队列， 采用双向链表结构，其节点包含线程的引用、等待状态、前驱节点和后继节点的指针。AQS 的常见实现类有 ReentrantLock、CountDownLatch 、Semaphore 等等 其中，CLH 队列是一种基于链表的、公平的自旋锁算法，主要用于多线程环境中实现锁的公平分配。\n【AQS 工作流程】 公平锁和非公平锁的区别就在于，公平锁是直接放到队里面，不会主动去尝试 CAS 获取锁\n先进先出 FIFO 队列用来实现多线程的排队工作，当线程加锁失败时，就把这个线程封装成一个Node 节点置于队列尾部 当持有锁的线程释放锁的时候，AQS 会将等待队列中第一个线程唤醒，并让它重新尝试获取锁 【同步状态 - state】\nAQS 使用一个volatile int类型的成员变量state来表示同步状态， 当state = 0 的时候表示没有锁，当state = 1 的时候表示当前对象锁已经被占有了。提供了三种API， 分别用于获取状态、设置状态和采用CAS 更新状态\n// 同步状态 private volatile int state; // 获取状态 protected final int getState() { return state; } // 设置状态 protected final void setState(int newState) { state = newState; } // CAS更新状态 protected final boolean compareAndSetState(int expect, int update) { // See below for intrinsics setup to support this return unsafe.compareAndSwapInt(this, stateOffset, expect, update); } 【FIFO队列 - Node】\n上面AQS 工作流程提到的Node 节点如下， Node 节点里面包含waitStatus 用于标记节点状态， thread 线程指针指向当前节点所代表的线程，还有前驱节点和后继结点指针。\n// Node类用于构建队列 static final class Node { // 标记节点状态。常见状态有 CANCELLED（表示线程取消）、SIGNAL（表示后继节点需要运行）、CONDITION（表示节点在条件队列中）等。 volatile int waitStatus; // 前驱节点 volatile Node prev; // 后继节点 volatile Node next; // 节点中的线程，存储线程引用，指向当前节点所代表的线程。 volatile Thread thread; } // 队列头节点，延迟初始化。只在setHead时修改 private transient volatile Node head; // 队列尾节点，延迟初始化。 private transient volatile Node tail; // 入队操作 private Node enq(final Node node) { for (;;) { Node t = tail; if (t == null) { // 必须先初始化 if (compareAndSetHead(new Node())) tail = head; } else { node.prev = t; if (compareAndSetTail(t, node)) { t.next = node; return t; } } } } 【同步队列和条件队列】\nAQS 有两种 FIFO 队列，同步队列和条件队列。同步队列用于锁的获取和释放，条件队列用于特定条件下管理线程的等待和唤醒。常用的ReentrantLock 就是基于同步队列实现的。\n同步队列的实现原理：当一个线程尝试获取锁失败的时候，AQS 会将该线程包装成一个 Node 节点加入到队列的尾部。这个节点会处于等待状态，直到所资源被其他线程释放。当锁被释放的时候，持有锁的线程会通知其他后继结点(如果存在的话)，后继结点会尝试获取锁，这个过程一直持续到线程成功获取锁或队列为空\nprivate Node addWaiter(Node mode) { Node node = new Node(Thread.currentThread(), mode); // 尝试快速路径：直接尝试在尾部插入节点 Node pred = tail; if (pred != null) { node.prev = pred; if (compareAndSetTail(pred, node)) { pred.next = node; return node; } } // 快速路径失败时，进入完整的入队操作 enq(node); return node; } private Node enq(final Node node) { for (;;) { Node t = tail; if (t == null) { // 队列为空，初始化 if (compareAndSetHead(new Node())) tail = head; } else { node.prev = t; if (compareAndSetTail(t, node)) { t.next = node; return t; } } } } 条件队列的实现原理：条件队列主要用于实现条件变量，实现了线程间的协调和通信。允许线程在特定条件不满足的时候挂起，等到其他线程改变了条件并显示的唤醒等待在该条件队列上的线程，典型的条件队列使用场景就是ReentrantLock 的 Condition\npublic class ConditionObject implements Condition, java.io.Serializable { // 条件队列的首尾节点 private transient Node firstWaiter; private transient Node lastWaiter; // ... } // ConditionObject是AQS的一个内部类，用于实现条件变量。条件变量用于线程间通信，允许一个或多个线程在特定条件成立之前等待，同时释放先关的锁。 public final void await() throws InterruptedException { // 如果当前线程在进入此方法之前已经被中断了，则直接抛出InterruptedException异常。 if (Thread.interrupted()) throw new InterruptedException(); // 将当前线程加入到等待队列中。 Node node = addConditionWaiter(); // 释放当前线程所持有的锁，并返回释放前的状态，以便以后可以重新获取到相同数量的锁。 int savedState = fullyRelease(node); // 中断模式，用于记录线程在等待过程中是否被中断。 int interruptMode = 0; // 如果当前节点不在同步队列中，则表示线程应该继续等待。 while (!isOnSyncQueue(node)) { // 阻塞当前线程，直到被唤醒或中断。 LockSupport.park(this); // 检查线程在等待过程中是否被中断，并更新interruptMode状态。 if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; } // 当节点成功加入到同步队列后，尝试以中断模式获取锁。 // 如果在此过程中线程被中断，且不是在signal之后，则设置中断模式为REINTERRUPT。 if (acquireQueued(node, savedState) \u0026\u0026 interruptMode != THROW_IE) interruptMode = REINTERRUPT; // 如果节点后面还有等待的节点，从等待队列中清理掉被取消的节点。 if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); // 根据中断模式处理中断。 if (interruptMode != 0) reportInterruptAfterWait(interruptMode); } 当线程调用了Condition 的 await() 方法后，它会释放当前持有的锁，并且该线程会被加入到条件队列中等待。直到被另一个线程的signal() (唤醒等待队列中头节点对应的线程) 或者 signalAll()（唤醒所有等待的线程）方法唤醒或者被中断。\npublic final void signal() { if (!isHeldExclusively()) throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignal(first); } private void doSignal(Node first) { do { if ( (firstWaiter = first.nextWaiter) == null) lastWaiter = null; first.nextWaiter = null; } while (!transferForSignal(first) \u0026\u0026 (first = firstWaiter) != null); } 【ReentrantLock、CountDownLatch、Semaphore 区别】\n对比维度 ReentrantLock CountDownLatch Semaphore 用途 互斥访问共享资源，支持可重入锁 等待多个线程完成操作后触发后续任务 控制同时访问共享资源的线程数量（限流） 同步方式 独占模式（Exclusive） 共享模式（Shared） 共享模式（Shared） 资源管理 通过 state 记录锁重入次数 通过 state 表示剩余需等待的计数 通过 state 表示可用许可证数量 释放机制 需显式调用 unlock() 释放锁 自动触发（countDown() 减至 0） 需显式调用 release() 归还许可 可重用性 可重复加锁/解锁（可重入） 一次性使用（计数归零后不可重置） 可重复获取/释放许可证 线程协作 基于条件变量 Condition 控制 无条件协作，仅等待计数归零 无协作，仅控制并发量 典型场景 替代 synchronized 的显式锁控制 主线程等待子线程初始化完成 数据库连接池、限流场景 【参考材料】\n从ReentrantLock的实现看AQS的原理及应用 【基本功】不可不说的Java“锁”事 5. Java 中 ReentrantLock 的实现原理是什么？ ReentrantLock 是基于 AQS 实现的一个可重入锁，支持公平锁和非公平锁两种方式。\n【ReentrantLock 结构】\n一个 state 变量: 用于表示锁的状态, state = 0 表示没有锁占用，state = 1 表示已经被占用 同步队列：用于锁的获取和释放。对于非公平锁，没有获取到锁的就会被放在这个队列里面。对于公平锁，所有的线程都是直接放到这个队列，依次等待获取锁。 条件队列：用于等待某个条件满足了之后，才让这些线程逐个获取锁。比如指定所有的线程必须在晚上2点开始扫描检查是否存在异常订单的情况，必须要等到晚上2点，这些线程才开始获取锁。 【CLH队列】\nCLH 是一种基于队列的自选锁，它适用于多处理器环境下的高并发场景。原理是通过维护一个隐式队列，让线程在等待锁的时候自旋在本地变量上，从而减少对共享变量的争用和缓存一致性流量。 它将争抢的线程组织成一个队列，通过排队的方式按序争抢锁。每个线程不再CAS 争抢一个变量，而是自选判断排在它前面的线程的状态，如果前面的线程状态为释放锁，那么后续的线程就抢锁。\nCLH 通过排队按序争抢解决了锁饥饿的问题 (锁饥饿就是有的线程长期抢不到锁)，通过 CAS 自选监听前面现成的状态避免总线风暴问题的产生。总线风暴是指短时间内大量并发CAS操作和缓存一致性协议产生的总线流量激增，会导致CPU利用率下降，内存访问延迟增加。 不过, CLH 的自旋期间线程会一直占用CPU资源，只适合锁等待比较短的场景。\n【AQS对CLH进行改造】\n为了防止CLH 自旋期间长期占用CPU资源的问题，AQS将自旋等待前置节点改成了阻塞线程。后续的线程没法儿主动去发现前面的线程是否释放了锁，只能等待前面线程通知后续线程锁被释放了，它采用去争夺锁。所以，AQS 把 CLH 改成了一个双向队列，让前面的线程可以通知后续的线程。如果后面的线程等待超时或者主动取消，则从队列中移除，后面的线程顶上来。\n6. 什么是 Java 的 CAS（Compare-And-Swap）操作？ CAS 是一种硬件级别的原子操作，用于实现无锁并发编程，使用比较和交换的方式确保线程安全。CAS 的作用就是保证无锁并发，而且CAS操作是原子的，保证了线程安全。\n【CAS过程】\n比较：CAS 在每次操作之前，会先检查内存当中的某个值是否与预期值相等 交换：如果发现同预期值相同，则将内存中的值更新为新值 自旋重试：如果发现和预期值不相同，说明其他线程已经修改了该值。它会在一定次数内，不断获取最新的内存值，更新预期值，然后再次尝试 CAS 操作。 【CAS存在的问题】\nABA问题：CAS 操作中，如果一个变量值被其他线程从A变成B，然后又变回A. CAS 无法检测到这种变化，可能会导致错误。 自旋开销：CAS 操作通常是通过自旋完成的，可能会导致CPU资源浪费，尤其是在高并发的情况下。 单变量控制：CAS 操作只适用单个变量的更新，不能涉及多个变量的复杂操作。 总线风暴：如果CAS修改同一个变量的并发很高，可能会导致总线风暴。 【总线风暴】\n总线风暴是指短时间内大量并发CAS操作和缓存一致性协议产生的总线流量激增，会导致CPU利用率下降，内存访问延迟增加。因为lock 前缀指令会把写缓冲区的所有数据立即刷新到主内存中，在对称多处理架构下，每个CPU都会通过嗅探总线来检查自己的缓存是否过期。如果某个CPU刷新自己的数据到驻村，就会通过总线通知其他CPU过期对应的缓存，实现内存屏障，保证一致性。 通过总线来回通信成为Cache 一致性流量，如果这个流量过大，总线就会成为瓶颈，导致本地缓存更新延迟。 所以，如果 CAS 修改同一个变量并发很高，就会导致总线风暴，出现性能瓶颈。\n7. 什么是 Java 中的 ABA 问题？ ABA 问题是指多线程环境下，某个变量的值在一顿时间内经历了从 A 到 B 再到 A 的变化，这种变化可能会被CAS 判定为值没有变化，从而导致线程发生错误的判断和操作。\n【ABA线程示例】\n下面的代码当中，如果线程A读取了oldHead， 此时另外一个线程B修改了栈的内容，然后将 oldHead 移除 (将栈顶元素从A 变成 B ， 再变成A)， 当线程A再次执行 compareAndSet 函数的时候，尽管值是一样的(oldHead没有变化)，但实际上栈的状态已经被修改过，可能导致数据不一致的问题。\npublic class LockFreeStack\u003cT\u003e { private AtomicReference\u003cNode\u003cT\u003e\u003e head = new AtomicReference\u003c\u003e(); public T pop() { Node\u003cT\u003e oldHead; Node\u003cT\u003e newHead; do { oldHead = head.get(); if (oldHead == null) { return null; } newHead = oldHead.next; } while (!head.compareAndSet(oldHead, newHead)); return oldHead.value; } } 【解决ABA问题的办法】\n引入版本号：在每次更新一个变量的时候，不仅更新变量的值，还更新一个版本号。CAS 操作在比较的时候，除了比较值是否一致，还比较版本号是否匹配。Java 当中的 AtomicStampReference 提供了版本号机制来避免 ABA 问题。每次更新stampedRef 的时候，都会一起更新对应的版本号\nAtomicStampedReference\u003cInteger\u003e stampedRef = new AtomicStampedReference\u003c\u003e(1, 0); int[] stampHolder = new int[1]; Integer ref = stampedRef.get(stampHolder); 使用AtomicMarkableReference：在变量的引用上标记一个布尔值，用来区分是否发生了特定的变化。不使用版本号，直接用标记位来追踪状态的变化。\nAtomicMarkableReference\u003cInteger\u003e markableRef = new AtomicMarkableReference\u003c\u003e(1, false); ",
  "wordCount" : "897",
  "inLanguage": "en",
  "image": "https://swimmingliu.cn/papermod-cover.png","datePublished": "2025-03-05T21:45:49+08:00",
  "dateModified": "2025-03-05T21:45:49+08:00",
  "author":[{
    "@type": "Person",
    "name": "SwimmingLiu"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://swimmingliu.cn/posts/job/java-juc-interview-questions/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "SwimmingLiu's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://swimmingliu.cn/images/swimmingliu_icon.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://swimmingliu.cn/" accesskey="h" title="𝓢𝔀𝓲𝓶𝓶𝓲𝓷𝓰𝓛𝓲𝓾&#39;𝓼 𝓑𝓵𝓸𝓰 (Alt + H)">
                <img src="https://swimmingliu.cn/images/swimmingliu_icon.png" alt="" aria-label="logo"
                    height="30">𝓢𝔀𝓲𝓶𝓶𝓲𝓷𝓰𝓛𝓲𝓾&#39;𝓼 𝓑𝓵𝓸𝓰</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://swimmingliu.cn/index.html" title="🏡 Home">
                    <span>🏡 Home</span>
                </a>
            </li>
            <li>
                <a href="https://swimmingliu.cn/search/" title="🔍 Search">
                    <span>🔍 Search</span>
                </a>
            </li>
            <li>
                <a href="https://swimmingliu.cn/posts/" title="🗒️ Posts">
                    <span>🗒️ Posts</span>
                </a>
            </li>
            <li>
                <a href="https://swimmingliu.cn/archives/" title="📃 Archive">
                    <span>📃 Archive</span>
                </a>
            </li>
            <li>
                <a href="https://swimmingliu.cn/tags/" title="📑 Tags">
                    <span>📑 Tags</span>
                </a>
            </li>
            <li>
                <a href="https://bento.me/swimmingliu" title="👨🏻‍🎓 About Me">
                    <span>👨🏻‍🎓 About Me</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
            <li>
                <a href="https://www.emojisearch.app/" title="Emoji">
                    <span>Emoji</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://swimmingliu.cn/">Home</a>&nbsp;»&nbsp;<a href="https://swimmingliu.cn/posts/">📚 Posts</a>&nbsp;»&nbsp;<a href="https://swimmingliu.cn/posts/job/">💻 Job</a></div>
    <h1 class="post-title entry-hint-parent">
      (JUC) Java并发面试题笔记
    </h1>
    <div class="post-meta"><span title='2025-03-05 21:45:49 +0800 CST'>March 5, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;SwimmingLiu

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#juc-java%e5%b9%b6%e5%8f%91%e9%9d%a2%e8%af%95%e9%a2%98%e7%ac%94%e8%ae%b0" aria-label="(JUC) Java并发面试题笔记">(JUC) Java并发面试题笔记</a><ul>
                        
                <li>
                    <a href="#1-%e4%bb%80%e4%b9%88%e6%98%af-java-%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8bjmm" aria-label="1. 什么是 Java 内存模型（JMM）？">1. 什么是 Java 内存模型（JMM）？</a></li>
                <li>
                    <a href="#2-%e4%bb%80%e4%b9%88%e6%98%afjava%e7%9a%84-happens-before-%e8%a7%84%e5%88%99" aria-label="2. 什么是Java的 happens-before 规则?">2. 什么是Java的 happens-before 规则?</a></li>
                <li>
                    <a href="#3--java-%e7%9a%84-synchronized-%e6%98%af%e6%80%8e%e4%b9%88%e5%ae%9e%e7%8e%b0%e7%9a%84" aria-label="3.  Java 的 synchronized 是怎么实现的？">3.  Java 的 synchronized 是怎么实现的？</a></li>
                <li>
                    <a href="#4-aqs%e4%ba%86%e8%a7%a3%e8%bf%87%e5%90%97" aria-label="4. AQS了解过吗?">4. AQS了解过吗?</a></li>
                <li>
                    <a href="#5-java-%e4%b8%ad-reentrantlock-%e7%9a%84%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88" aria-label="5. Java 中 ReentrantLock 的实现原理是什么？">5. Java 中 ReentrantLock 的实现原理是什么？</a></li>
                <li>
                    <a href="#6-%e4%bb%80%e4%b9%88%e6%98%af-java-%e7%9a%84-cascompare-and-swap%e6%93%8d%e4%bd%9c" aria-label="6. 什么是 Java 的 CAS（Compare-And-Swap）操作？">6. 什么是 Java 的 CAS（Compare-And-Swap）操作？</a></li>
                <li>
                    <a href="#7-%e4%bb%80%e4%b9%88%e6%98%af-java-%e4%b8%ad%e7%9a%84-aba-%e9%97%ae%e9%a2%98" aria-label="7. 什么是 Java 中的 ABA 问题？">7. 什么是 Java 中的 ABA 问题？</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>
  <div class="post-content"><h1 id="juc-java并发面试题笔记">(JUC) Java并发面试题笔记<a hidden class="anchor" aria-hidden="true" href="#juc-java并发面试题笔记">#</a></h1>
<h2 id="1-什么是-java-内存模型jmm">1. 什么是 Java 内存模型（JMM）？<a hidden class="anchor" aria-hidden="true" href="#1-什么是-java-内存模型jmm">#</a></h2>
<p><code>JMM</code> 是 Java内存模型 ， 它是Java虚拟机 <code>JVM</code> 定义的一种规范，用于描述多线程程序中的变量，像实例字段、静态字段和数组元素，他们如何在内存中存储和传递的规则。也就是规定线程啥时候从住内存里面读数据，啥时候把数据写回到住内存。<code>JMM</code> 的核心目标是确保多线程环境下的<strong>可见性</strong>、<strong>有序性</strong>和<strong>原子性</strong>, 避免硬件和编译器优化带来的不一致问题。</p>
<p><strong>【可见性、有序性、原子性定义】</strong></p>
<ul>
<li><strong>可见性</strong>：确保一个线程对共享变量的修改，能够及时被另外一个线程看到。 <code>volatile</code>就是用来保证可见性的，强制线程每次读写的时候，直接从主内存当中获取最新值。</li>
<li><strong>有序性</strong>：指线程执行操作的顺序。JMM允许某些指令重排序之后再提高性能，但会保证线程内的操作顺序不会被破坏。通过<code>happens-before</code> (线程A发生在线程B之前)的关系来保证跨线程的有序性。</li>
<li><strong>原子性</strong>：操作不可分割，线程不会在执行的过程当中被打断。例如, <code>synchronize</code> 关键字能确保方法或代码块的原子性</li>
</ul>
<p><strong>【JMM作用】</strong></p>
<p>因为不同的操作系统都有一套独立的内存模型，但是Java为了满足跨平台的特性，它需要定义一套内存模型屏蔽个操作系统之间的差异。我们可以利用JMM当中定义好的从Java源码到CPU指令的执行规范，也就是使用<code>synchronized</code> 、<code>volatile</code> 等关键字，还有<code>happens-before</code>原则，就可以写出并发安全的代码了。
比如说，线程A和线程B同时操作 <code>变量-1</code>，假如最开始<code>变量-1</code> 是 <code>0</code></p>
<ul>
<li>首先，线程A和线程B都读取了<code>变量-1</code></li>
<li>然后，线程B对取到的<code>变量-1</code>自增为<code>1</code>，并写回主内存</li>
<li>此时，线程A对读取到的<code>变量-1</code>也自增<code>1</code>，并写回主内存。这就会导致线程B的操作失效了，出现并发安全问题。</li>
</ul>
<p>如果有JMM，我们就可以在线程A要修改数据之前,让它采用CAS乐观锁的方式进行修改。再次去读主内存当中的值，然后修改之后，再判断一下主内存的值是否发生变化。如果没有发生变化，就写回主内存。如果发生变化，就要进行自旋。</p>
<p><strong>【注意】</strong> 工作内存是每个线程独立的内存空间，其他线程都是看不到的。主内存是Java堆内存的一部分，所有的实例变量、静态变量和数组元素都存储在主内存当中。</p>
<p><img alt="JMM架构图" loading="lazy" src="https://oss.swimmingliu.cn/49ddf552-f9c8-11ef-99c5-c858c0c1deba"></p>
<p><strong>【内存间交互操作类型 (8种原子操作)】</strong></p>
<ol>
<li><strong>lock 上锁</strong>：把一个变量表示为一条线程独占的状态</li>
<li><strong>unlock 解锁</strong>： 把一个变量从独占状态中释放出来，释放后的变量才能被其他线程锁定</li>
<li><strong>read 读取</strong>： 从主内存当中读取一个变量到工作内存中</li>
<li><strong>load 载入</strong>：把<code>read</code>操作从主内存中得到的变量值放入工作内存的变量副本当中</li>
<li><strong>use 使用</strong>：把工作内存当中的一个变量值传递给执行引擎</li>
<li><strong>assign 赋值</strong>：把一个从执行引擎接收到的值赋给工作内存中的变量</li>
<li><strong>store 存储</strong>：把工作内存中的一个变量的值传送给主内存中</li>
<li><strong>write 写入</strong>：把store操作从工作内存中得到的变量值放入主内存的变量中</li>
</ol>
<p><strong>【volatile 特殊规则】</strong></p>
<ul>
<li><strong>可见性</strong>：对于 <code>volatile</code> 修饰的变量的写操作会立即刷新到内存中，任何线程对这个<code>volatile</code> 变量的读操作都能立即看到最新的值。</li>
<li><strong>禁止指令重排序</strong>： 在对 <code>volatile</code> 变量进行读/写操作的时候，会插入内存屏障，禁止指令重排序。也就是该变量的写操作不能与之前的读/写操作重排序，它的都操作不能与之后的读/写操作重排序。</li>
</ul>
<p><strong>【Happens-Before 原则】</strong></p>
<p>见下一个问题</p>
<h2 id="2-什么是java的-happens-before-规则">2. 什么是Java的 happens-before 规则?<a hidden class="anchor" aria-hidden="true" href="#2-什么是java的-happens-before-规则">#</a></h2>
<p><code>happens-before</code> 原则就是 <code>JMM</code> 当中定义操作间顺序的规则，确保操作的有序性和可见性。</p>
<ol>
<li><strong>程序次序规则</strong>：线程当中所有操作都是按程序代码的顺序发生</li>
<li><strong>监视器锁规则</strong>：解锁操作发生在同一个锁的随后的加锁操作之前，说白了，先解锁，后上锁</li>
<li><strong><code>volatile</code> 变量规则</strong>： <code>volatile</code> 变量的写操作发生在对改变量随后的读操作之前，先写后读</li>
<li><strong>线程启动规则</strong>：线程A对线程B的<code>Thread.start()</code> 调用发生在这个新线程的每一个操作之前</li>
<li><strong>线程终止规则</strong>：线程A所有的操作都发生在其他线程检测到线程A终止之前</li>
<li><strong>线程中断规则</strong>：对线程的中断操作 (<code>Thread.interrupt()</code>) 发生在被中断线程检测到的中断时间之前 (通过<code>Thread.interrupted()</code> 或 <code>Thread.isInterrupted()</code> 进行检测)</li>
<li><strong>对象终结规则</strong>： 一个对象的构造函数执行结束发生在这个对象的<code>finalize()</code> 方法之前</li>
<li><strong>传递性</strong>： 如果A <code>happens-before</code> B，B <code>happens-before</code> C, 则 A <code>happens-before</code> C</li>
</ol>
<h2 id="3--java-的-synchronized-是怎么实现的">3.  Java 的 synchronized 是怎么实现的？<a hidden class="anchor" aria-hidden="true" href="#3--java-的-synchronized-是怎么实现的">#</a></h2>
<p><strong>【实现原理】</strong></p>
<p><code>synchronized</code> 关键字是以来 <code>JVM</code> 的Monitor (监视器锁)和 Object Header (对象头) 实现的。其中，重量级所依赖于 <code>Monitor</code> 监视器锁， 轻量级锁和偏向锁都依赖于对象头 (Object Header)</p>
<p><strong>【不同使用场景的区别】</strong></p>
<ul>
<li><strong>修饰方法</strong>：会在修饰的方法的访问标志中增加一个 <code>ACC_SYNCHRONIZED</code> 标志，每当有一个线程访问该方法时， JVM回去检测该方法的访问标志。如果包含<code>ACC_SYNCHRONIZED</code> 标志， 线程必须获得该方法对应的对象监视器锁 (对象锁)，也就是<code>Monitor</code> 当中的<code>owner</code>执行该线程。 然后再执行该方法，保持同步性。</li>
<li><strong>修饰代码块</strong>：在代码块的前后分别插入 <code>monitorenter</code> 和 <code>monitorexit</code> 字节码指令， 可以理解为加锁和解锁</li>
</ul>
<p><strong>【可重入性】</strong></p>
<p><code>synchronized</code> 是可以重入的，每次获取一次锁。如果是当前线程的锁，计数器加<code>1</code>，锁释放的时候，计数器减<code>1</code>。直到计数器减为 <code>0</code> 为止，锁才真正释放</p>
<p><strong>【<code>synchronized</code> 锁升级】</strong></p>
<p><code>synchronized</code> 锁分为三种，偏向锁，轻量级锁，重量级锁。其升级次序为偏向锁(一个线程) -&gt; 轻量级锁 (多个线程) -&gt; 重量级锁 (多个线程竞争激烈)</p>
<p><img alt="Synchronized对象头" loading="lazy" src="https://oss.swimmingliu.cn/4a286ce8-f9c8-11ef-b127-c858c0c1deba"></p>
<ul>
<li><strong>偏向锁</strong>：当有线程第一次获取锁的时候， <code>JVM</code> 会采用修改锁对象的对象头，将该线程标记为偏向状态。对象头里面会记录线程<code>ID</code> 和 对应的<code>epoch</code> 偏向锁版本。后续该线程再获取锁，基本没啥开销。</li>
<li><strong>轻量级锁</strong>：当有另外的线程尝试去获取已经被偏向的锁时，锁会升级为轻量级锁。此时，申请上锁的过程中，JVM会在当前线程的栈帧中创建一个锁记录<code>Lock Record</code>，让锁记录指向锁对象。然后用<code>CAS</code> 替换锁对象的<code>Mark Word</code>， 并将<code>Mark Word</code> 的值存入锁记录。如果替换成功，锁对象的<code>Mark Word</code> 就变成当前线程的所锁记录。使用 <code>CAS</code> 操作的目的是减少锁竞争的开销。</li>
<li><strong>重量级锁</strong>：当 <code>CAS</code> 失败无法获取锁的时候，JVM判定其为多个线程竞争锁激烈。锁会升级成为重量锁，会使用操作系统的互斥量 <code>Mutex</code> 来实现线程的阻塞和环形。若果获取锁成功，线程会被放入Monitor的 <code>owner</code> 当中</li>
</ul>
<p><img alt="Monitor结构" loading="lazy" src="https://oss.swimmingliu.cn/4a41e56d-f9c8-11ef-8eab-c858c0c1deba"></p>
<p><strong>【锁消除和锁粗化】</strong></p>
<ul>
<li><strong>锁消除</strong>：JVM判断对象是否只在当前线程使用，如果只在当前线程使用，则消除不必要加的锁</li>
<li><strong>锁粗化</strong>：多个锁频繁操作出现时，JVM会将这些锁操作合并，见锁获取和释放的开销。</li>
</ul>
<p><strong>【参考材料】</strong> <a href="https://blog.csdn.net/qq_38246328/article/details/124654374">黑马程序员-synchronized锁升级</a></p>
<h2 id="4-aqs了解过吗">4. AQS了解过吗?<a hidden class="anchor" aria-hidden="true" href="#4-aqs了解过吗">#</a></h2>
<p><code>AQS</code> (<code>Abstract Queued Synchronizer</code>简称，抽象的队列式同步器), 它其实就是把跟锁相关的操作进行抽象和封装的一个工具类。将排队、入队、加锁、中断这些方法提供出来，方便其他相关<code>JUC</code> 锁的使用，具体的加锁时机、入队时机都需要实现类自己控制。
<code>AQS</code> 通过维护一个共享状态 <code>state</code> 和 一个先进先出 <code>FIFO</code>  的等待队列，来管理线程对共享资源的访问。共享状态 <code>state</code> 用 <code>volatile</code> 修饰，表示当前资源的状态，保证了可见性和有序性。在独占锁中 (<code>ReentrantLock</code> 或者 <code>synchronized</code>), <code>state</code> 为 <code>0</code> 表示未被占用，为<code>1</code> 表示已被占用。假如当前共享资源已经被占用，线程获取资源失败，会被加入到<code>AQS</code> 的等待队列里面。这个队列是一个变体的 <code>CLH</code> 队列， 采用双向链表结构，其节点包含线程的引用、等待状态、前驱节点和后继节点的指针。<code>AQS</code> 的常见实现类有 <code>ReentrantLock</code>、<code>CountDownLatch</code> 、<code>Semaphore</code> 等等
其中，<code>CLH</code> 队列是一种基于链表的、公平的自旋锁算法，主要用于多线程环境中实现锁的公平分配。</p>
<p><img alt="AQS结构" loading="lazy" src="https://oss.swimmingliu.cn/f147d41b-fb59-11ef-9d36-c858c0c1deba"></p>
<p><strong>【AQS 工作流程】</strong> 公平锁和非公平锁的区别就在于，公平锁是直接放到队里面，不会主动去尝试 <code>CAS</code> 获取锁</p>
<ol>
<li>先进先出 <code>FIFO</code> 队列用来实现多线程的排队工作，当线程加锁失败时，就把这个线程封装成一个<code>Node</code> 节点置于队列尾部</li>
</ol>
<p><img alt="AQS队列的加锁过程" loading="lazy" src="https://oss.swimmingliu.cn/f2067cce-fb59-11ef-8306-c858c0c1deba"></p>
<ol start="2">
<li>当持有锁的线程释放锁的时候，<code>AQS</code> 会将等待队列中第一个线程唤醒，并让它重新尝试获取锁</li>
</ol>
<p><img alt="AQS队列的加锁过程-有线程持有锁" loading="lazy" src="https://oss.swimmingliu.cn/f21cfc0f-fb59-11ef-a390-c858c0c1deba"></p>
<p><strong>【同步状态 - state】</strong></p>
<p><code>AQS</code> 使用一个<code>volatile</code> int类型的成员变量<code>state</code>来表示同步状态， 当<code>state = 0</code> 的时候表示没有锁，当<code>state = 1</code> 的时候表示当前对象锁已经被占有了。提供了三种<code>API</code>， 分别用于获取状态、设置状态和采用<code>CAS</code> 更新状态</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 同步状态</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="kd">volatile</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">state</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 获取状态</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">protected</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">getState</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">state</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 设置状态</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">protected</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">setState</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">newState</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">newState</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// CAS更新状态</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">protected</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">compareAndSetState</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">expect</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">update</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// See below for intrinsics setup to support this</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">unsafe</span><span class="p">.</span><span class="na">compareAndSwapInt</span><span class="p">(</span><span class="k">this</span><span class="p">,</span><span class="w"> </span><span class="n">stateOffset</span><span class="p">,</span><span class="w"> </span><span class="n">expect</span><span class="p">,</span><span class="w"> </span><span class="n">update</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><strong>【FIFO队列 - Node】</strong></p>
<p>上面<code>AQS</code> 工作流程提到的<code>Node</code> 节点如下， <code>Node</code> 节点里面包含<code>waitStatus</code> 用于标记节点状态， <code>thread</code>  线程指针指向当前节点所代表的线程，还有前驱节点和后继结点指针。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// Node类用于构建队列</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Node</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 标记节点状态。常见状态有 CANCELLED（表示线程取消）、SIGNAL（表示后继节点需要运行）、CONDITION（表示节点在条件队列中）等。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">volatile</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">waitStatus</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 前驱节点</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">volatile</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="n">prev</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 后继节点</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">volatile</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="n">next</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 节点中的线程，存储线程引用，指向当前节点所代表的线程。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">volatile</span><span class="w"> </span><span class="n">Thread</span><span class="w"> </span><span class="n">thread</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 队列头节点，延迟初始化。只在setHead时修改</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="kd">transient</span><span class="w"> </span><span class="kd">volatile</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="n">head</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 队列尾节点，延迟初始化。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="kd">transient</span><span class="w"> </span><span class="kd">volatile</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 入队操作</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="nf">enq</span><span class="p">(</span><span class="kd">final</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="n">node</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;;)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Node</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 必须先初始化</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">compareAndSetHead</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Node</span><span class="p">()))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">node</span><span class="p">.</span><span class="na">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">compareAndSetTail</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">t</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><strong>【同步队列和条件队列】</strong></p>
<p><code>AQS</code> 有两种 <code>FIFO</code> 队列，同步队列和条件队列。同步队列用于锁的获取和释放，条件队列用于特定条件下管理线程的等待和唤醒。常用的<code>ReentrantLock</code> 就是基于同步队列实现的。</p>
<ul>
<li>
<p><strong>同步队列的实现原理</strong>：当一个线程尝试获取锁失败的时候，<code>AQS</code> 会将该线程包装成一个 <code>Node</code> 节点加入到队列的尾部。这个节点会处于等待状态，直到所资源被其他线程释放。当锁被释放的时候，持有锁的线程会通知其他后继结点(如果存在的话)，后继结点会尝试获取锁，这个过程一直持续到线程成功获取锁或队列为空</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="nf">addWaiter</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="n">mode</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Node</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Node</span><span class="p">(</span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">(),</span><span class="w"> </span><span class="n">mode</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 尝试快速路径：直接尝试在尾部插入节点</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Node</span><span class="w"> </span><span class="n">pred</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pred</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">node</span><span class="p">.</span><span class="na">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pred</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">compareAndSetTail</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">pred</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">node</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 快速路径失败时，进入完整的入队操作</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">enq</span><span class="p">(</span><span class="n">node</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">node</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="nf">enq</span><span class="p">(</span><span class="kd">final</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="n">node</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(;;)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Node</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tail</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">t</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 队列为空，初始化</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">compareAndSetHead</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">Node</span><span class="p">()))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">tail</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">node</span><span class="p">.</span><span class="na">prev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">compareAndSetTail</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="n">node</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">t</span><span class="p">.</span><span class="na">next</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">t</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p><strong>条件队列的实现原理</strong>：条件队列主要用于实现条件变量，实现了线程间的协调和通信。允许线程在特定条件不满足的时候挂起，等到其他线程改变了条件并显示的唤醒等待在该条件队列上的线程，典型的条件队列使用场景就是<code>ReentrantLock</code> 的 <code>Condition</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">ConditionObject</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">Condition</span><span class="p">,</span><span class="w"> </span><span class="n">java</span><span class="p">.</span><span class="na">io</span><span class="p">.</span><span class="na">Serializable</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 条件队列的首尾节点</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">transient</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="n">firstWaiter</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">transient</span><span class="w"> </span><span class="n">Node</span><span class="w"> </span><span class="n">lastWaiter</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// ...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// ConditionObject是AQS的一个内部类，用于实现条件变量。条件变量用于线程间通信，允许一个或多个线程在特定条件成立之前等待，同时释放先关的锁。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">await</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">InterruptedException</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 如果当前线程在进入此方法之前已经被中断了，则直接抛出InterruptedException异常。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Thread</span><span class="p">.</span><span class="na">interrupted</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">InterruptedException</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 将当前线程加入到等待队列中。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Node</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">addConditionWaiter</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 释放当前线程所持有的锁，并返回释放前的状态，以便以后可以重新获取到相同数量的锁。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">savedState</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fullyRelease</span><span class="p">(</span><span class="n">node</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 中断模式，用于记录线程在等待过程中是否被中断。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">interruptMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 如果当前节点不在同步队列中，则表示线程应该继续等待。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">isOnSyncQueue</span><span class="p">(</span><span class="n">node</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 阻塞当前线程，直到被唤醒或中断。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">LockSupport</span><span class="p">.</span><span class="na">park</span><span class="p">(</span><span class="k">this</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 检查线程在等待过程中是否被中断，并更新interruptMode状态。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">interruptMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">checkInterruptWhileWaiting</span><span class="p">(</span><span class="n">node</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">break</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 当节点成功加入到同步队列后，尝试以中断模式获取锁。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 如果在此过程中线程被中断，且不是在signal之后，则设置中断模式为REINTERRUPT。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">acquireQueued</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">savedState</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">interruptMode</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">THROW_IE</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">interruptMode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">REINTERRUPT</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 如果节点后面还有等待的节点，从等待队列中清理掉被取消的节点。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="na">nextWaiter</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="c1">// clean up if cancelled</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">unlinkCancelledWaiters</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 根据中断模式处理中断。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">interruptMode</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">reportInterruptAfterWait</span><span class="p">(</span><span class="n">interruptMode</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>当线程调用了<code>Condition</code> 的 <code>await()</code> 方法后，它会释放当前持有的锁，并且该线程会被加入到条件队列中等待。直到被另一个线程的<code>signal()</code> (唤醒等待队列中头节点对应的线程) 或者 <code>signalAll()</code>（唤醒所有等待的线程）方法唤醒或者被中断。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">signal</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">isHeldExclusively</span><span class="p">())</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">IllegalMonitorStateException</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Node</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">firstWaiter</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">first</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">doSignal</span><span class="p">(</span><span class="n">first</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">doSignal</span><span class="p">(</span><span class="n">Node</span><span class="w"> </span><span class="n">first</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="p">(</span><span class="n">firstWaiter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">first</span><span class="p">.</span><span class="na">nextWaiter</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">lastWaiter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">first</span><span class="p">.</span><span class="na">nextWaiter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">transferForSignal</span><span class="p">(</span><span class="n">first</span><span class="p">)</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">             </span><span class="p">(</span><span class="n">first</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">firstWaiter</span><span class="p">)</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
</ul>
<p><strong>【<code>ReentrantLock</code>、<code>CountDownLatch</code>、<code>Semaphore</code> 区别】</strong></p>
<table>
  <thead>
      <tr>
          <th><strong>对比维度</strong></th>
          <th><strong>ReentrantLock</strong></th>
          <th><strong>CountDownLatch</strong></th>
          <th><strong>Semaphore</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>用途</strong></td>
          <td>互斥访问共享资源，支持可重入锁</td>
          <td>等待多个线程完成操作后触发后续任务</td>
          <td>控制同时访问共享资源的线程数量（限流）</td>
      </tr>
      <tr>
          <td><strong>同步方式</strong></td>
          <td>独占模式（Exclusive）</td>
          <td>共享模式（Shared）</td>
          <td>共享模式（Shared）</td>
      </tr>
      <tr>
          <td><strong>资源管理</strong></td>
          <td>通过 <code>state</code> 记录锁重入次数</td>
          <td>通过 <code>state</code> 表示剩余需等待的计数</td>
          <td>通过 <code>state</code> 表示可用许可证数量</td>
      </tr>
      <tr>
          <td><strong>释放机制</strong></td>
          <td>需显式调用 <code>unlock()</code> 释放锁</td>
          <td>自动触发（<code>countDown()</code> 减至 0）</td>
          <td>需显式调用 <code>release()</code> 归还许可</td>
      </tr>
      <tr>
          <td><strong>可重用性</strong></td>
          <td>可重复加锁/解锁（可重入）</td>
          <td>一次性使用（计数归零后不可重置）</td>
          <td>可重复获取/释放许可证</td>
      </tr>
      <tr>
          <td><strong>线程协作</strong></td>
          <td>基于条件变量 <code>Condition</code> 控制</td>
          <td>无条件协作，仅等待计数归零</td>
          <td>无协作，仅控制并发量</td>
      </tr>
      <tr>
          <td><strong>典型场景</strong></td>
          <td>替代 <code>synchronized</code> 的显式锁控制</td>
          <td>主线程等待子线程初始化完成</td>
          <td>数据库连接池、限流场景</td>
      </tr>
  </tbody>
</table>
<p><strong>【参考材料】</strong></p>
<ol>
<li><a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">从ReentrantLock的实现看AQS的原理及应用</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&mid=2651749434&idx=3&sn=5ffa63ad47fe166f2f1a9f604ed10091&chksm=bd12a5778a652c61509d9e718ab086ff27ad8768586ea9b38c3dcf9e017a8e49bcae3df9bcc8&scene=38#wechat_redirect">【基本功】不可不说的Java“锁”事</a></li>
</ol>
<h2 id="5-java-中-reentrantlock-的实现原理是什么">5. Java 中 ReentrantLock 的实现原理是什么？<a hidden class="anchor" aria-hidden="true" href="#5-java-中-reentrantlock-的实现原理是什么">#</a></h2>
<p><code>ReentrantLock</code> 是基于 <code>AQS</code> 实现的一个可重入锁，支持公平锁和非公平锁两种方式。</p>
<p>【<code>ReentrantLock</code> 结构】</p>
<ul>
<li><strong>一个 <code>state</code> 变量</strong>: 用于表示锁的状态, <code>state = 0</code> 表示没有锁占用，<code>state = 1</code> 表示已经被占用</li>
<li><strong>同步队列</strong>：用于锁的获取和释放。对于非公平锁，没有获取到锁的就会被放在这个队列里面。对于公平锁，所有的线程都是直接放到这个队列，依次等待获取锁。</li>
<li><strong>条件队列</strong>：用于等待某个条件满足了之后，才让这些线程逐个获取锁。比如指定所有的线程必须在晚上2点开始扫描检查是否存在异常订单的情况，必须要等到晚上2点，这些线程才开始获取锁。</li>
</ul>
<p><img alt="ReentrantLock工作流程" loading="lazy" src="https://oss.swimmingliu.cn/f23cc434-fb59-11ef-8ca6-c858c0c1deba"></p>
<p><strong>【CLH队列】</strong></p>
<p><code>CLH</code> 是一种基于队列的自选锁，它适用于多处理器环境下的高并发场景。原理是通过维护一个<strong>隐式队列</strong>，让线程在等待锁的时候自旋在本地变量上，从而减少对共享变量的争用和缓存一致性流量。
它将争抢的线程组织成一个队列，通过排队的方式按序争抢锁。每个线程不再<code>CAS</code> 争抢一个变量，而是自选判断排在它前面的线程的状态，如果前面的线程状态为释放锁，那么后续的线程就抢锁。</p>
<p><img alt="CLH队列结构" loading="lazy" src="https://oss.swimmingliu.cn/f25c2db6-fb59-11ef-8a71-c858c0c1deba"></p>
<p><code>CLH</code> 通过排队按序争抢解决了锁饥饿的问题 (锁饥饿就是有的线程长期抢不到锁)，通过 <code>CAS</code> 自选监听前面现成的状态避免总线风暴问题的产生。总线风暴是指短时间内大量并发CAS操作和缓存一致性协议产生的总线流量激增，会导致CPU利用率下降，内存访问延迟增加。 不过, <code>CLH</code> 的自旋期间线程会一直占用CPU资源，只适合锁等待比较短的场景。</p>
<p><strong>【AQS对CLH进行改造】</strong></p>
<p>为了防止<code>CLH</code> 自旋期间长期占用CPU资源的问题，<code>AQS</code>将自旋等待前置节点改成了阻塞线程。后续的线程没法儿主动去发现前面的线程是否释放了锁，只能等待前面线程通知后续线程锁被释放了，它采用去争夺锁。所以，<code>AQS</code> 把 <code>CLH</code> 改成了一个双向队列，让前面的线程可以通知后续的线程。如果后面的线程等待超时或者主动取消，则从队列中移除，后面的线程顶上来。</p>
<p><img alt="AQS改进CLH结构工作流" loading="lazy" src="https://oss.swimmingliu.cn/f27716e4-fb59-11ef-836d-c858c0c1deba"></p>
<h2 id="6-什么是-java-的-cascompare-and-swap操作">6. 什么是 Java 的 CAS（Compare-And-Swap）操作？<a hidden class="anchor" aria-hidden="true" href="#6-什么是-java-的-cascompare-and-swap操作">#</a></h2>
<p><code>CAS</code> 是一种硬件级别的原子操作，用于实现无锁并发编程，使用比较和交换的方式确保线程安全。<code>CAS</code> 的作用就是保证无锁并发，而且<code>CAS</code>操作是原子的，保证了线程安全。</p>
<p><strong>【CAS过程】</strong></p>
<ol>
<li><strong>比较</strong>：<code>CAS</code> 在每次操作之前，会先检查内存当中的某个值是否与预期值相等</li>
<li><strong>交换</strong>：如果发现同预期值相同，则将内存中的值更新为新值</li>
<li><strong>自旋重试</strong>：如果发现和预期值不相同，说明其他线程已经修改了该值。它会在一定次数内，不断获取最新的内存值，更新预期值，然后再次尝试 <code>CAS</code> 操作。</li>
</ol>
<p><strong>【CAS存在的问题】</strong></p>
<ol>
<li><strong>ABA问题</strong>：<code>CAS</code> 操作中，如果一个变量值被其他线程从A变成B，然后又变回A. <code>CAS</code> 无法检测到这种变化，可能会导致错误。</li>
<li><strong>自旋开销</strong>：<code>CAS</code> 操作通常是通过自旋完成的，可能会导致CPU资源浪费，尤其是在高并发的情况下。</li>
<li><strong>单变量控制</strong>：<code>CAS</code> 操作只适用单个变量的更新，不能涉及多个变量的复杂操作。</li>
<li><strong>总线风暴</strong>：如果<code>CAS</code>修改同一个变量的并发很高，可能会导致总线风暴。</li>
</ol>
<p><strong>【总线风暴】</strong></p>
<p>总线风暴是指短时间内大量并发CAS操作和缓存一致性协议产生的总线流量激增，会导致CPU利用率下降，内存访问延迟增加。因为<code>lock</code> 前缀指令会把写缓冲区的所有数据立即刷新到主内存中，在对称多处理架构下，每个CPU都会通过嗅探总线来检查自己的缓存是否过期。如果某个CPU刷新自己的数据到驻村，就会通过总线通知其他CPU过期对应的缓存，实现内存屏障，保证一致性。
通过总线来回通信成为<code>Cache</code> 一致性流量，如果这个流量过大，总线就会成为瓶颈，导致本地缓存更新延迟。 所以，如果 <code>CAS</code>  修改同一个变量并发很高，就会导致总线风暴，出现性能瓶颈。</p>
<h2 id="7-什么是-java-中的-aba-问题">7. 什么是 Java 中的 ABA 问题？<a hidden class="anchor" aria-hidden="true" href="#7-什么是-java-中的-aba-问题">#</a></h2>
<p><code>ABA</code> 问题是指多线程环境下，某个变量的值在一顿时间内经历了从 <code>A</code> 到 <code>B</code> 再到 <code>A</code> 的变化，这种变化可能会被<code>CAS</code> 判定为值没有变化，从而导致线程发生错误的判断和操作。</p>
<p><strong>【ABA线程示例】</strong></p>
<p>下面的代码当中，如果线程A读取了<code>oldHead</code>， 此时另外一个线程B修改了栈的内容，然后将 <code>oldHead</code> 移除 (将栈顶元素从<code>A</code> 变成 <code>B</code> ， 再变成<code>A</code>)， 当线程A再次执行 <code>compareAndSet</code> 函数的时候，尽管值是一样的(<code>oldHead</code>没有变化)，但实际上栈的状态已经被修改过，可能导致数据不一致的问题。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">LockFreeStack</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">AtomicReference</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">head</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AtomicReference</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="nf">pop</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">oldHead</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Node</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">newHead</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">do</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">oldHead</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">head</span><span class="p">.</span><span class="na">get</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">oldHead</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="kc">null</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">newHead</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">oldHead</span><span class="p">.</span><span class="na">next</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="p">.</span><span class="na">compareAndSet</span><span class="p">(</span><span class="n">oldHead</span><span class="p">,</span><span class="w"> </span><span class="n">newHead</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">oldHead</span><span class="p">.</span><span class="na">value</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p><strong>【解决ABA问题的办法】</strong></p>
<ol>
<li>
<p><strong>引入版本号</strong>：在每次更新一个变量的时候，不仅更新变量的值，还更新一个版本号。<code>CAS</code> 操作在比较的时候，除了比较值是否一致，还比较版本号是否匹配。Java 当中的 <code>AtomicStampReference</code> 提供了版本号机制来避免 <code>ABA</code> 问题。每次更新<code>stampedRef</code> 的时候，都会一起更新对应的版本号</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">AtomicStampedReference</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">stampedRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AtomicStampedReference</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kt">int</span><span class="o">[]</span><span class="w"> </span><span class="n">stampHolder</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="kt">int</span><span class="o">[</span><span class="n">1</span><span class="o">]</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">Integer</span><span class="w"> </span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">stampedRef</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">stampHolder</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p><strong>使用<code>AtomicMarkableReference</code></strong>：在变量的引用上标记一个布尔值，用来区分是否发生了特定的变化。不使用版本号，直接用标记位来追踪状态的变化。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">AtomicMarkableReference</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">markableRef</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AtomicMarkableReference</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="kc">false</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></div></li>
</ol>


  </div>



  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://swimmingliu.cn/tags/java/">Java</a></li>
      <li><a href="https://swimmingliu.cn/tags/juc/">JUC</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://swimmingliu.cn/posts/job/desgin-mode-interview-questions/">
    <span class="title">« Prev</span>
    <br>
    <span>设计模式面试题笔记</span>
  </a>
  <a class="next" href="https://swimmingliu.cn/posts/job/operation-system-interview-questions/">
    <span class="title">Next »</span>
    <br>
    <span>操作系统面试题笔记</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2023-2025 <a href="https://swimmingliu.cn/">SwimmingLiu&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
    <span>
        <a href="https://beian.miit.gov.cn/">浙ICP备2024056260号</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
