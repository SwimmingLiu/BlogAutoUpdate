<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Java场景100题 | SwimmingLiu&#39;s Blog</title>
<meta name="keywords" content="Java">
<meta name="description" content="并发与性能优化
1. 大文件上传如何处理？分片上传
相关代码：https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson001
1.1 为什么需要分片上传?
大文件在上传的过程中，耗费的时间比较长。如果网络不稳定，很可能导致上传失败，需要重新上传。分片上传，就可以解决这个问题。
分片上传定义：将大文件拆分为不同的文件块，逐块进行上传
1.2 如何实现分片上传？
1.2.1 如何存储分片信息
分片上传需要记录文件的属性 (md5、大小、名称)、分片数量、文件存储的完整路径 (本地路径)，还需要记录每个分块的上传情况 (分块大小、分块顺序、分块任务id)。可以用 分块上传任务表 和 分块文件表 来记录。


分块任务表 (t_shard_upload)
create table if not exists t_shard_upload(
    id varchar(32) primary key,
    file_name varchar(256) not null comment &#39;文件名称&#39;,
    part_num int not null comment &#39;分片数量&#39;,
    md5 varchar(128) comment &#39;文件md5值&#39;,
    file_full_path varchar(512) comment &#39;文件完整路径&#39;
) comment = &#39;分片上传任务表&#39;;


分块文件表 (t_shard_upload_part）
create table if not exists  t_shard_upload_part(
    id varchar(32) primary key,
    shard_upload_id varchar(32) not null comment &#39;分片任务id（t_shard_upload.id）&#39;,
    part_order int not null comment &#39;第几个分片，从1开始&#39;,
    file_full_path varchar(512) comment &#39;文件完整路径&#39;,
    UNIQUE KEY `uq_part_order` (`shard_upload_id`,`part_order`)
) comment = &#39;分片文件表，每个分片文件对应一条记录&#39;;


分块文件表和分块上传表是 1 to M 的关系，假如当前文件分为10块。则会出现1个分片上传任务，和10个分片文件记录。">
<meta name="author" content="SwimmingLiu">
<link rel="canonical" href="https://swimmingliu.cn/posts/job/java-scene-quiz-100/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.6ecbb0040febd20e47edd88a662c19f1ea945bf7427774b86594271d18f88faf.css" integrity="sha256-bsuwBA/r0g5H7diKZiwZ8eqUW/dCd3S4ZZQnHRj4j68=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<link rel="apple-touch-icon" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<link rel="mask-icon" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://swimmingliu.cn/posts/job/java-scene-quiz-100/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ],
            
            throwOnError: false
        });
    });
</script>

<meta property="og:url" content="https://swimmingliu.cn/posts/job/java-scene-quiz-100/">
  <meta property="og:site_name" content="SwimmingLiu&#39;s Blog">
  <meta property="og:title" content="Java场景100题">
  <meta property="og:description" content="并发与性能优化 1. 大文件上传如何处理？分片上传 相关代码：https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson001
1.1 为什么需要分片上传? 大文件在上传的过程中，耗费的时间比较长。如果网络不稳定，很可能导致上传失败，需要重新上传。分片上传，就可以解决这个问题。
分片上传定义：将大文件拆分为不同的文件块，逐块进行上传
1.2 如何实现分片上传？ 1.2.1 如何存储分片信息 分片上传需要记录文件的属性 (md5、大小、名称)、分片数量、文件存储的完整路径 (本地路径)，还需要记录每个分块的上传情况 (分块大小、分块顺序、分块任务id)。可以用 分块上传任务表 和 分块文件表 来记录。
分块任务表 (t_shard_upload)
create table if not exists t_shard_upload( id varchar(32) primary key, file_name varchar(256) not null comment &#39;文件名称&#39;, part_num int not null comment &#39;分片数量&#39;, md5 varchar(128) comment &#39;文件md5值&#39;, file_full_path varchar(512) comment &#39;文件完整路径&#39; ) comment = &#39;分片上传任务表&#39;; 分块文件表 (t_shard_upload_part）
create table if not exists t_shard_upload_part( id varchar(32) primary key, shard_upload_id varchar(32) not null comment &#39;分片任务id（t_shard_upload.id）&#39;, part_order int not null comment &#39;第几个分片，从1开始&#39;, file_full_path varchar(512) comment &#39;文件完整路径&#39;, UNIQUE KEY `uq_part_order` (`shard_upload_id`,`part_order`) ) comment = &#39;分片文件表，每个分片文件对应一条记录&#39;; 分块文件表和分块上传表是 1 to M 的关系，假如当前文件分为10块。则会出现1个分片上传任务，和10个分片文件记录。">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-07-06T13:27:35+08:00">
    <meta property="article:modified_time" content="2025-07-06T13:27:35+08:00">
    <meta property="article:tag" content="Java">
      <meta property="og:image" content="https://swimmingliu.cn/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://swimmingliu.cn/papermod-cover.png">
<meta name="twitter:title" content="Java场景100题">
<meta name="twitter:description" content="并发与性能优化
1. 大文件上传如何处理？分片上传
相关代码：https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson001
1.1 为什么需要分片上传?
大文件在上传的过程中，耗费的时间比较长。如果网络不稳定，很可能导致上传失败，需要重新上传。分片上传，就可以解决这个问题。
分片上传定义：将大文件拆分为不同的文件块，逐块进行上传
1.2 如何实现分片上传？
1.2.1 如何存储分片信息
分片上传需要记录文件的属性 (md5、大小、名称)、分片数量、文件存储的完整路径 (本地路径)，还需要记录每个分块的上传情况 (分块大小、分块顺序、分块任务id)。可以用 分块上传任务表 和 分块文件表 来记录。


分块任务表 (t_shard_upload)
create table if not exists t_shard_upload(
    id varchar(32) primary key,
    file_name varchar(256) not null comment &#39;文件名称&#39;,
    part_num int not null comment &#39;分片数量&#39;,
    md5 varchar(128) comment &#39;文件md5值&#39;,
    file_full_path varchar(512) comment &#39;文件完整路径&#39;
) comment = &#39;分片上传任务表&#39;;


分块文件表 (t_shard_upload_part）
create table if not exists  t_shard_upload_part(
    id varchar(32) primary key,
    shard_upload_id varchar(32) not null comment &#39;分片任务id（t_shard_upload.id）&#39;,
    part_order int not null comment &#39;第几个分片，从1开始&#39;,
    file_full_path varchar(512) comment &#39;文件完整路径&#39;,
    UNIQUE KEY `uq_part_order` (`shard_upload_id`,`part_order`)
) comment = &#39;分片文件表，每个分片文件对应一条记录&#39;;


分块文件表和分块上传表是 1 to M 的关系，假如当前文件分为10块。则会出现1个分片上传任务，和10个分片文件记录。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚 Posts",
      "item": "https://swimmingliu.cn/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "💻 Job",
      "item": "https://swimmingliu.cn/posts/job/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Java场景100题",
      "item": "https://swimmingliu.cn/posts/job/java-scene-quiz-100/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java场景100题",
  "name": "Java场景100题",
  "description": "并发与性能优化 1. 大文件上传如何处理？分片上传 相关代码：https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson001\n1.1 为什么需要分片上传? 大文件在上传的过程中，耗费的时间比较长。如果网络不稳定，很可能导致上传失败，需要重新上传。分片上传，就可以解决这个问题。\n分片上传定义：将大文件拆分为不同的文件块，逐块进行上传\n1.2 如何实现分片上传？ 1.2.1 如何存储分片信息 分片上传需要记录文件的属性 (md5、大小、名称)、分片数量、文件存储的完整路径 (本地路径)，还需要记录每个分块的上传情况 (分块大小、分块顺序、分块任务id)。可以用 分块上传任务表 和 分块文件表 来记录。\n分块任务表 (t_shard_upload)\ncreate table if not exists t_shard_upload( id varchar(32) primary key, file_name varchar(256) not null comment \u0026#39;文件名称\u0026#39;, part_num int not null comment \u0026#39;分片数量\u0026#39;, md5 varchar(128) comment \u0026#39;文件md5值\u0026#39;, file_full_path varchar(512) comment \u0026#39;文件完整路径\u0026#39; ) comment = \u0026#39;分片上传任务表\u0026#39;; 分块文件表 (t_shard_upload_part）\ncreate table if not exists t_shard_upload_part( id varchar(32) primary key, shard_upload_id varchar(32) not null comment \u0026#39;分片任务id（t_shard_upload.id）\u0026#39;, part_order int not null comment \u0026#39;第几个分片，从1开始\u0026#39;, file_full_path varchar(512) comment \u0026#39;文件完整路径\u0026#39;, UNIQUE KEY `uq_part_order` (`shard_upload_id`,`part_order`) ) comment = \u0026#39;分片文件表，每个分片文件对应一条记录\u0026#39;; 分块文件表和分块上传表是 1 to M 的关系，假如当前文件分为10块。则会出现1个分片上传任务，和10个分片文件记录。\n",
  "keywords": [
    "Java"
  ],
  "articleBody": "并发与性能优化 1. 大文件上传如何处理？分片上传 相关代码：https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson001\n1.1 为什么需要分片上传? 大文件在上传的过程中，耗费的时间比较长。如果网络不稳定，很可能导致上传失败，需要重新上传。分片上传，就可以解决这个问题。\n分片上传定义：将大文件拆分为不同的文件块，逐块进行上传\n1.2 如何实现分片上传？ 1.2.1 如何存储分片信息 分片上传需要记录文件的属性 (md5、大小、名称)、分片数量、文件存储的完整路径 (本地路径)，还需要记录每个分块的上传情况 (分块大小、分块顺序、分块任务id)。可以用 分块上传任务表 和 分块文件表 来记录。\n分块任务表 (t_shard_upload)\ncreate table if not exists t_shard_upload( id varchar(32) primary key, file_name varchar(256) not null comment '文件名称', part_num int not null comment '分片数量', md5 varchar(128) comment '文件md5值', file_full_path varchar(512) comment '文件完整路径' ) comment = '分片上传任务表'; 分块文件表 (t_shard_upload_part）\ncreate table if not exists t_shard_upload_part( id varchar(32) primary key, shard_upload_id varchar(32) not null comment '分片任务id（t_shard_upload.id）', part_order int not null comment '第几个分片，从1开始', file_full_path varchar(512) comment '文件完整路径', UNIQUE KEY `uq_part_order` (`shard_upload_id`,`part_order`) ) comment = '分片文件表，每个分片文件对应一条记录'; 分块文件表和分块上传表是 1 to M 的关系，假如当前文件分为10块。则会出现1个分片上传任务，和10个分片文件记录。\n1.2.2 如何定义分块上传接口 分块上传可以分为下面 5 个接口\n**创建分片上传任务接口 ** (/shardUpload/init) 入参：文件名称、文件大小、文件md5 出参：任务id、分片数量 实现：计算分片数量，创建分片任务 上传分片文件 (/shardUpload/uploadPart) 入参：MultiPartFile 文件 出参 ：分片文件记录id、任务id 实现：存入文件到磁盘自动位置，创建分片文件记录 合并分片、完成上传 (/shardUpload/complete) 入参：任务id 出参：布尔值 实现：按照顺序合并所有二进制文件 获取分片任务详细信息(/shardUpload/detail) 入参：任务id 、文件md5 (二选一) 出参：任务进度、文件名称、文件md5 实现：读取分片文件表查看上传情况 功能：获取分片任务的状态信息，如分片任务是否上传完毕，哪些分片已上传等信息，网络出现故障，可以借助此接口恢复上传 1.3 如果上传过程中，出现故障如何处理？ 情况1：浏览器无法读取刚才用户选择的文件了 此时需要用户重新选择文件，重新上传。这个地方也可以给大家提供另外一种思路，第1个接口创建分片任务的时候传入了文件的md5，按说这个值是具有唯一性的，那么就可以通过这个值找到刚才的任务，按照这种思路，就需要后端提供一个新的接口：通过文件的md5值找到刚才失败的那个任务，然后继续上传未上传的分片。\n情况2：浏览器可以继续读取刚才用户选择的文件 这种情况，可以先调用第4个接口，通过此接口可以知道那些分片还未上传，然后继续上传这些分片就可以了。\n2. 多线程任务批处理通用工具类 相关代码：https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson002\n使用线程池批量发送短信，当短信发送完毕之后，记录耗时情况 【主要知识点】\nCountDownLatch：如果想要等异步线程执行之后，再继续回到原方法中，可以使用CountDownLatch Executors：用于创建线程池，重写 executor.execute 中的 Runnable 方法，可实现异步执行线程 public class TaskDisposeUtils { /** * 使用线程池批处理文件，当所有任务处理完毕后才会返回 * * @param taskList 任务列表 * @param consumer 处理任务的方法 * @param executor 线程池 * @param * @throws InterruptedException */ public static \u003cT\u003e void dispose(List\u003cT\u003e taskList, Consumer\u003c? super T\u003e consumer, Executor executor) throws InterruptedException { if (taskList == null || taskList.isEmpty() || consumer == null) return; CountDownLatch latch = new CountDownLatch(taskList.size()); for (T item : taskList) { executor.execute(() -\u003e { try { consumer.accept(item); } finally { latch.countDown(); } }); } latch.await(); } public static void main(String[] args) throws InterruptedException { long startTime = System.currentTimeMillis(); List\u003cString\u003e taskList = List.of(\"短信-1\", \"短信-2\", \"短信-3\"); ExecutorService executor = Executors.newFixedThreadPool(10); dispose(taskList, TaskDisposeUtils::doTask, executor); System.out.println(\"任务处理完毕,耗时(ms):\" + (System.currentTimeMillis() - startTime)); executor.shutdown(); } public static void doTask(String task) { System.out.println(task + \"发送成功\"); try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { Thread.currentThread().interrupt(); } } } 3. 接口性能压力测试工具 相关代码：https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson003\n3.1 常用压测工具类 Jemeter 、LoadRunner、ApiFox - 自动化测试\n【注意】LoadRunner 只有window可以用\n3.2 手写压测工具类 【主要知识点】\n为什么 updateFastestTime 方法需要使用循环而不是直接 compareAndSet ：因为直接使用 compareAndSet 会出现线程不安全的情况，比如下面的情况\n// 错误的做法（非线程安全） int current = fastestCostTime.get(); // 线程A读取到值100 if (current \u003e costTime) { // 线程A判断100 \u003e 30，准备更新 // 此时线程B也读取到100，也判断100 \u003e 50，也准备更新 fastestCostTime.set(costTime); // 线程A设置为30 // 线程B设置为50，覆盖了线程A的结果 (最小时间应该是30s) } // 使用while循环保证线程安全 （其实就是CAS） while (true){ int fsCostTime = fastestCostTime.get(); // 线程A读取到100 // 线程B此时将值改为90 if (fastestCostTime.compareAndSet(fsCostTime, costTime)) { // 线程A尝试将100改为50 // 失败！因为当前值已经是90，不等于预期的100 break; } // 继续循环，重新获取最新值90，再次尝试 } 线程池参数：数依次为 coolPoolSize 、maxPoolSize、keepAliveTime、TimeUnit、waitQueue 等待队列\n为什么线程需要预热：预热是为了避免线程创建时带来的额外开销，如果不预热，很可能前 100 个核心线程需要多消耗 10~50 ms 来创建线程\nAtomicInteger：防止多线程修改同一数据时，出现线程不安全的情况\n// 普通Integer的问题 int value = counter; // 1. 读取 value = value + 1; // 2. 修改 counter = value; // 3. 写入 // 这三步不是原子的，可能被其他线程中断 // AtomicInteger采用CAS + volatile 保证原子性 atomicCounter.incrementAndGet(); // 原子操作 volatile 关键字在AtomicInteger作用：volatile 就像是给变量贴了个\"实时更新\"的标签。通过内存可见性和禁止指令重排序来保证实时更新\n// 没有volatile的情况 int count = 0; // 线程A修改了count = 100 // 线程B可能还是看到count = 0（因为每个线程都有自己的缓存） 所以，如果 没有volatile 关键字， 没有线程都有自己的\"小本本\"（CPU缓存，线程私有），可能记录的数据不是最新的。\npublic class LoadRunnerUtils { public static class LoadRunnerResult { private int requests; // 请求总数 private int concurrency; // 并发量 private int successRequests; // 成功请求数 private int failRequests; // 失败请求数 private int timeTakenForTests; // 请求总耗时(ms) private float requestsPerSecond; // 每秒请求数（吞吐量） private float timePerRequest; // 每个请求平均耗时(ms) private float fastestCostTime; // 最快的请求耗时(ms) private float slowestCostTime; // 最慢的请求耗时(ms) } /** * 执行并发压力测试 * @param requests 总请求数 * @param concurrency 并发数量 * @param command 被测试的代码 * @return 压测结果 */ public static LoadRunnerResult run(int requests, int concurrency, Runnable command) throws InterruptedException { log.info(\"压测开始......\"); // 创建固定大小的线程池，预热所有核心线程 ThreadPoolExecutor executor = createThreadPool(concurrency); // 用于等待所有请求完成的同步器 CountDownLatch latch = new CountDownLatch(requests); // 统计数据（使用原子类保证线程安全） AtomicInteger successCount = new AtomicInteger(0); AtomicInteger fastestTime = new AtomicInteger(Integer.MAX_VALUE); AtomicInteger slowestTime = new AtomicInteger(Integer.MIN_VALUE); long startTime = System.currentTimeMillis(); // 提交所有压测任务 for (int i = 0; i \u003c requests; i++) { executor.execute(() -\u003e executeRequest(command, successCount, fastestTime, slowestTime, latch)); } // 等待所有请求完成 latch.await(); executor.shutdown(); long endTime = System.currentTimeMillis(); log.info(\"压测结束，总耗时(ms):{}\", (endTime - startTime)); // 返回压测结果 } /** * 创建线程池并预热核心线程 */ private static ThreadPoolExecutor createThreadPool(int concurrency) { // 参数依次为 coolPoolSize、maxPoolSize、keepAliveTime、TimeUnit、等待队列 ThreadPoolExecutor executor = new ThreadPoolExecutor(concurrency, concurrency, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue\u003c\u003e()); executor.prestartAllCoreThreads(); return executor; } /** * 执行单个请求并统计结果 */ private static void executeRequest(Runnable command, AtomicInteger successCount, AtomicInteger fastestTime, AtomicInteger slowestTime, CountDownLatch latch) { try { long requestStart = System.currentTimeMillis(); command.run(); // 执行被测试的方法 int costTime = (int)(System.currentTimeMillis() - requestStart); // 更新统计数据 updateFastestTime(fastestTime, costTime); updateSlowestTime(slowestTime, costTime); successCount.incrementAndGet(); } catch (Exception e) { log.error(\"请求执行失败: {}\", e.getMessage()); } finally { latch.countDown(); // 标记当前请求完成 } } /** * 原子更新最快耗时 */ private static void updateFastestTime(AtomicInteger fastestTime, int costTime) { while (true) { int current = fastestTime.get(); if (current \u003c= costTime || fastestTime.compareAndSet(current, costTime)) { break; } } } } 4. Semaphore实现接口限流 如果后端服务是单体服务，且只部署在一台服务器上，可以采用 Semaphore 信号量的方式实现简单的接口限流机制\n相关代码：https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson005\nSemaphore : JUC当中对信号量的实现，用于控制同时访问共享资源的线程数量。\npublic class TestController { /** * Juc中的Semaphore可以实现限流功能，可以将 Semaphore 想象成停车场入口的大爷， * 大爷手里面拥有一定数量的停车卡（也可以说是令牌），卡的数量是多少呢？就是Semaphore构造方法中指定的，如下就是50个卡， * 车主想进去停车，先要从大爷手中拿到一张卡，出来的时候，需要还给大爷，如果拿不到卡，就不能进去停车。 * semaphore 内部提供了获取令牌，和还令牌的一些方法 */ private Semaphore semaphore = new Semaphore(50); /** * 来个案例，下面是一个下单的方法，这个方法最多只允许 50 个并发，若超过50个并发，则进来的请求，最多等待1秒，如果无法获取到令牌，则快速返回失败，请重试 * @return */ @GetMapping(\"/placeOrder\") public String placeOrder() throws InterruptedException { /** * semaphore 在上面定义的，里面有50个令牌，也就是同时可以支持50个并发请求 * 下面的代码，尝试最多等待1秒去获取令牌，获取成功，则进入下单逻辑，获取失败，则返回系统繁忙，请稍后重试 */ boolean flag = this.semaphore.tryAcquire(1, 1L, TimeUnit.SECONDS); // 获取到令牌，则进入下单逻辑 if (flag) { try { //这里休眠2秒，模拟下单的操作 TimeUnit.SECONDS.sleep(2); return \"下单成功\"; } finally { //这里一定不要漏掉了，令牌用完了，要还回去 this.semaphore.release(); } } else { return \"系统繁忙，请稍后重试\"; } } } 5. 并行查询 - 提交接口响应速度 需求分析：当前接口需要实现下面的功能\n接收一个商品id，需要返回商品下面这些信息，这些信息都在不同的表中，通过商品id就可以查到\n商品基本信息（如商品名称、价格等基本信息) 商品描述信息（可能是富文本，放在单独的表中） 商品收藏量 商品评论量 相关代码：https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson006\n5.1 常规做法 按照商品 id 分别查询不同的数据库，在JVM内存中对结果进行组装。\npublic class GoodsController { /** * 根据商品id获取商品信息(基本信息、描述信息、评论量，收藏量) * * @param goodsId 商品id * @return * @throws InterruptedException */ @GetMapping(\"/getGoodsDetail\") public GoodsDetailResponse getGoodsDetail(@RequestParam(\"goodsId\") String goodsId) { long st = System.currentTimeMillis(); GoodsDetailResponse goodsDetailResponse = new GoodsDetailResponse(); // 1、获取商品基本信息，耗时100ms goodsDetailResponse.setGoodsInfo(this.getGoodsInfo(goodsId)); //2、获取商品描述信息，耗时100ms goodsDetailResponse.setGoodsDescription(this.getGoodsDescription(goodsId)); //3、获取商品评论量，耗时100ms goodsDetailResponse.setCommentCount(this.getGoodsCommentCount(goodsId)); //4、获取商品收藏量，耗时100ms goodsDetailResponse.setFavoriteCount(this.getGoodsFavoriteCount(goodsId)); // 总耗时为500ms左右 LOGGER.info(\"获取商品信息，普通版耗时：{} ms\", (System.currentTimeMillis() - st)); } // 使用sleep模拟数据库查询的延迟 private int getGoodsFavoriteCount(String goodsId) { try { log.info(\"获取商品收藏量\"); TimeUnit.MILLISECONDS.sleep(100); } catch (InterruptedException e) { Thread.currentThread().interrupt(); throw new RuntimeException(e); } return 10000; } 5.2 使用线程池并行查询商品信息 分析：上方的4个商品信息查询之间并没有任何依赖，这些没有依赖的查询其实是可以并行查询的。所以可以使用线程池同时去拿这4个结果，然后在JVM内存中进行组装\n【主要知识点】\nCompletableFuture (CF)：主要用于异步执行多个相互独立的任务 （适合异步任务编排，可以方便地组合和转换任务结果）\nCountDownLatch (CDL): 主要用于线程协调，等待一组线程完成 （一般就是用来等待一批线程执行完）\nCF 和 CDL 区别\nCountDownLatch 👉 运动会起跑 裁判（主线程）等待所有运动员（子线程）就位（countDown），枪响（计数器归零）后统一开跑。 CompletableFuture 👉 外卖订单流程 下单（异步任务）→ 制作（thenApply 加工）→ 配送（thenAccept 交付），每个环节自动触发下一步，无需阻塞 对比维度 CountDownLatch CompletableFuture 核心用途 线程等待机制（阻塞线程直到任务完成） 异步编程模型（非阻塞链式任务处理） 工作方式 通过计数器递减（countDown()）触发释放 通过回调链（thenApply()/thenAccept()）传递结果 线程阻塞 调用线程主动阻塞（await()） 调用线程不阻塞，通过回调处理结果 结果传递 ❌ 不支持任务结果传递 ✅ 支持任务结果传递和转换 异常处理 ❌ 需手动捕获异常 ✅ 内置异常处理（exceptionally()/handle()） 任务组合 ❌ 仅支持单次计数 ✅ 支持多任务组合（allOf()/anyOf()） 复用性 ❌ 计数器归零后不可重用 ✅ 可重复组合新任务 典型场景 启动前等待资源初始化、批量任务并行执行 异步API调用、流水线式数据处理、微服务编排 下面看一组CF和CDL的代码对比：\npublic class AsyncDemo { // 模拟线程池 private static final ExecutorService executor = Executors.newFixedThreadPool(3); /** * CompletableFuture方式 - 支持任务编排和结果处理 */ public GoodsInfo getGoodsInfoWithCF(String goodsId) { GoodsInfo result = new GoodsInfo(); // 1. 创建多个异步任务 CompletableFuture\u003cString\u003e basicInfoFuture = CompletableFuture .supplyAsync(() -\u003e queryBasicInfo(goodsId), executor); CompletableFuture\u003cInteger\u003e priceFuture = CompletableFuture .supplyAsync(() -\u003e queryPrice(goodsId), executor); // 2. 对结果进行处理转换 CompletableFuture\u003cString\u003e processedInfo = basicInfoFuture .thenApply(info -\u003e \"处理后的商品信息: \" + info) .exceptionally(ex -\u003e \"获取商品信息失败\"); // 3. 等待所有任务完成并组装结果 CompletableFuture.allOf(processedInfo, priceFuture).join(); result.setInfo(processedInfo.join()); result.setPrice(priceFuture.join()); return result; } /** * CountDownLatch方式 - 仅支持等待多个线程完成 */ public GoodsInfo getGoodsInfoWithCDL(String goodsId) throws InterruptedException { GoodsInfo result = new GoodsInfo(); CountDownLatch latch = new CountDownLatch(2); // 1. 需要手动创建线程执行任务 executor.submit(() -\u003e { try { result.setInfo(queryBasicInfo(goodsId)); } finally { latch.countDown(); } }); executor.submit(() -\u003e { try { result.setPrice(queryPrice(goodsId)); } finally { latch.countDown(); } }); // 2. 等待所有任务完成 latch.await(); return result; } 如果需要异步并行 + 任务编排，就用 CompletableFuture ；如果只是用于等待一批异步任务执行完，就用 CountDownLaunch\npublic class GoodsController { /** * 优化后的方法，根据商品id获取商品信息(基本信息、描述信息、评论量，收藏量) * * @param goodsId 商品id * @return * @throws InterruptedException */ @GetMapping(\"/getGoodsDetailNew\") public GoodsDetailResponse getGoodsDetailNew(@RequestParam(\"goodsId\") String goodsId) { long st = System.currentTimeMillis(); GoodsDetailResponse goodsDetailResponse = new GoodsDetailResponse(); // 1、获取商品基本信息，耗时100ms CompletableFuture\u003cVoid\u003e goodsInfoCf = CompletableFuture.runAsync(() -\u003e goodsDetailResponse.setGoodsInfo(this.getGoodsInfo(goodsId)), this.goodsThreadPool); //2、获取商品描述信息，耗时100ms CompletableFuture\u003cVoid\u003e goodsDescriptionCf = CompletableFuture.runAsync(() -\u003e goodsDetailResponse.setGoodsDescription(this.getGoodsDescription(goodsId)), this.goodsThreadPool); //3、获取商品评论量，耗时100ms CompletableFuture\u003cVoid\u003e goodsCommentCountCf = CompletableFuture.runAsync(() -\u003e goodsDetailResponse.setCommentCount(this.getGoodsCommentCount(goodsId)), this.goodsThreadPool); //4、获取商品收藏量，耗时100ms CompletableFuture\u003cVoid\u003e goodsFavoriteCountCf = CompletableFuture.runAsync(() -\u003e goodsDetailResponse.setFavoriteCount(this.getGoodsFavoriteCount(goodsId)), this.goodsThreadPool); //等待上面执行结束 CompletableFuture.allOf(goodsInfoCf, goodsDescriptionCf, goodsCommentCountCf, goodsFavoriteCountCf).join(); // 总耗时大约在100ms左右 LOGGER.info(\"获取商品信息，使用线程池并行查询耗时：{} ms\", (System.currentTimeMillis() - st)); return goodsDetailResponse; } } 6. 并行查询可能存在的问题？如何解决？ 相关代码：https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson006\n6.1 并行查询中存在的问题 并行查询所用到的线程池配置是非常关键且重要的配置，如果设置不当可能出现严重的性能问题。\n比如将核心线程数设置为了 1 ，而队列大小没有限制，那么所有的请求都变成串行了，会导致请求响应非常慢。另外，核心线程池和队列大小的上限也应该匹配。如果核心线程池设置为 10 ，而队列大小没有设置上限。该线程池同时只可支持 10 个任务并行，其他的请求都会变成串行执行了，进入队列排队，从而导致接口响应特别慢。\n6.2 如何解决并行查询的问题 解决并行查询问题的核心：不要让任务排队或者排队时间不要太长\n下面从线程池的执行流程入手，优化并行查询问题\n【解决方案】\n增大线程数：可以将核心线程数、最大线程数调大，但不能调到超过CPU的最大负载，不然可能会降低系统性能分。该参数应该根据业务的指标进行压测得到一个合理的值\n减少队列数：\n将队列大小设置的比较小，这样排队的时间大概率会比较短，或者排队失败，直接后面的流程\n⚠️ 之前理解存在误区：应该是核心线程检查完了，就检查能否放入队列，再检查最大线程数。而不是核心线程检查完，就去检查最大线程数。\n减少队列数至 0：这样任务就不会进入队列，而直接创建新的线程去执行，或者走拒绝策略\nLinkedBlockingQueue、ArrayBlockingQueue 容量是不允许为0的，如果需要用到容量为0的队列，则需要使用同步阻塞队列 SynchronousQueue\n拒绝策略：可以使用 CallerRunsPolicy，这个策略是直接在调用线程的当前线程中执行。该策略可以保证任务能快速被处理，不会一直处于阻塞态\n策略名称 行为描述 适用场景 生活实例类比 AbortPolicy 直接抛出 RejectedExecutionException 异常 需要严格保证任务不丢失的场景 餐厅满员时直接拒绝新顾客 CallerRunsPolicy 让提交任务的线程自己执行该任务 需要降低任务提交速度的场景 经理亲自处理无法分配的任务 DiscardPolicy 静默丢弃新任务，不抛异常也不执行 允许丢弃非关键任务的场景 快递爆仓时直接丢弃新包裹 DiscardOldestPolicy 丢弃队列中最老的任务，然后尝试重新提交当前任务 优先处理新任务的场景 超市排队时让等待最久的顾客离开 线程池隔离：不同的业务最好使用不同的线程池，互不影响，强烈建议核心业务一定要使用单独的线程池。\n【优化后的线程池配置】\n@Bean public ThreadPoolTaskExecutor goodsThreadPool() { ThreadPoolTaskExecutor threadPoolTaskExecutor = new ThreadPoolTaskExecutor(); threadPoolTaskExecutor.setThreadNamePrefix(\"ThreadPool-Goods-\"); // 核心线程数为cpu核数 * 4，最大线程数据为cpu核数 * 8 threadPoolTaskExecutor.setCorePoolSize(Runtime.getRuntime().availableProcessors() * 4); threadPoolTaskExecutor.setMaxPoolSize(Runtime.getRuntime().availableProcessors() * 8); // 队列容量为0，则任务就不会进入队列 threadPoolTaskExecutor.setQueueCapacity(0); // 拒绝策略使用CallerRunsPolicy，让当前线程去兜底去执行任务 threadPoolTaskExecutor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy()); return threadPoolTaskExecutor; } 7. 接口性能调优之大 (长) 事务优化 日常编程中，容易遇到事务执行时间较长的情况。如果该事务的对应的接口，请求量暴增，由于数据库连接池的限制，大部分请求可能会失败。\n相关代码：https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson009\n7.1 大(长)事务所带来的问题 下面的代码带有 @Transcational 注解， 说明该方法会交给 Spring 来管理该方法的事务。具体执行逻辑如下：\n1、Spring去数据库连接池拿到一个数据库连接 2、开启事务 3、执行bigTransaction()中的代码 4、提交事务 5、将数据库连接还给数据库连接池中 在这个过程中，数据库连接会一直被占用。因为数据库连接时有限的，并且是非常稀缺的资。如果长时间被占用，并且数据库连接池中的可用连接都被占用了，则其他请求无法连接数据库。它会导致连接超时，执行方法失败。例如，下面方法中 this.getData() 方法会占用 5s 的时间。如果 5s 内有 100 条请求并发执行，且数据库连接池最大连接数为 20，超时时间为3s。 则剩余的 80 条请求，都会出现连接失败的现象。\n@Transactional public void bigTransaction() throws InterruptedException { // 1、getData()方法模拟一个比较耗时的获取数据的操作，这个方法内部会休眠5秒 String data = this.getData(); //2、将上面获取到的数据写入到db中 Lesson007PO po = new Lesson007PO(); po.setId(UUID.randomUUID().toString()); po.setData(data); this.lesson007Mapper.insert(po); } public String getData() throws InterruptedException { //休眠5秒 TimeUnit.SECONDS.sleep(5); return UUID.randomUUID().toString(); } 7.2 如何解决大 (长) 事务的问题 (拆分为小事务) 优化方法：将大(长)事务进行拆分，将无需数据库连接的部分拆出来，将事务最小化。 例如，上方的代码中，this.getData() 方法是不需要操作数据库的，只有最后的 insert 方法才需要连接数据库。所以，可以将事务的粒度控制在 insert 方法中。\nTranscationTemplate：Spring中的 TranscationTemplate 工具类能够采用编程式的方案，灵活控制事务的粒度。\n/** * 使用 TransactionTemplate 编程式事务，可以灵活的控制事务的范围 * * @throws InterruptedException */ public void smallTransaction() throws InterruptedException { // 1、调用getData()方法，讲获取的数据写到db中，假设 getData方法比较耗时，比如耗时 5秒 String data = this.getData(); //2、将上面获取到的数据写入到db中 Lesson007PO po = new Lesson007PO(); po.setId(UUID.randomUUID().toString()); po.setData(data); // this.transactionTemplate.executeWithoutResult可以传入一个Consumer，这个Consumer表述需要在事务中执行的业务操作 this.transactionTemplate.executeWithoutResult(action -\u003e { this.lesson007Mapper.insert(po); }); } 【总结】\n控制事务粒度 ：使用 TransactionTemplate 编程式事务，精准控制事务的粒度，尽量让事务小型化 非数据库相关代码，避免出现在事务中：尽量避免将没有事务的耗时操作放到事务代码中；避免在事务中执行远程操作，远程操作是不需要用到本地事务的，所以没有必要放在事务中 事务集中化：尽量让事务的操作集中在一起执行，比如都放到方法最后，使用 TransactionTemplate 执行，这样可使事务最小化 8. 动态线程池 相关代码：https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson009\n8.1 为什么需要动态线程池 平时我们在开发中，创建了不少线程池，这些线程池都处于游离状态，不方便管理和监控。无法知道目前系统中有哪些线程池、以及每个线程池当前的一个状态，负载情况等，所以我们可以开发一个线程池管理器来解决这个问题。\n8.2 线程池管理器 统管系统中所有线程池，负责所有线程池的创建、监控等操作。\npublic class ThreadPoolManager { /** 线程池Map */ private static Map\u003cString, ThreadPoolTaskExecutor\u003e threadPoolMap = new ConcurrentHashMap\u003cString, ThreadPoolTaskExecutor\u003e(16); /** * 创建新的线程池，如果线程池已经创建，返回已经创建的线程池 * * @param name 线程池名称 * @param corePoolSize 核心线程数 * @param maxPoolSize 最大线程数 * @param queueCapacity 队列大小 * @param keepAliveSeconds 线程池存活时间（秒） * @param threadFactory 线程工厂 * @param rejectedExecutionHandler 拒绝策略 * @return */ public static ThreadPoolTaskExecutor newThreadPool(String name, int corePoolSize, int maxPoolSize, int queueCapacity, int keepAliveSeconds, ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler) { return threadPoolMap.computeIfAbsent(name, threadGroupName -\u003e { ThreadPoolTaskExecutor threadPoolExecutor = new ThreadPoolTaskExecutor() { private boolean initialized = false; // 初始化标记 @Override protected BlockingQueue\u003cRunnable\u003e createQueue(int queueCapacity) { if (queueCapacity \u003e 0) { // 使用自定义的 ResizeLinkedBlockingQueue 替代默认队列，保证能够在运行时动态调整队列大小 return new ResizeLinkedBlockingQueue\u003c\u003e(queueCapacity); } else { // 当队列容量设置为0时，使用 SynchronousQueue。表示任务必须立即被线程处理，否则就会被拒绝 return new SynchronousQueue\u003c\u003e(); } } @Override public void setQueueCapacity(int queueCapacity) { // 确保线程池已初始化且队列类型正确时才调整容量 if (this.initialized \u0026\u0026 this.getThreadPoolExecutor() != null \u0026\u0026 this.getThreadPoolExecutor().getQueue() != null \u0026\u0026 this.getThreadPoolExecutor().getQueue() instanceof ResizeLinkedBlockingQueue) { ((ResizeLinkedBlockingQueue) this.getThreadPoolExecutor().getQueue()).setCapacity(queueCapacity); } super.setQueueCapacity(queueCapacity); } @Override public void afterPropertiesSet() { // 使用 initialized 标记确保线程池只被初始化一次 if (initialized) { return; } super.afterPropertiesSet(); this.initialized = true; } }; // 设置参数 threadPoolExecutor.setCorePoolSize(corePoolSize); ... if (threadFactory != null) { // ThreadFactory相当于线程池的一些规定 (招聘标准) threadPoolExecutor.setThreadFactory(threadFactory); } if (rejectedExecutionHandler != null) { // 拒绝执行的策略，上方提到的四种拒绝策略 threadPoolExecutor.setRejectedExecutionHandler(rejectedExecutionHandler); } threadPoolExecutor.afterPropertiesSet(); return threadPoolExecutor; }); } /** 获取所有线程池信息 */ public static List\u003cThreadPoolInfo\u003e threadPoolInfoList() { return threadPoolMap .entrySet() .stream() .map(entry -\u003e threadPoolInfo(entry.getKey(), entry.getValue())) .collect(Collectors.toList()); } } 8.3 动态线程池 动态线程池：无需重启的情况下，可以对线程池进行扩缩容，比如改变线程池的核心线程数量、最大线程数量、队列容量等。\n8.3.1 常用动态线程池 dynamic-tp：https://github.com/dromara/dynamic-tp\n8.3.2 手动实现动态线程池 线程池中会用到Java中的阻塞队列 java.util.concurrent.BlockingQueue，目前 jdk中自带几个阻塞队列都不支持动态扩容。 比如 java.util.concurrent.LinkedBlockingQueue，它的 capacity 是 final 修饰的，不支持修改。\n动态调整大小的前提：动态调整线程池大小需要队列容量能够支持调整，我们需要创建可扩容的阻塞队列 ResizeLinkedBlockingQueue。代码是从LinkedBlockingQueue 中拷贝过来的，增加可修改容量 的setCapacity 方法。然后创建线程池的时，使用自定义的阻塞队列便可以实现线程池的动态扩容。\n/** * 设置容量 * @param capacity */ public void setCapacity(int capacity) { if (capacity \u003c= 0) throw new IllegalArgumentException(); final ReentrantLock putLock = this.putLock; putLock.lock(); try { if (count.get() \u003e capacity) { throw new IllegalArgumentException(); } this.capacity = capacity; } finally { putLock.unlock(); } } 动态更改线程池大小的方法如下所示：\npublic class ThreadPoolManager { /** * 动态变更线程池（如：扩缩容、扩缩队列大小） * @param threadPoolChange 变更线程池信息 */ public static void changeThreadPool(ThreadPoolChange threadPoolChange) { ThreadPoolTaskExecutor threadPoolTaskExecutor = threadPoolMap.get(threadPoolChange.getName()); if (threadPoolTaskExecutor == null) { throw new IllegalArgumentException(); } if (threadPoolChange.getCorePoolSize() \u003e threadPoolChange.getMaxPoolSize()) { throw new IllegalArgumentException(); } synchronized (ThreadPoolManager.class) { // 增加线程情况：需要修改的最大线程大于当前核心线程，则设置当前核心线程为修改后的最大线程 if (threadPoolChange.getMaxPoolSize() \u003e threadPoolTaskExecutor.getCorePoolSize()) { // 先调整最大线程数，再调整核心数 （先扩大总量，再扩大局部） threadPoolTaskExecutor.setMaxPoolSize(threadPoolChange.getMaxPoolSize()); threadPoolTaskExecutor.setCorePoolSize(threadPoolChange.getCorePoolSize()); threadPoolTaskExecutor.setQueueCapacity(threadPoolChange.getQueueCapacity()); } else { // 先减少局部，再减少总量 threadPoolTaskExecutor.setCorePoolSize(threadPoolChange.getCorePoolSize()); threadPoolTaskExecutor.setMaxPoolSize(threadPoolChange.getMaxPoolSize()); threadPoolTaskExecutor.setQueueCapacity(threadPoolChange.getQueueCapacity()); } } } } 分布式与微服务 1. SpringBoot实现动态Job的实战 相关代码：https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson011\n1.1 Job表 - 表结构 字段名 类型 可空 默认 备注 id varchar(50) 否 - id，主键 name varchar(100) 否 - job名称，可以定义一个有意义的名称 cron varchar(50) 否 - job的执行周期，cron表达式 bean_name varchar(100) 否 - job需要执行那个bean，对应spring中bean的名称 bean_method varchar(100) 否 - job执行的bean的方法 status smallint 否 0 job的状态,0：停止，1：执行中 1.2 Job执行管理器 @Component public class SpringJobRunManager implements CommandLineRunner { // applicationContext 主要用于在任务执行时动态获取和调用指定的 Bean 和方法，实现灵活的任务调度。 // 可以把它理解为“Spring 管理的对象工厂和服务总线” @Autowired private ApplicationContext applicationContext; // threadPoolTaskScheduler 是 Spring 提供的线程池定时任务调度器，主要用于在应用中以多线程方式执行定时任务（如定时执行、Cron表达式调度等） @Autowired private ThreadPoolTaskScheduler threadPoolTaskScheduler; // job表相关服务 @Autowired private JobService jobService; /** * 系统重正在运行中的job列表 */ private Map\u003cString, SpringJobTask\u003e runningJobMap = new ConcurrentHashMap\u003c\u003e(); /** * springboot应用启动后会回调 * * @param args incoming main method arguments * @throws Exception */ @Override public void run(String... args) throws Exception { //1、启动job this.startAllJob(); //2、监控db中job的变化（job增、删、改），然后同步给job执行器去执行 this.monitorDbJobChange(); } } Springboot应用启动之后会回调 CommandLineRunner 中的 run 方法，依次启动job，并监控job中的变化。\n1.2.1 启动job 启动job的方式比较简单，就是从数据库中找出所有需要启动的job（状态为start），然后循环启动。\n启动job具体方式如下：\nprivate void startAllJob() { List\u003cJob\u003e jobList = this.jobService.getStartJobList(); for (Job job : jobList) { this.startJob(job); } } /** * 启动一个定时任务（job） * * @param job 需要启动的任务对象 */ private void startJob(Job job) { // 1. 创建任务执行体，注入Spring上下文，便于任务内获取Bean对象 SpringJobTask springJobTask = new SpringJobTask(job, this.applicationContext); // 2. 根据job的cron表达式创建调度触发器 CronTrigger trigger = new CronTrigger(job.getCron()); // 3. 使用线程池调度器注册任务，返回调度句柄 ScheduledFuture\u003c?\u003e scheduledFuture = this.threadPoolTaskScheduler.schedule(springJobTask, trigger); // 4. 记录调度句柄到任务对象，便于后续取消 -\u003e springJobTask.setScheduledFuture(scheduledFuture); // 5. 将任务放入运行中的任务Map，方便管理和查找 runningJobMap.put(job.getId(), springJobTask); // 6. 记录日志，方便追踪 logger.info(\"启动 job 成功:{}\", JSONUtil.toJsonStr(job)); } /** * 删除（停止）一个定时任务 * @param job 需要删除的任务对象 */ private void deleteJob(Job job) { if (job == null) { return; } // 1. 从运行中的任务Map获取任务 SpringJobTask springJobTask = this.runningJobMap.get(job.getId()); if (springJobTask == null) { return;} // 2. 取消任务调度（停止定时执行） springJobTask.getScheduledFuture().cancel(false); // 3. 从Map中移除该任务 runningJobMap.remove(job.getId()); // 4. 记录日志 logger.info(\"移除 job 成功:{}\", JSONUtil.toJsonStr(job)); } /** * 更新一个定时任务（先删除再启动） * @param job 需要更新的任务对象 */ public void updateJob(Job job) { // 1. 先删除旧的任务 this.deleteJob(job); // 2. 再启动新的任务 this.startJob(job); // 3. 记录日志 logger.info(\"更新 job 成功:{}\", JSONUtil.toJsonStr(job)); } 1.2.2 动态监控DB中job的变化 /** * 监控db中job的变化，每5秒监控一次，这个频率大家使用的时候可以稍微调大点 */ private void monitorDbJobChange() { this.threadPoolTaskScheduler.scheduleWithFixedDelay(this::jobChangeDispose, Duration.ofSeconds(5)); } // 任务变化处理 private void jobChangeDispose() { //1、从db中拿到所有job，和目前内存中正在运行的所有job对比，可得到本次新增的job、删除的job、更新的job JobChange jobChange = this.getJobChange(); //2、处理新增的job for (Job job : jobChange.getAddJobList()) { this.startJob(job);} //3、处理删除的job for (Job job : jobChange.getDeleteJobList()) { this.deleteJob(job);} //4、处理变化的job for (Job job : jobChange.getUpdateJobList()) { this.updateJob(job);} } private JobChange getJobChange() { //新增的job List\u003cJob\u003e addJobList = new ArrayList\u003c\u003e(); //删除的job List\u003cJob\u003e deleteJobList = new ArrayList\u003c\u003e(); //更新的job List\u003cJob\u003e updateJobList = new ArrayList\u003c\u003e(); //从db中拿到所有job，和目前内存中正在运行的所有job对比，可得到本次新增的job、删除的job、更新的job List\u003cJob\u003e startJobList = this.jobService.getStartJobList(); for (Job job : startJobList) { SpringJobTask springJobTask = runningJobMap.get(job.getId()); if (springJobTask == null) { addJobList.add(job); } else { //job的执行规则变了 if (jobIsChange(job, springJobTask.getJob())) { updateJobList.add(job); } } } //获取被删除的job，springJobTaskMap中存在的，而startJobList不存在的，则是需要从当前运行列表中停止移除的 Set\u003cString\u003e startJobIdList = CollUtils.convertSet(startJobList, Job::getId); for (Map.Entry\u003cString, SpringJobTask\u003e springJobTaskEntry : runningJobMap.entrySet()) { if (!startJobIdList.contains(springJobTaskEntry.getKey())) { deleteJobList.add(springJobTaskEntry.getValue().getJob()); } } //返回job变更结果 return new JobChange(addJobList, updateJobList, deleteJobList); } /** * 检测两个job是否发生了变化，（cron、beanName、beanMethod）中有任意一项变动了，则返回true * * @param job1 * @param job2 * @return */ private boolean jobIsChange(Job job1, Job job2) { return !(Objects.equals(job1.getCron(), job2.getCron()) \u0026\u0026 Objects.equals(job1.getBeanName(), job2.getBeanName()) \u0026\u0026 Objects.equals(job1.getBeanMethod(), job2.getBeanMethod())); } ",
  "wordCount" : "2159",
  "inLanguage": "en",
  "image": "https://swimmingliu.cn/papermod-cover.png","datePublished": "2025-07-06T13:27:35+08:00",
  "dateModified": "2025-07-06T13:27:35+08:00",
  "author":[{
    "@type": "Person",
    "name": "SwimmingLiu"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://swimmingliu.cn/posts/job/java-scene-quiz-100/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "SwimmingLiu's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://swimmingliu.cn/images/swimmingliu_icon.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://swimmingliu.cn/" accesskey="h" title="𝓢𝔀𝓲𝓶𝓶𝓲𝓷𝓰𝓛𝓲𝓾&#39;𝓼 𝓑𝓵𝓸𝓰 (Alt + H)">
                <img src="https://swimmingliu.cn/images/swimmingliu_icon.png" alt="" aria-label="logo"
                    height="30">𝓢𝔀𝓲𝓶𝓶𝓲𝓷𝓰𝓛𝓲𝓾&#39;𝓼 𝓑𝓵𝓸𝓰</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://swimmingliu.cn/index.html" title="🏡 Home">
                    <span>🏡 Home</span>
                </a>
            </li>
            <li>
                <a href="https://swimmingliu.cn/search/" title="🔍 Search">
                    <span>🔍 Search</span>
                </a>
            </li>
            <li>
                <a href="https://swimmingliu.cn/posts/" title="🗒️ Posts">
                    <span>🗒️ Posts</span>
                </a>
            </li>
            <li>
                <a href="https://swimmingliu.cn/archives/" title="📃 Archive">
                    <span>📃 Archive</span>
                </a>
            </li>
            <li>
                <a href="https://swimmingliu.cn/tags/" title="📑 Tags">
                    <span>📑 Tags</span>
                </a>
            </li>
            <li>
                <a href="https://bento.me/swimmingliu" title="👨🏻‍🎓 About Me">
                    <span>👨🏻‍🎓 About Me</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
            <li>
                <a href="https://www.emojisearch.app/" title="Emoji">
                    <span>Emoji</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://swimmingliu.cn/">Home</a>&nbsp;»&nbsp;<a href="https://swimmingliu.cn/posts/">📚 Posts</a>&nbsp;»&nbsp;<a href="https://swimmingliu.cn/posts/job/">💻 Job</a></div>
    <h1 class="post-title entry-hint-parent">
      Java场景100题
    </h1>
    <div class="post-meta"><span title='2025-07-06 13:27:35 +0800 CST'>July 6, 2025</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;SwimmingLiu

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%b9%b6%e5%8f%91%e4%b8%8e%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96" aria-label="并发与性能优化">并发与性能优化</a><ul>
                        
                <li>
                    <a href="#1-%e5%a4%a7%e6%96%87%e4%bb%b6%e4%b8%8a%e4%bc%a0%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86%e5%88%86%e7%89%87%e4%b8%8a%e4%bc%a0" aria-label="1. 大文件上传如何处理？分片上传">1. 大文件上传如何处理？分片上传</a><ul>
                        
                <li>
                    <a href="#11-%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%88%86%e7%89%87%e4%b8%8a%e4%bc%a0" aria-label="1.1 为什么需要分片上传?">1.1 为什么需要分片上传?</a></li>
                <li>
                    <a href="#12-%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%88%86%e7%89%87%e4%b8%8a%e4%bc%a0" aria-label="1.2 如何实现分片上传？">1.2 如何实现分片上传？</a><ul>
                        
                <li>
                    <a href="#121-%e5%a6%82%e4%bd%95%e5%ad%98%e5%82%a8%e5%88%86%e7%89%87%e4%bf%a1%e6%81%af" aria-label="1.2.1 如何存储分片信息">1.2.1 如何存储分片信息</a></li>
                <li>
                    <a href="#122-%e5%a6%82%e4%bd%95%e5%ae%9a%e4%b9%89%e5%88%86%e5%9d%97%e4%b8%8a%e4%bc%a0%e6%8e%a5%e5%8f%a3" aria-label="1.2.2 如何定义分块上传接口">1.2.2 如何定义分块上传接口</a></li></ul>
                </li>
                <li>
                    <a href="#13-%e5%a6%82%e6%9e%9c%e4%b8%8a%e4%bc%a0%e8%bf%87%e7%a8%8b%e4%b8%ad%e5%87%ba%e7%8e%b0%e6%95%85%e9%9a%9c%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86" aria-label="1.3 如果上传过程中，出现故障如何处理？">1.3 如果上传过程中，出现故障如何处理？</a><ul>
                        
                <li>
                    <a href="#%e6%83%85%e5%86%b51%e6%b5%8f%e8%a7%88%e5%99%a8%e6%97%a0%e6%b3%95%e8%af%bb%e5%8f%96%e5%88%9a%e6%89%8d%e7%94%a8%e6%88%b7%e9%80%89%e6%8b%a9%e7%9a%84%e6%96%87%e4%bb%b6%e4%ba%86" aria-label="情况1：浏览器无法读取刚才用户选择的文件了">情况1：浏览器无法读取刚才用户选择的文件了</a></li>
                <li>
                    <a href="#%e6%83%85%e5%86%b52%e6%b5%8f%e8%a7%88%e5%99%a8%e5%8f%af%e4%bb%a5%e7%bb%a7%e7%bb%ad%e8%af%bb%e5%8f%96%e5%88%9a%e6%89%8d%e7%94%a8%e6%88%b7%e9%80%89%e6%8b%a9%e7%9a%84%e6%96%87%e4%bb%b6" aria-label="情况2：浏览器可以继续读取刚才用户选择的文件">情况2：浏览器可以继续读取刚才用户选择的文件</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#2-%e5%a4%9a%e7%ba%bf%e7%a8%8b%e4%bb%bb%e5%8a%a1%e6%89%b9%e5%a4%84%e7%90%86%e9%80%9a%e7%94%a8%e5%b7%a5%e5%85%b7%e7%b1%bb" aria-label="2. 多线程任务批处理通用工具类">2. 多线程任务批处理通用工具类</a></li>
                <li>
                    <a href="#3-%e6%8e%a5%e5%8f%a3%e6%80%a7%e8%83%bd%e5%8e%8b%e5%8a%9b%e6%b5%8b%e8%af%95%e5%b7%a5%e5%85%b7" aria-label="3. 接口性能压力测试工具">3. 接口性能压力测试工具</a><ul>
                        
                <li>
                    <a href="#31-%e5%b8%b8%e7%94%a8%e5%8e%8b%e6%b5%8b%e5%b7%a5%e5%85%b7%e7%b1%bb" aria-label="3.1 常用压测工具类">3.1 常用压测工具类</a></li>
                <li>
                    <a href="#32-%e6%89%8b%e5%86%99%e5%8e%8b%e6%b5%8b%e5%b7%a5%e5%85%b7%e7%b1%bb" aria-label="3.2 手写压测工具类">3.2 手写压测工具类</a></li></ul>
                </li>
                <li>
                    <a href="#4-semaphore%e5%ae%9e%e7%8e%b0%e6%8e%a5%e5%8f%a3%e9%99%90%e6%b5%81" aria-label="4. Semaphore实现接口限流">4. Semaphore实现接口限流</a></li>
                <li>
                    <a href="#5-%e5%b9%b6%e8%a1%8c%e6%9f%a5%e8%af%a2---%e6%8f%90%e4%ba%a4%e6%8e%a5%e5%8f%a3%e5%93%8d%e5%ba%94%e9%80%9f%e5%ba%a6" aria-label="5. 并行查询 - 提交接口响应速度">5. 并行查询 - 提交接口响应速度</a><ul>
                        
                <li>
                    <a href="#51--%e5%b8%b8%e8%a7%84%e5%81%9a%e6%b3%95" aria-label="5.1  常规做法">5.1  常规做法</a></li>
                <li>
                    <a href="#52-%e4%bd%bf%e7%94%a8%e7%ba%bf%e7%a8%8b%e6%b1%a0%e5%b9%b6%e8%a1%8c%e6%9f%a5%e8%af%a2%e5%95%86%e5%93%81%e4%bf%a1%e6%81%af" aria-label="5.2 使用线程池并行查询商品信息">5.2 使用线程池并行查询商品信息</a></li></ul>
                </li>
                <li>
                    <a href="#6-%e5%b9%b6%e8%a1%8c%e6%9f%a5%e8%af%a2%e5%8f%af%e8%83%bd%e5%ad%98%e5%9c%a8%e7%9a%84%e9%97%ae%e9%a2%98%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3" aria-label="6. 并行查询可能存在的问题？如何解决？">6. 并行查询可能存在的问题？如何解决？</a><ul>
                        
                <li>
                    <a href="#61-%e5%b9%b6%e8%a1%8c%e6%9f%a5%e8%af%a2%e4%b8%ad%e5%ad%98%e5%9c%a8%e7%9a%84%e9%97%ae%e9%a2%98" aria-label="6.1 并行查询中存在的问题">6.1 并行查询中存在的问题</a></li>
                <li>
                    <a href="#62-%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e5%b9%b6%e8%a1%8c%e6%9f%a5%e8%af%a2%e7%9a%84%e9%97%ae%e9%a2%98" aria-label="6.2 如何解决并行查询的问题">6.2 如何解决并行查询的问题</a></li></ul>
                </li>
                <li>
                    <a href="#7-%e6%8e%a5%e5%8f%a3%e6%80%a7%e8%83%bd%e8%b0%83%e4%bc%98%e4%b9%8b%e5%a4%a7-%e9%95%bf-%e4%ba%8b%e5%8a%a1%e4%bc%98%e5%8c%96" aria-label="7. 接口性能调优之大 (长) 事务优化">7. 接口性能调优之大 (长) 事务优化</a><ul>
                        
                <li>
                    <a href="#71-%e5%a4%a7%e9%95%bf%e4%ba%8b%e5%8a%a1%e6%89%80%e5%b8%a6%e6%9d%a5%e7%9a%84%e9%97%ae%e9%a2%98" aria-label="7.1 大(长)事务所带来的问题">7.1 大(长)事务所带来的问题</a></li>
                <li>
                    <a href="#72-%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e5%a4%a7-%e9%95%bf-%e4%ba%8b%e5%8a%a1%e7%9a%84%e9%97%ae%e9%a2%98-%e6%8b%86%e5%88%86%e4%b8%ba%e5%b0%8f%e4%ba%8b%e5%8a%a1" aria-label="7.2 如何解决大 (长) 事务的问题 (拆分为小事务)">7.2 如何解决大 (长) 事务的问题 (拆分为小事务)</a></li></ul>
                </li>
                <li>
                    <a href="#8-%e5%8a%a8%e6%80%81%e7%ba%bf%e7%a8%8b%e6%b1%a0" aria-label="8. 动态线程池">8. 动态线程池</a><ul>
                        
                <li>
                    <a href="#81-%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%8a%a8%e6%80%81%e7%ba%bf%e7%a8%8b%e6%b1%a0" aria-label="8.1 为什么需要动态线程池">8.1 为什么需要动态线程池</a></li>
                <li>
                    <a href="#82-%e7%ba%bf%e7%a8%8b%e6%b1%a0%e7%ae%a1%e7%90%86%e5%99%a8" aria-label="8.2 线程池管理器">8.2 线程池管理器</a></li>
                <li>
                    <a href="#83-%e5%8a%a8%e6%80%81%e7%ba%bf%e7%a8%8b%e6%b1%a0" aria-label="8.3 动态线程池">8.3 动态线程池</a><ul>
                        
                <li>
                    <a href="#831-%e5%b8%b8%e7%94%a8%e5%8a%a8%e6%80%81%e7%ba%bf%e7%a8%8b%e6%b1%a0" aria-label="8.3.1 常用动态线程池">8.3.1 常用动态线程池</a></li>
                <li>
                    <a href="#832-%e6%89%8b%e5%8a%a8%e5%ae%9e%e7%8e%b0%e5%8a%a8%e6%80%81%e7%ba%bf%e7%a8%8b%e6%b1%a0" aria-label="8.3.2 手动实现动态线程池">8.3.2 手动实现动态线程池</a></li></ul>
                </li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%88%86%e5%b8%83%e5%bc%8f%e4%b8%8e%e5%be%ae%e6%9c%8d%e5%8a%a1" aria-label="分布式与微服务">分布式与微服务</a><ul>
                        
                <li>
                    <a href="#1-springboot%e5%ae%9e%e7%8e%b0%e5%8a%a8%e6%80%81job%e7%9a%84%e5%ae%9e%e6%88%98" aria-label="1. SpringBoot实现动态Job的实战">1. SpringBoot实现动态Job的实战</a><ul>
                        
                <li>
                    <a href="#11-job%e8%a1%a8---%e8%a1%a8%e7%bb%93%e6%9e%84" aria-label="1.1 Job表 - 表结构">1.1 Job表 - 表结构</a></li>
                <li>
                    <a href="#12-job%e6%89%a7%e8%a1%8c%e7%ae%a1%e7%90%86%e5%99%a8" aria-label="1.2 Job执行管理器">1.2 Job执行管理器</a><ul>
                        
                <li>
                    <a href="#121-%e5%90%af%e5%8a%a8job" aria-label="1.2.1 启动job">1.2.1 启动job</a></li>
                <li>
                    <a href="#122-%e5%8a%a8%e6%80%81%e7%9b%91%e6%8e%a7db%e4%b8%adjob%e7%9a%84%e5%8f%98%e5%8c%96" aria-label="1.2.2 动态监控DB中job的变化">1.2.2 动态监控DB中job的变化</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>
  <div class="post-content"><h1 id="并发与性能优化">并发与性能优化<a hidden class="anchor" aria-hidden="true" href="#并发与性能优化">#</a></h1>
<h2 id="1-大文件上传如何处理分片上传">1. 大文件上传如何处理？分片上传<a hidden class="anchor" aria-hidden="true" href="#1-大文件上传如何处理分片上传">#</a></h2>
<p>相关代码：<a href="https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson001">https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson001</a></p>
<h3 id="11-为什么需要分片上传">1.1 为什么需要分片上传?<a hidden class="anchor" aria-hidden="true" href="#11-为什么需要分片上传">#</a></h3>
<p>大文件在上传的过程中，耗费的时间比较长。如果网络不稳定，很可能导致上传失败，需要重新上传。分片上传，就可以解决这个问题。</p>
<p><strong>分片上传定义</strong>：将大文件拆分为不同的文件块，逐块进行上传</p>
<h3 id="12-如何实现分片上传">1.2 如何实现分片上传？<a hidden class="anchor" aria-hidden="true" href="#12-如何实现分片上传">#</a></h3>
<h4 id="121-如何存储分片信息">1.2.1 如何存储分片信息<a hidden class="anchor" aria-hidden="true" href="#121-如何存储分片信息">#</a></h4>
<p>分片上传需要记录文件的属性 (md5、大小、名称)、分片数量、文件存储的完整路径 (本地路径)，还需要记录每个分块的上传情况 (分块大小、分块顺序、分块任务id)。可以用 <strong>分块上传任务表</strong> 和 <strong>分块文件表</strong> 来记录。</p>
<ol>
<li>
<p><strong>分块任务表 (t_shard_upload)</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">create</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="k">exists</span><span class="w"> </span><span class="n">t_shard_upload</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="nb">varchar</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="k">primary</span><span class="w"> </span><span class="k">key</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">file_name</span><span class="w"> </span><span class="nb">varchar</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="k">null</span><span class="w"> </span><span class="k">comment</span><span class="w"> </span><span class="s1">&#39;文件名称&#39;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">part_num</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="k">null</span><span class="w"> </span><span class="k">comment</span><span class="w"> </span><span class="s1">&#39;分片数量&#39;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">md5</span><span class="w"> </span><span class="nb">varchar</span><span class="p">(</span><span class="mi">128</span><span class="p">)</span><span class="w"> </span><span class="k">comment</span><span class="w"> </span><span class="s1">&#39;文件md5值&#39;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">file_full_path</span><span class="w"> </span><span class="nb">varchar</span><span class="p">(</span><span class="mi">512</span><span class="p">)</span><span class="w"> </span><span class="k">comment</span><span class="w"> </span><span class="s1">&#39;文件完整路径&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">)</span><span class="w"> </span><span class="k">comment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;分片上传任务表&#39;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p><strong>分块文件表 (t_shard_upload_part）</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">create</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="k">exists</span><span class="w">  </span><span class="n">t_shard_upload_part</span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="nb">varchar</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="k">primary</span><span class="w"> </span><span class="k">key</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">shard_upload_id</span><span class="w"> </span><span class="nb">varchar</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="k">null</span><span class="w"> </span><span class="k">comment</span><span class="w"> </span><span class="s1">&#39;分片任务id（t_shard_upload.id）&#39;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">part_order</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="k">null</span><span class="w"> </span><span class="k">comment</span><span class="w"> </span><span class="s1">&#39;第几个分片，从1开始&#39;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">file_full_path</span><span class="w"> </span><span class="nb">varchar</span><span class="p">(</span><span class="mi">512</span><span class="p">)</span><span class="w"> </span><span class="k">comment</span><span class="w"> </span><span class="s1">&#39;文件完整路径&#39;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">UNIQUE</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="o">`</span><span class="n">uq_part_order</span><span class="o">`</span><span class="w"> </span><span class="p">(</span><span class="o">`</span><span class="n">shard_upload_id</span><span class="o">`</span><span class="p">,</span><span class="o">`</span><span class="n">part_order</span><span class="o">`</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">)</span><span class="w"> </span><span class="k">comment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;分片文件表，每个分片文件对应一条记录&#39;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div></li>
</ol>
<p>分块文件表和分块上传表是 <strong>1 to M</strong> 的关系，假如当前文件分为<strong>10</strong>块。则会出现<strong>1</strong>个分片上传任务，和<strong>10</strong>个分片文件记录。</p>
<h4 id="122-如何定义分块上传接口">1.2.2 如何定义分块上传接口<a hidden class="anchor" aria-hidden="true" href="#122-如何定义分块上传接口">#</a></h4>
<p>分块上传可以分为下面 5 个接口</p>
<ol>
<li>**创建分片上传任务接口 ** (<code>/shardUpload/init</code>)
<ul>
<li>入参：文件名称、文件大小、文件md5</li>
<li>出参：任务id、分片数量</li>
<li>实现：计算分片数量，创建分片任务</li>
</ul>
</li>
<li><strong>上传分片文件</strong> (<code>/shardUpload/uploadPart</code>)
<ul>
<li>入参：MultiPartFile 文件</li>
<li>出参 ：分片文件记录id、任务id</li>
<li>实现：存入文件到磁盘自动位置，创建分片文件记录</li>
</ul>
</li>
<li>合并分片、完成上传 (<code>/shardUpload/complete</code>)
<ul>
<li>入参：任务id</li>
<li>出参：布尔值</li>
<li>实现：按照顺序合并所有二进制文件</li>
</ul>
</li>
<li>获取分片任务详细信息(<code>/shardUpload/detail</code>)
<ul>
<li>入参：任务id 、文件md5 (二选一)</li>
<li>出参：任务进度、文件名称、文件md5</li>
<li>实现：读取分片文件表查看上传情况</li>
<li>功能：获取分片任务的状态信息，如分片任务是否上传完毕，哪些分片已上传等信息，网络出现故障，可以借助此接口恢复上传</li>
</ul>
</li>
</ol>
<h3 id="13-如果上传过程中出现故障如何处理">1.3 如果上传过程中，出现故障如何处理？<a hidden class="anchor" aria-hidden="true" href="#13-如果上传过程中出现故障如何处理">#</a></h3>
<h4 id="情况1浏览器无法读取刚才用户选择的文件了">情况1：浏览器无法读取刚才用户选择的文件了<a hidden class="anchor" aria-hidden="true" href="#情况1浏览器无法读取刚才用户选择的文件了">#</a></h4>
<p>此时需要用户重新选择文件，重新上传。这个地方也可以给大家提供另外一种思路，第1个接口创建分片任务的时候传入了文件的md5，按说这个值是具有唯一性的，那么就可以通过这个值找到刚才的任务，按照这种思路，就需要后端提供一个新的接口：通过文件的md5值找到刚才失败的那个任务，然后继续上传未上传的分片。</p>
<h4 id="情况2浏览器可以继续读取刚才用户选择的文件">情况2：浏览器可以继续读取刚才用户选择的文件<a hidden class="anchor" aria-hidden="true" href="#情况2浏览器可以继续读取刚才用户选择的文件">#</a></h4>
<p>这种情况，可以先调用第4个接口，通过此接口可以知道那些分片还未上传，然后继续上传这些分片就可以了。</p>
<h2 id="2-多线程任务批处理通用工具类">2. 多线程任务批处理通用工具类<a hidden class="anchor" aria-hidden="true" href="#2-多线程任务批处理通用工具类">#</a></h2>
<p>相关代码：<a href="https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson002">https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson002</a></p>
<blockquote>
<p>使用线程池批量发送短信，当短信发送完毕之后，记录耗时情况
<strong>【主要知识点】</strong></p></blockquote>
<ul>
<li>CountDownLatch：如果想要等异步线程执行之后，再继续回到原方法中，可以使用CountDownLatch</li>
<li>Executors：用于创建线程池，重写 <code>executor.execute</code> 中的 <code>Runnable</code> 方法，可实现异步执行线程</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">TaskDisposeUtils</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 使用线程池批处理文件，当所有任务处理完毕后才会返回
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param taskList 任务列表
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param consumer 处理任务的方法
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param executor 线程池
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param &lt;T&gt;
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @throws InterruptedException
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">dispose</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">taskList</span><span class="p">,</span><span class="w"> </span><span class="n">Consumer</span><span class="o">&lt;?</span><span class="w"> </span><span class="kd">super</span><span class="w"> </span><span class="n">T</span><span class="o">&gt;</span><span class="w"> </span><span class="n">consumer</span><span class="p">,</span><span class="w"> </span><span class="n">Executor</span><span class="w"> </span><span class="n">executor</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">InterruptedException</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">taskList</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">taskList</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">()</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">consumer</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">CountDownLatch</span><span class="w"> </span><span class="n">latch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">CountDownLatch</span><span class="p">(</span><span class="n">taskList</span><span class="p">.</span><span class="na">size</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">T</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">taskList</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">executor</span><span class="p">.</span><span class="na">execute</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">consumer</span><span class="p">.</span><span class="na">accept</span><span class="p">(</span><span class="n">item</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="n">latch</span><span class="p">.</span><span class="na">countDown</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">latch</span><span class="p">.</span><span class="na">await</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">InterruptedException</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="n">startTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="na">currentTimeMillis</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">List</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">taskList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">List</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="s">&#34;短信-1&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;短信-2&#34;</span><span class="p">,</span><span class="w"> </span><span class="s">&#34;短信-3&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">ExecutorService</span><span class="w"> </span><span class="n">executor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Executors</span><span class="p">.</span><span class="na">newFixedThreadPool</span><span class="p">(</span><span class="n">10</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">dispose</span><span class="p">(</span><span class="n">taskList</span><span class="p">,</span><span class="w"> </span><span class="n">TaskDisposeUtils</span><span class="p">::</span><span class="n">doTask</span><span class="p">,</span><span class="w"> </span><span class="n">executor</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">       </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;任务处理完毕,耗时(ms):&#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="na">currentTimeMillis</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">startTime</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">executor</span><span class="p">.</span><span class="na">shutdown</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">doTask</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">task</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">task</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34;发送成功&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">SECONDS</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="n">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">interrupt</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h2 id="3-接口性能压力测试工具">3. 接口性能压力测试工具<a hidden class="anchor" aria-hidden="true" href="#3-接口性能压力测试工具">#</a></h2>
<p>相关代码：<a href="https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson003">https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson003</a></p>
<h3 id="31-常用压测工具类">3.1 常用压测工具类<a hidden class="anchor" aria-hidden="true" href="#31-常用压测工具类">#</a></h3>
<p><a href="https://jmeter.apache.org/">Jemeter</a> 、<a href="https://blog.csdn.net/light2081/article/details/131175276">LoadRunner</a>、ApiFox - 自动化测试</p>
<p>【注意】LoadRunner 只有window可以用</p>
<h3 id="32-手写压测工具类">3.2 手写压测工具类<a hidden class="anchor" aria-hidden="true" href="#32-手写压测工具类">#</a></h3>
<p>【主要知识点】</p>
<ul>
<li>
<p><strong>为什么 <code>updateFastestTime</code> 方法需要使用循环而不是直接 <code>compareAndSet</code></strong> ：因为直接使用 <code>compareAndSet</code> 会出现线程不安全的情况，比如下面的情况</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 错误的做法（非线程安全）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kt">int</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fastestCostTime</span><span class="p">.</span><span class="na">get</span><span class="p">();</span><span class="w">  </span><span class="c1">// 线程A读取到值100</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">current</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">costTime</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">             </span><span class="c1">// 线程A判断100 &gt; 30，准备更新</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 此时线程B也读取到100，也判断100 &gt; 50，也准备更新</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">fastestCostTime</span><span class="p">.</span><span class="na">set</span><span class="p">(</span><span class="n">costTime</span><span class="p">);</span><span class="w">    </span><span class="c1">// 线程A设置为30</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 线程B设置为50，覆盖了线程A的结果 (最小时间应该是30s)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 使用while循环保证线程安全 （其实就是CAS）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="kc">true</span><span class="p">){</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">fsCostTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fastestCostTime</span><span class="p">.</span><span class="na">get</span><span class="p">();</span><span class="w">  </span><span class="c1">// 线程A读取到100</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">// 线程B此时将值改为90</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">fastestCostTime</span><span class="p">.</span><span class="na">compareAndSet</span><span class="p">(</span><span class="n">fsCostTime</span><span class="p">,</span><span class="w"> </span><span class="n">costTime</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// 线程A尝试将100改为50</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="c1">// 失败！因为当前值已经是90，不等于预期的100</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="k">break</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">// 继续循环，重新获取最新值90，再次尝试</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p><strong>线程池参数</strong>：数依次为 <code>coolPoolSize</code> 、<code>maxPoolSize</code>、<code>keepAliveTime</code>、<code>TimeUnit</code>、<code>waitQueue</code> 等待队列</p>
</li>
<li>
<p><strong>为什么线程需要预热</strong>：预热是为了避免线程创建时带来的额外开销，如果不预热，很可能前 <code>100</code> 个核心线程需要多消耗 <code>10~50 ms</code> 来创建线程</p>
</li>
<li>
<p><strong>AtomicInteger</strong>：防止多线程修改同一数据时，出现线程不安全的情况</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="c1">// 普通Integer的问题</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kt">int</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">counter</span><span class="p">;</span><span class="w">     </span><span class="c1">// 1. 读取</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">value</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">1</span><span class="p">;</span><span class="w">       </span><span class="c1">// 2. 修改</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">value</span><span class="p">;</span><span class="w">         </span><span class="c1">// 3. 写入</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 这三步不是原子的，可能被其他线程中断</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// AtomicInteger采用CAS + volatile 保证原子性</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">atomicCounter</span><span class="p">.</span><span class="na">incrementAndGet</span><span class="p">();</span><span class="w">  </span><span class="c1">// 原子操作</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p><code>volatile</code> 关键字在<code>AtomicInteger</code>作用：<code>volatile</code> 就像是给变量贴了个&quot;实时更新&quot;的标签。通过内存可见性和禁止指令重排序来保证实时更新</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-Java" data-lang="Java"><span class="line"><span class="cl"><span class="c1">// 没有volatile的情况</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 线程A修改了count = 100</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 线程B可能还是看到count = 0（因为每个线程都有自己的缓存）</span><span class="w">
</span></span></span></code></pre></div><p>所以，如果 没有<code>volatile</code> 关键字， 没有线程都有自己的&quot;小本本&quot;（CPU缓存，线程私有），可能记录的数据不是最新的。</p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">LoadRunnerUtils</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">class</span> <span class="nc">LoadRunnerResult</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">requests</span><span class="p">;</span><span class="w">           </span><span class="c1">// 请求总数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">concurrency</span><span class="p">;</span><span class="w">        </span><span class="c1">// 并发量</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">successRequests</span><span class="p">;</span><span class="w">    </span><span class="c1">// 成功请求数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">failRequests</span><span class="p">;</span><span class="w">       </span><span class="c1">// 失败请求数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">timeTakenForTests</span><span class="p">;</span><span class="w">  </span><span class="c1">// 请求总耗时(ms)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">private</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">requestsPerSecond</span><span class="p">;</span><span class="w"> </span><span class="c1">// 每秒请求数（吞吐量）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">private</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">timePerRequest</span><span class="p">;</span><span class="w">    </span><span class="c1">// 每个请求平均耗时(ms)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">private</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">fastestCostTime</span><span class="p">;</span><span class="w">   </span><span class="c1">// 最快的请求耗时(ms)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">private</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">slowestCostTime</span><span class="p">;</span><span class="w">   </span><span class="c1">// 最慢的请求耗时(ms)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 执行并发压力测试
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param requests    总请求数
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param concurrency 并发数量
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param command     被测试的代码
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @return 压测结果
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">LoadRunnerResult</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">requests</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">concurrency</span><span class="p">,</span><span class="w"> </span><span class="n">Runnable</span><span class="w"> </span><span class="n">command</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">InterruptedException</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">log</span><span class="p">.</span><span class="na">info</span><span class="p">(</span><span class="s">&#34;压测开始......&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 创建固定大小的线程池，预热所有核心线程</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">ThreadPoolExecutor</span><span class="w"> </span><span class="n">executor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">createThreadPool</span><span class="p">(</span><span class="n">concurrency</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 用于等待所有请求完成的同步器</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">CountDownLatch</span><span class="w"> </span><span class="n">latch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">CountDownLatch</span><span class="p">(</span><span class="n">requests</span><span class="p">);</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 统计数据（使用原子类保证线程安全）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">AtomicInteger</span><span class="w"> </span><span class="n">successCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AtomicInteger</span><span class="p">(</span><span class="n">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">AtomicInteger</span><span class="w"> </span><span class="n">fastestTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AtomicInteger</span><span class="p">(</span><span class="n">Integer</span><span class="p">.</span><span class="na">MAX_VALUE</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">AtomicInteger</span><span class="w"> </span><span class="n">slowestTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">AtomicInteger</span><span class="p">(</span><span class="n">Integer</span><span class="p">.</span><span class="na">MIN_VALUE</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="n">startTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="na">currentTimeMillis</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 提交所有压测任务</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">requests</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">executor</span><span class="p">.</span><span class="na">execute</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">executeRequest</span><span class="p">(</span><span class="n">command</span><span class="p">,</span><span class="w"> </span><span class="n">successCount</span><span class="p">,</span><span class="w"> </span><span class="n">fastestTime</span><span class="p">,</span><span class="w"> </span><span class="n">slowestTime</span><span class="p">,</span><span class="w"> </span><span class="n">latch</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 等待所有请求完成</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">latch</span><span class="p">.</span><span class="na">await</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">executor</span><span class="p">.</span><span class="na">shutdown</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="n">endTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="na">currentTimeMillis</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">log</span><span class="p">.</span><span class="na">info</span><span class="p">(</span><span class="s">&#34;压测结束，总耗时(ms):{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">endTime</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">startTime</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 返回压测结果</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 创建线程池并预热核心线程
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">ThreadPoolExecutor</span><span class="w"> </span><span class="nf">createThreadPool</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">concurrency</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 参数依次为 coolPoolSize、maxPoolSize、keepAliveTime、TimeUnit、等待队列</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">ThreadPoolExecutor</span><span class="w"> </span><span class="n">executor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">concurrency</span><span class="p">,</span><span class="w"> </span><span class="n">concurrency</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">0L</span><span class="p">,</span><span class="w"> </span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">MILLISECONDS</span><span class="p">,</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">LinkedBlockingQueue</span><span class="o">&lt;&gt;</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">executor</span><span class="p">.</span><span class="na">prestartAllCoreThreads</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">executor</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 执行单个请求并统计结果
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">executeRequest</span><span class="p">(</span><span class="n">Runnable</span><span class="w"> </span><span class="n">command</span><span class="p">,</span><span class="w"> </span><span class="n">AtomicInteger</span><span class="w"> </span><span class="n">successCount</span><span class="p">,</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">                                     </span><span class="n">AtomicInteger</span><span class="w"> </span><span class="n">fastestTime</span><span class="p">,</span><span class="w"> </span><span class="n">AtomicInteger</span><span class="w"> </span><span class="n">slowestTime</span><span class="p">,</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">                                     </span><span class="n">CountDownLatch</span><span class="w"> </span><span class="n">latch</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">long</span><span class="w"> </span><span class="n">requestStart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="na">currentTimeMillis</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">command</span><span class="p">.</span><span class="na">run</span><span class="p">();</span><span class="w"> </span><span class="c1">// 执行被测试的方法</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">costTime</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">System</span><span class="p">.</span><span class="na">currentTimeMillis</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">requestStart</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 更新统计数据</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">updateFastestTime</span><span class="p">(</span><span class="n">fastestTime</span><span class="p">,</span><span class="w"> </span><span class="n">costTime</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">updateSlowestTime</span><span class="p">(</span><span class="n">slowestTime</span><span class="p">,</span><span class="w"> </span><span class="n">costTime</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">successCount</span><span class="p">.</span><span class="na">incrementAndGet</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">Exception</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">log</span><span class="p">.</span><span class="na">error</span><span class="p">(</span><span class="s">&#34;请求执行失败: {}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="na">getMessage</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">latch</span><span class="p">.</span><span class="na">countDown</span><span class="p">();</span><span class="w"> </span><span class="c1">// 标记当前请求完成</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 原子更新最快耗时
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">updateFastestTime</span><span class="p">(</span><span class="n">AtomicInteger</span><span class="w"> </span><span class="n">fastestTime</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">costTime</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="kc">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fastestTime</span><span class="p">.</span><span class="na">get</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">current</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">costTime</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">fastestTime</span><span class="p">.</span><span class="na">compareAndSet</span><span class="p">(</span><span class="n">current</span><span class="p">,</span><span class="w"> </span><span class="n">costTime</span><span class="p">))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">break</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h2 id="4-semaphore实现接口限流">4. Semaphore实现接口限流<a hidden class="anchor" aria-hidden="true" href="#4-semaphore实现接口限流">#</a></h2>
<blockquote>
<p>如果后端服务是单体服务，且只部署在一台服务器上，可以采用 <code>Semaphore</code> 信号量的方式实现简单的接口限流机制</p></blockquote>
<p>相关代码：<a href="https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson005">https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson005</a></p>
<p><code>Semaphore</code> : JUC当中对信号量的实现，用于控制同时访问共享资源的线程数量。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">TestController</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * Juc中的Semaphore可以实现限流功能，可以将 Semaphore 想象成停车场入口的大爷，
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 大爷手里面拥有一定数量的停车卡（也可以说是令牌），卡的数量是多少呢？就是Semaphore构造方法中指定的，如下就是50个卡，
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 车主想进去停车，先要从大爷手中拿到一张卡，出来的时候，需要还给大爷，如果拿不到卡，就不能进去停车。
</span></span></span><span class="line"><span class="cl"><span class="cm">     * semaphore 内部提供了获取令牌，和还令牌的一些方法
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">Semaphore</span><span class="w"> </span><span class="n">semaphore</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Semaphore</span><span class="p">(</span><span class="n">50</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 来个案例，下面是一个下单的方法，这个方法最多只允许 50 个并发，若超过50个并发，则进来的请求，最多等待1秒，如果无法获取到令牌，则快速返回失败，请重试
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @return
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@GetMapping</span><span class="p">(</span><span class="s">&#34;/placeOrder&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="nf">placeOrder</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">InterruptedException</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">         * semaphore 在上面定义的，里面有50个令牌，也就是同时可以支持50个并发请求
</span></span></span><span class="line"><span class="cl"><span class="cm">         * 下面的代码，尝试最多等待1秒去获取令牌，获取成功，则进入下单逻辑，获取失败，则返回系统繁忙，请稍后重试
</span></span></span><span class="line"><span class="cl"><span class="cm">         */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">boolean</span><span class="w"> </span><span class="n">flag</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">semaphore</span><span class="p">.</span><span class="na">tryAcquire</span><span class="p">(</span><span class="n">1</span><span class="p">,</span><span class="w"> </span><span class="n">1L</span><span class="p">,</span><span class="w"> </span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">SECONDS</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 获取到令牌，则进入下单逻辑</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">flag</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="c1">//这里休眠2秒，模拟下单的操作</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">SECONDS</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="n">2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="s">&#34;下单成功&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="c1">//这里一定不要漏掉了，令牌用完了，要还回去</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="k">this</span><span class="p">.</span><span class="na">semaphore</span><span class="p">.</span><span class="na">release</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="s">&#34;系统繁忙，请稍后重试&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h2 id="5-并行查询---提交接口响应速度">5. 并行查询 - 提交接口响应速度<a hidden class="anchor" aria-hidden="true" href="#5-并行查询---提交接口响应速度">#</a></h2>
<blockquote>
<p>需求分析：当前接口需要实现下面的功能</p>
<p>接收一个商品id，需要返回商品下面这些信息，这些信息都在不同的表中，通过商品id就可以查到</p>
<ul>
<li>商品基本信息（如商品名称、价格等基本信息)</li>
<li>商品描述信息（可能是富文本，放在单独的表中）</li>
<li>商品收藏量</li>
<li>商品评论量</li>
</ul></blockquote>
<p>相关代码：<a href="https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson006">https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson006</a></p>
<h3 id="51--常规做法">5.1  常规做法<a hidden class="anchor" aria-hidden="true" href="#51--常规做法">#</a></h3>
<p>按照商品 <code>id</code> 分别查询不同的数据库，在JVM内存中对结果进行组装。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">GoodsController</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 根据商品id获取商品信息(基本信息、描述信息、评论量，收藏量)
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param goodsId 商品id
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @return
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @throws InterruptedException
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@GetMapping</span><span class="p">(</span><span class="s">&#34;/getGoodsDetail&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">GoodsDetailResponse</span><span class="w"> </span><span class="nf">getGoodsDetail</span><span class="p">(</span><span class="nd">@RequestParam</span><span class="p">(</span><span class="s">&#34;goodsId&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">goodsId</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="n">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="na">currentTimeMillis</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">GoodsDetailResponse</span><span class="w"> </span><span class="n">goodsDetailResponse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">GoodsDetailResponse</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 1、获取商品基本信息，耗时100ms</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">goodsDetailResponse</span><span class="p">.</span><span class="na">setGoodsInfo</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">getGoodsInfo</span><span class="p">(</span><span class="n">goodsId</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//2、获取商品描述信息，耗时100ms</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">goodsDetailResponse</span><span class="p">.</span><span class="na">setGoodsDescription</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">getGoodsDescription</span><span class="p">(</span><span class="n">goodsId</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//3、获取商品评论量，耗时100ms</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">goodsDetailResponse</span><span class="p">.</span><span class="na">setCommentCount</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">getGoodsCommentCount</span><span class="p">(</span><span class="n">goodsId</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//4、获取商品收藏量，耗时100ms</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">goodsDetailResponse</span><span class="p">.</span><span class="na">setFavoriteCount</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">getGoodsFavoriteCount</span><span class="p">(</span><span class="n">goodsId</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 总耗时为500ms左右</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">LOGGER</span><span class="p">.</span><span class="na">info</span><span class="p">(</span><span class="s">&#34;获取商品信息，普通版耗时：{} ms&#34;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="na">currentTimeMillis</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 使用sleep模拟数据库查询的延迟</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">getGoodsFavoriteCount</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">goodsId</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="n">log</span><span class="p">.</span><span class="na">info</span><span class="p">(</span><span class="s">&#34;获取商品收藏量&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">MILLISECONDS</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="n">100</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">catch</span><span class="w"> </span><span class="p">(</span><span class="n">InterruptedException</span><span class="w"> </span><span class="n">e</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">interrupt</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">RuntimeException</span><span class="p">(</span><span class="n">e</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">10000</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="52-使用线程池并行查询商品信息">5.2 使用线程池并行查询商品信息<a hidden class="anchor" aria-hidden="true" href="#52-使用线程池并行查询商品信息">#</a></h3>
<blockquote>
<p>分析：上方的4个商品信息查询之间并没有任何依赖，这些没有依赖的查询其实是可以并行查询的。所以可以使用线程池同时去拿这4个结果，然后在JVM内存中进行组装</p></blockquote>
<p>【主要知识点】</p>
<ul>
<li>
<p>CompletableFuture (CF)：主要用于异步执行多个相互独立的任务 （适合异步任务编排，可以方便地组合和转换任务结果）</p>
</li>
<li>
<p>CountDownLatch (CDL): 主要用于线程协调，等待一组线程完成 （一般就是用来等待一批线程执行完）</p>
</li>
<li>
<p>CF 和 CDL 区别</p>
<ul>
<li><strong>CountDownLatch</strong> 👉 <strong>运动会起跑</strong>
裁判（主线程）等待所有运动员（子线程）就位（<code>countDown</code>），枪响（计数器归零）后统一开跑。</li>
<li><strong>CompletableFuture</strong> 👉 <strong>外卖订单流程</strong>
下单（异步任务）→ 制作（<code>thenApply</code> 加工）→ 配送（<code>thenAccept</code> 交付），每个环节自动触发下一步，无需阻塞</li>
</ul>
<table>
  <thead>
      <tr>
          <th style="text-align: left"><strong>对比维度</strong></th>
          <th style="text-align: left"><strong>CountDownLatch</strong></th>
          <th style="text-align: left"><strong>CompletableFuture</strong></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong>核心用途</strong></td>
          <td style="text-align: left">线程等待机制（阻塞线程直到任务完成）</td>
          <td style="text-align: left">异步编程模型（非阻塞链式任务处理）</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>工作方式</strong></td>
          <td style="text-align: left">通过计数器递减（<code>countDown()</code>）触发释放</td>
          <td style="text-align: left">通过回调链（<code>thenApply()</code>/<code>thenAccept()</code>）传递结果</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>线程阻塞</strong></td>
          <td style="text-align: left">调用线程主动阻塞（<code>await()</code>）</td>
          <td style="text-align: left">调用线程不阻塞，通过回调处理结果</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>结果传递</strong></td>
          <td style="text-align: left">❌ 不支持任务结果传递</td>
          <td style="text-align: left">✅ 支持任务结果传递和转换</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>异常处理</strong></td>
          <td style="text-align: left">❌ 需手动捕获异常</td>
          <td style="text-align: left">✅ 内置异常处理（<code>exceptionally()</code>/<code>handle()</code>）</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>任务组合</strong></td>
          <td style="text-align: left">❌ 仅支持单次计数</td>
          <td style="text-align: left">✅ 支持多任务组合（<code>allOf()</code>/<code>anyOf()</code>）</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>复用性</strong></td>
          <td style="text-align: left">❌ 计数器归零后不可重用</td>
          <td style="text-align: left">✅ 可重复组合新任务</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>典型场景</strong></td>
          <td style="text-align: left">启动前等待资源初始化、批量任务并行执行</td>
          <td style="text-align: left">异步API调用、流水线式数据处理、微服务编排</td>
      </tr>
  </tbody>
</table>
<p>下面看一组CF和CDL的代码对比：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">AsyncDemo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 模拟线程池</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">ExecutorService</span><span class="w"> </span><span class="n">executor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Executors</span><span class="p">.</span><span class="na">newFixedThreadPool</span><span class="p">(</span><span class="n">3</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * CompletableFuture方式 - 支持任务编排和结果处理
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">GoodsInfo</span><span class="w"> </span><span class="nf">getGoodsInfoWithCF</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">goodsId</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">GoodsInfo</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">GoodsInfo</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 1. 创建多个异步任务</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">CompletableFuture</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">basicInfoFuture</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CompletableFuture</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="na">supplyAsync</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">queryBasicInfo</span><span class="p">(</span><span class="n">goodsId</span><span class="p">),</span><span class="w"> </span><span class="n">executor</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">CompletableFuture</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span><span class="w"> </span><span class="n">priceFuture</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CompletableFuture</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="na">supplyAsync</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">queryPrice</span><span class="p">(</span><span class="n">goodsId</span><span class="p">),</span><span class="w"> </span><span class="n">executor</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 2. 对结果进行处理转换    </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">CompletableFuture</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">processedInfo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">basicInfoFuture</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="na">thenApply</span><span class="p">(</span><span class="n">info</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&#34;处理后的商品信息: &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">info</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="na">exceptionally</span><span class="p">(</span><span class="n">ex</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s">&#34;获取商品信息失败&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 3. 等待所有任务完成并组装结果    </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">CompletableFuture</span><span class="p">.</span><span class="na">allOf</span><span class="p">(</span><span class="n">processedInfo</span><span class="p">,</span><span class="w"> </span><span class="n">priceFuture</span><span class="p">).</span><span class="na">join</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">result</span><span class="p">.</span><span class="na">setInfo</span><span class="p">(</span><span class="n">processedInfo</span><span class="p">.</span><span class="na">join</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">result</span><span class="p">.</span><span class="na">setPrice</span><span class="p">(</span><span class="n">priceFuture</span><span class="p">.</span><span class="na">join</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * CountDownLatch方式 - 仅支持等待多个线程完成
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">GoodsInfo</span><span class="w"> </span><span class="nf">getGoodsInfoWithCDL</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">goodsId</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">InterruptedException</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">GoodsInfo</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">GoodsInfo</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">CountDownLatch</span><span class="w"> </span><span class="n">latch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">CountDownLatch</span><span class="p">(</span><span class="n">2</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 1. 需要手动创建线程执行任务</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">executor</span><span class="p">.</span><span class="na">submit</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">result</span><span class="p">.</span><span class="na">setInfo</span><span class="p">(</span><span class="n">queryBasicInfo</span><span class="p">(</span><span class="n">goodsId</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">latch</span><span class="p">.</span><span class="na">countDown</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">executor</span><span class="p">.</span><span class="na">submit</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">result</span><span class="p">.</span><span class="na">setPrice</span><span class="p">(</span><span class="n">queryPrice</span><span class="p">(</span><span class="n">goodsId</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">latch</span><span class="p">.</span><span class="na">countDown</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 2. 等待所有任务完成</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">latch</span><span class="p">.</span><span class="na">await</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>如果需要异步并行 + 任务编排，就用 <code>CompletableFuture</code> ；如果只是用于等待一批异步任务执行完，就用 <code>CountDownLaunch</code></p>
</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">GoodsController</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 优化后的方法，根据商品id获取商品信息(基本信息、描述信息、评论量，收藏量)
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param goodsId 商品id
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @return
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @throws InterruptedException
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@GetMapping</span><span class="p">(</span><span class="s">&#34;/getGoodsDetailNew&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="n">GoodsDetailResponse</span><span class="w"> </span><span class="nf">getGoodsDetailNew</span><span class="p">(</span><span class="nd">@RequestParam</span><span class="p">(</span><span class="s">&#34;goodsId&#34;</span><span class="p">)</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">goodsId</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">long</span><span class="w"> </span><span class="n">st</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">System</span><span class="p">.</span><span class="na">currentTimeMillis</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">GoodsDetailResponse</span><span class="w"> </span><span class="n">goodsDetailResponse</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">GoodsDetailResponse</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 1、获取商品基本信息，耗时100ms</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">CompletableFuture</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span><span class="w"> </span><span class="n">goodsInfoCf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CompletableFuture</span><span class="p">.</span><span class="na">runAsync</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">goodsDetailResponse</span><span class="p">.</span><span class="na">setGoodsInfo</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">getGoodsInfo</span><span class="p">(</span><span class="n">goodsId</span><span class="p">)),</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">goodsThreadPool</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//2、获取商品描述信息，耗时100ms</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">CompletableFuture</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span><span class="w"> </span><span class="n">goodsDescriptionCf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CompletableFuture</span><span class="p">.</span><span class="na">runAsync</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">goodsDetailResponse</span><span class="p">.</span><span class="na">setGoodsDescription</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">getGoodsDescription</span><span class="p">(</span><span class="n">goodsId</span><span class="p">)),</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">goodsThreadPool</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//3、获取商品评论量，耗时100ms</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">CompletableFuture</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span><span class="w"> </span><span class="n">goodsCommentCountCf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CompletableFuture</span><span class="p">.</span><span class="na">runAsync</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">goodsDetailResponse</span><span class="p">.</span><span class="na">setCommentCount</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">getGoodsCommentCount</span><span class="p">(</span><span class="n">goodsId</span><span class="p">)),</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">goodsThreadPool</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//4、获取商品收藏量，耗时100ms</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">CompletableFuture</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span><span class="w"> </span><span class="n">goodsFavoriteCountCf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CompletableFuture</span><span class="p">.</span><span class="na">runAsync</span><span class="p">(()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">goodsDetailResponse</span><span class="p">.</span><span class="na">setFavoriteCount</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">getGoodsFavoriteCount</span><span class="p">(</span><span class="n">goodsId</span><span class="p">)),</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">goodsThreadPool</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//等待上面执行结束</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">CompletableFuture</span><span class="p">.</span><span class="na">allOf</span><span class="p">(</span><span class="n">goodsInfoCf</span><span class="p">,</span><span class="w"> </span><span class="n">goodsDescriptionCf</span><span class="p">,</span><span class="w"> </span><span class="n">goodsCommentCountCf</span><span class="p">,</span><span class="w"> </span><span class="n">goodsFavoriteCountCf</span><span class="p">).</span><span class="na">join</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">// 总耗时大约在100ms左右</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">LOGGER</span><span class="p">.</span><span class="na">info</span><span class="p">(</span><span class="s">&#34;获取商品信息，使用线程池并行查询耗时：{} ms&#34;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="na">currentTimeMillis</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">st</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">goodsDetailResponse</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h2 id="6-并行查询可能存在的问题如何解决">6. 并行查询可能存在的问题？如何解决？<a hidden class="anchor" aria-hidden="true" href="#6-并行查询可能存在的问题如何解决">#</a></h2>
<p>相关代码：<a href="https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson006">https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson006</a></p>
<h3 id="61-并行查询中存在的问题">6.1 并行查询中存在的问题<a hidden class="anchor" aria-hidden="true" href="#61-并行查询中存在的问题">#</a></h3>
<p>并行查询所用到的线程池配置是非常关键且重要的配置，如果设置不当可能出现严重的性能问题。</p>
<p>比如将核心线程数设置为了 <code>1</code> ，而队列大小没有限制，那么所有的请求都变成串行了，会导致请求响应非常慢。另外，核心线程池和队列大小的上限也应该匹配。如果核心线程池设置为 <code>10</code> ，而队列大小没有设置上限。该线程池同时只可支持 <code>10</code> 个任务并行，其他的请求都会变成串行执行了，进入队列排队，从而导致接口响应特别慢。</p>
<h3 id="62-如何解决并行查询的问题">6.2 如何解决并行查询的问题<a hidden class="anchor" aria-hidden="true" href="#62-如何解决并行查询的问题">#</a></h3>
<p>解决并行查询问题的核心：不要让任务排队或者排队时间不要太长</p>
<p>下面从线程池的执行流程入手，优化并行查询问题</p>
<p><img alt="image-20240405093250650" loading="lazy" src="https://oss.swimmingliu.cn/536e392e-6313-11f0-99d8-caaeffceb345"></p>
<p><strong>【解决方案】</strong></p>
<ul>
<li>
<p><strong>增大线程数</strong>：可以将<strong>核心线程数</strong>、<strong>最大线程数调大</strong>，但不能调到超过CPU的最大负载，不然可能会降低系统性能分。该参数应该根据业务的指标进行压测得到一个合理的值</p>
</li>
<li>
<p><strong>减少队列数</strong>：</p>
<ul>
<li>
<p>将队列大小设置的比较小，这样排队的时间大概率会比较短，或者排队失败，直接后面的流程</p>
<p>⚠️ 之前理解存在误区：应该是核心线程检查完了，就检查能否放入队列，再检查最大线程数。而不是核心线程检查完，就去检查最大线程数。</p>
</li>
<li>
<p>减少队列数至 <code>0</code>：这样任务就不会进入队列，而直接创建新的线程去执行，或者走拒绝策略</p>
<blockquote>
<p><code>LinkedBlockingQueue、ArrayBlockingQueue</code> 容量是不允许为0的，如果需要用到容量为0的队列，则需要使用<strong>同步阻塞队列</strong> <code>SynchronousQueue</code></p></blockquote>
</li>
</ul>
</li>
<li>
<p><strong>拒绝策略</strong>：可以使用 <code>CallerRunsPolicy</code>，这个策略是直接在调用线程的当前线程中执行。该策略可以保证任务能快速被处理，不会一直处于阻塞态</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">策略名称</th>
          <th style="text-align: left">行为描述</th>
          <th style="text-align: left">适用场景</th>
          <th style="text-align: left">生活实例类比</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left"><strong>AbortPolicy</strong></td>
          <td style="text-align: left">直接抛出 <code>RejectedExecutionException</code> 异常</td>
          <td style="text-align: left">需要严格保证任务不丢失的场景</td>
          <td style="text-align: left">餐厅满员时直接拒绝新顾客</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>CallerRunsPolicy</strong></td>
          <td style="text-align: left">让提交任务的线程自己执行该任务</td>
          <td style="text-align: left">需要降低任务提交速度的场景</td>
          <td style="text-align: left">经理亲自处理无法分配的任务</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>DiscardPolicy</strong></td>
          <td style="text-align: left">静默丢弃新任务，不抛异常也不执行</td>
          <td style="text-align: left">允许丢弃非关键任务的场景</td>
          <td style="text-align: left">快递爆仓时直接丢弃新包裹</td>
      </tr>
      <tr>
          <td style="text-align: left"><strong>DiscardOldestPolicy</strong></td>
          <td style="text-align: left">丢弃队列中最老的任务，然后尝试重新提交当前任务</td>
          <td style="text-align: left">优先处理新任务的场景</td>
          <td style="text-align: left">超市排队时让等待最久的顾客离开</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p><strong>线程池隔离</strong>：不同的业务最好使用不同的线程池，互不影响，强烈建议<strong>核心业务</strong>一定要使用单独的线程池。</p>
</li>
</ul>
<p><strong>【优化后的线程池配置】</strong></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Bean</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="n">ThreadPoolTaskExecutor</span><span class="w"> </span><span class="nf">goodsThreadPool</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">ThreadPoolTaskExecutor</span><span class="w"> </span><span class="n">threadPoolTaskExecutor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ThreadPoolTaskExecutor</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">threadPoolTaskExecutor</span><span class="p">.</span><span class="na">setThreadNamePrefix</span><span class="p">(</span><span class="s">&#34;ThreadPool-Goods-&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 核心线程数为cpu核数 * 4，最大线程数据为cpu核数 * 8</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">threadPoolTaskExecutor</span><span class="p">.</span><span class="na">setCorePoolSize</span><span class="p">(</span><span class="n">Runtime</span><span class="p">.</span><span class="na">getRuntime</span><span class="p">().</span><span class="na">availableProcessors</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">4</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">threadPoolTaskExecutor</span><span class="p">.</span><span class="na">setMaxPoolSize</span><span class="p">(</span><span class="n">Runtime</span><span class="p">.</span><span class="na">getRuntime</span><span class="p">().</span><span class="na">availableProcessors</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">8</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 队列容量为0，则任务就不会进入队列</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">threadPoolTaskExecutor</span><span class="p">.</span><span class="na">setQueueCapacity</span><span class="p">(</span><span class="n">0</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 拒绝策略使用CallerRunsPolicy，让当前线程去兜底去执行任务</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">threadPoolTaskExecutor</span><span class="p">.</span><span class="na">setRejectedExecutionHandler</span><span class="p">(</span><span class="k">new</span><span class="w"> </span><span class="n">ThreadPoolExecutor</span><span class="p">.</span><span class="na">CallerRunsPolicy</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">threadPoolTaskExecutor</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h2 id="7-接口性能调优之大-长-事务优化">7. 接口性能调优之大 (长) 事务优化<a hidden class="anchor" aria-hidden="true" href="#7-接口性能调优之大-长-事务优化">#</a></h2>
<blockquote>
<p>日常编程中，容易遇到事务执行时间较长的情况。如果该事务的对应的接口，请求量暴增，由于数据库连接池的限制，大部分请求可能会失败。</p></blockquote>
<p>相关代码：<a href="https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson009">https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson009</a></p>
<h3 id="71-大长事务所带来的问题">7.1 大(长)事务所带来的问题<a hidden class="anchor" aria-hidden="true" href="#71-大长事务所带来的问题">#</a></h3>
<p>下面的代码带有 <code>@Transcational</code> 注解， 说明该方法会交给 <code>Spring</code> 来管理该方法的事务。具体执行逻辑如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">1、Spring去数据库连接池拿到一个数据库连接
</span></span><span class="line"><span class="cl">2、开启事务
</span></span><span class="line"><span class="cl">3、执行bigTransaction<span class="o">()</span>中的代码
</span></span><span class="line"><span class="cl">4、提交事务
</span></span><span class="line"><span class="cl">5、将数据库连接还给数据库连接池中
</span></span></code></pre></div><p>在这个过程中，数据库连接会一直被占用。因为数据库连接时有限的，并且是非常稀缺的资。如果长时间被占用，并且数据库连接池中的可用连接都被占用了，则其他请求无法连接数据库。它会导致连接超时，执行方法失败。例如，下面方法中 <code>this.getData()</code> 方法会占用 <code>5s</code> 的时间。如果 <code>5s</code> 内有 <code>100</code> 条请求并发执行，且数据库连接池最大连接数为 <code>20</code>，超时时间为<code>3s</code>。 则剩余的 <code>80</code> 条请求，都会出现连接失败的现象。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Transactional</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">bigTransaction</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">InterruptedException</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 1、getData()方法模拟一个比较耗时的获取数据的操作，这个方法内部会休眠5秒</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">String</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">getData</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//2、将上面获取到的数据写入到db中</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Lesson007PO</span><span class="w"> </span><span class="n">po</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Lesson007PO</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">po</span><span class="p">.</span><span class="na">setId</span><span class="p">(</span><span class="n">UUID</span><span class="p">.</span><span class="na">randomUUID</span><span class="p">().</span><span class="na">toString</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">po</span><span class="p">.</span><span class="na">setData</span><span class="p">(</span><span class="n">data</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">lesson007Mapper</span><span class="p">.</span><span class="na">insert</span><span class="p">(</span><span class="n">po</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="nf">getData</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">InterruptedException</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//休眠5秒</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">TimeUnit</span><span class="p">.</span><span class="na">SECONDS</span><span class="p">.</span><span class="na">sleep</span><span class="p">(</span><span class="n">5</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">UUID</span><span class="p">.</span><span class="na">randomUUID</span><span class="p">().</span><span class="na">toString</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="72-如何解决大-长-事务的问题-拆分为小事务">7.2 如何解决大 (长) 事务的问题 (拆分为小事务)<a hidden class="anchor" aria-hidden="true" href="#72-如何解决大-长-事务的问题-拆分为小事务">#</a></h3>
<p><strong>优化方法</strong>：将大(长)事务进行拆分，将无需数据库连接的部分拆出来，将事务最小化。
例如，上方的代码中，<code>this.getData()</code> 方法是不需要操作数据库的，只有最后的 <code>insert</code> 方法才需要连接数据库。所以，可以将事务的粒度控制在 <code>insert</code> 方法中。</p>
<p><strong>TranscationTemplate</strong>：Spring中的 <code>TranscationTemplate</code> 工具类能够采用编程式的方案，灵活控制事务的粒度。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 使用 TransactionTemplate 编程式事务，可以灵活的控制事务的范围
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @throws InterruptedException
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">smallTransaction</span><span class="p">()</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">InterruptedException</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 1、调用getData()方法，讲获取的数据写到db中，假设 getData方法比较耗时，比如耗时 5秒</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">String</span><span class="w"> </span><span class="n">data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">getData</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//2、将上面获取到的数据写入到db中</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Lesson007PO</span><span class="w"> </span><span class="n">po</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Lesson007PO</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">po</span><span class="p">.</span><span class="na">setId</span><span class="p">(</span><span class="n">UUID</span><span class="p">.</span><span class="na">randomUUID</span><span class="p">().</span><span class="na">toString</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">po</span><span class="p">.</span><span class="na">setData</span><span class="p">(</span><span class="n">data</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// this.transactionTemplate.executeWithoutResult可以传入一个Consumer，这个Consumer表述需要在事务中执行的业务操作</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">transactionTemplate</span><span class="p">.</span><span class="na">executeWithoutResult</span><span class="p">(</span><span class="n">action</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">lesson007Mapper</span><span class="p">.</span><span class="na">insert</span><span class="p">(</span><span class="n">po</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>【总结】</p>
<ol>
<li><strong>控制事务粒度</strong> ：使用 <code>TransactionTemplate</code> 编程式事务，精准控制事务的粒度，尽量让事务小型化</li>
<li><strong>非数据库相关代码，避免出现在事务中</strong>：尽量避免将没有事务的耗时操作放到事务代码中；避免在事务中执行远程操作，远程操作是不需要用到本地事务的，所以没有必要放在事务中</li>
<li><strong>事务集中化</strong>：尽量让事务的操作集中在一起执行，比如都放到方法最后，使用 <code>TransactionTemplate</code> 执行，这样可使事务最小化</li>
</ol>
<h2 id="8-动态线程池">8. 动态线程池<a hidden class="anchor" aria-hidden="true" href="#8-动态线程池">#</a></h2>
<p>相关代码：<a href="https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson009">https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson009</a></p>
<h3 id="81-为什么需要动态线程池">8.1 为什么需要动态线程池<a hidden class="anchor" aria-hidden="true" href="#81-为什么需要动态线程池">#</a></h3>
<blockquote>
<p>平时我们在开发中，创建了不少线程池，这些线程池都处于游离状态，不方便管理和监控。无法知道目前系统中有哪些线程池、以及每个线程池当前的一个状态，负载情况等，所以我们可以开发一个线程池管理器来解决这个问题。</p></blockquote>
<h3 id="82-线程池管理器">8.2 线程池管理器<a hidden class="anchor" aria-hidden="true" href="#82-线程池管理器">#</a></h3>
<p>统管系统中所有线程池，负责所有线程池的创建、监控等操作。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">ThreadPoolManager</span><span class="w"> </span><span class="p">{</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="cm">/** 线程池Map */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">ThreadPoolTaskExecutor</span><span class="o">&gt;</span><span class="w"> </span><span class="n">threadPoolMap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ConcurrentHashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">ThreadPoolTaskExecutor</span><span class="o">&gt;</span><span class="p">(</span><span class="n">16</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 创建新的线程池，如果线程池已经创建，返回已经创建的线程池
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param name                     线程池名称
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param corePoolSize             核心线程数
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param maxPoolSize              最大线程数
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param queueCapacity            队列大小
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param keepAliveSeconds         线程池存活时间（秒）
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param threadFactory            线程工厂
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param rejectedExecutionHandler 拒绝策略
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @return
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">ThreadPoolTaskExecutor</span><span class="w"> </span><span class="nf">newThreadPool</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">corePoolSize</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">maxPoolSize</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">queueCapacity</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">keepAliveSeconds</span><span class="p">,</span><span class="w"> </span><span class="n">ThreadFactory</span><span class="w"> </span><span class="n">threadFactory</span><span class="p">,</span><span class="w"> </span><span class="n">RejectedExecutionHandler</span><span class="w"> </span><span class="n">rejectedExecutionHandler</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">threadPoolMap</span><span class="p">.</span><span class="na">computeIfAbsent</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">threadGroupName</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">ThreadPoolTaskExecutor</span><span class="w"> </span><span class="n">threadPoolExecutor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ThreadPoolTaskExecutor</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="kd">private</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="n">initialized</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="p">;</span><span class="w"> </span><span class="c1">// 初始化标记</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="kd">protected</span><span class="w"> </span><span class="n">BlockingQueue</span><span class="o">&lt;</span><span class="n">Runnable</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">createQueue</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">queueCapacity</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">queueCapacity</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                      	</span><span class="c1">// 使用自定义的 ResizeLinkedBlockingQueue 替代默认队列，保证能够在运行时动态调整队列大小</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ResizeLinkedBlockingQueue</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">queueCapacity</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                      	</span><span class="c1">// 当队列容量设置为0时，使用 SynchronousQueue。表示任务必须立即被线程处理，否则就会被拒绝</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">SynchronousQueue</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">setQueueCapacity</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">queueCapacity</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                  	</span><span class="c1">// 确保线程池已初始化且队列类型正确时才调整容量</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">initialized</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">getThreadPoolExecutor</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="k">this</span><span class="p">.</span><span class="na">getThreadPoolExecutor</span><span class="p">().</span><span class="na">getQueue</span><span class="p">()</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                            </span><span class="k">this</span><span class="p">.</span><span class="na">getThreadPoolExecutor</span><span class="p">().</span><span class="na">getQueue</span><span class="p">()</span><span class="w"> </span><span class="k">instanceof</span><span class="w"> </span><span class="n">ResizeLinkedBlockingQueue</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="p">((</span><span class="n">ResizeLinkedBlockingQueue</span><span class="p">)</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">getThreadPoolExecutor</span><span class="p">().</span><span class="na">getQueue</span><span class="p">()).</span><span class="na">setCapacity</span><span class="p">(</span><span class="n">queueCapacity</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="kd">super</span><span class="p">.</span><span class="na">setQueueCapacity</span><span class="p">(</span><span class="n">queueCapacity</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">afterPropertiesSet</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                  	</span><span class="c1">// 使用 initialized 标记确保线程池只被初始化一次</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">initialized</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                        </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="kd">super</span><span class="p">.</span><span class="na">afterPropertiesSet</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                    </span><span class="k">this</span><span class="p">.</span><span class="na">initialized</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 设置参数</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">threadPoolExecutor</span><span class="p">.</span><span class="na">setCorePoolSize</span><span class="p">(</span><span class="n">corePoolSize</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">threadFactory</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="c1">// ThreadFactory相当于线程池的一些规定 (招聘标准)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">threadPoolExecutor</span><span class="p">.</span><span class="na">setThreadFactory</span><span class="p">(</span><span class="n">threadFactory</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rejectedExecutionHandler</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="c1">// 拒绝执行的策略，上方提到的四种拒绝策略</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">threadPoolExecutor</span><span class="p">.</span><span class="na">setRejectedExecutionHandler</span><span class="p">(</span><span class="n">rejectedExecutionHandler</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">threadPoolExecutor</span><span class="p">.</span><span class="na">afterPropertiesSet</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">threadPoolExecutor</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">});</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">   
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/** 获取所有线程池信息 */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">List</span><span class="o">&lt;</span><span class="n">ThreadPoolInfo</span><span class="o">&gt;</span><span class="w"> </span><span class="nf">threadPoolInfoList</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">threadPoolMap</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="na">entrySet</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="na">stream</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="na">map</span><span class="p">(</span><span class="n">entry</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">threadPoolInfo</span><span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="na">getKey</span><span class="p">(),</span><span class="w"> </span><span class="n">entry</span><span class="p">.</span><span class="na">getValue</span><span class="p">()))</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="p">.</span><span class="na">collect</span><span class="p">(</span><span class="n">Collectors</span><span class="p">.</span><span class="na">toList</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h3 id="83-动态线程池">8.3 动态线程池<a hidden class="anchor" aria-hidden="true" href="#83-动态线程池">#</a></h3>
<p>动态线程池：无需重启的情况下，可以对线程池进行扩缩容，比如改变线程池的核心线程数量、最大线程数量、队列容量等。</p>
<h4 id="831-常用动态线程池">8.3.1 常用动态线程池<a hidden class="anchor" aria-hidden="true" href="#831-常用动态线程池">#</a></h4>
<p><strong>dynamic-tp</strong>：https://github.com/dromara/dynamic-tp</p>
<h4 id="832-手动实现动态线程池">8.3.2 手动实现动态线程池<a hidden class="anchor" aria-hidden="true" href="#832-手动实现动态线程池">#</a></h4>
<blockquote>
<p>线程池中会用到Java中的阻塞队列 <code>java.util.concurrent.BlockingQueue</code>，目前 jdk中自带几个阻塞队列都不支持动态扩容。
比如 <code>java.util.concurrent.LinkedBlockingQueue</code>，它的 <code>capacity</code> 是 <code>final</code> 修饰的，不支持修改。</p></blockquote>
<p><strong>动态调整大小的前提</strong>：动态调整线程池大小需要队列容量能够支持调整，我们需要创建可扩容的阻塞队列 <code>ResizeLinkedBlockingQueue</code>。代码是从<code>LinkedBlockingQueue</code> 中拷贝过来的，增加可修改容量 的<code>setCapacity</code> 方法。然后创建线程池的时，使用自定义的阻塞队列便可以实现线程池的动态扩容。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 设置容量
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param capacity
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">setCapacity</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">capacity</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">capacity</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">0</span><span class="p">)</span><span class="w"> </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">IllegalArgumentException</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">final</span><span class="w"> </span><span class="n">ReentrantLock</span><span class="w"> </span><span class="n">putLock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">putLock</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">putLock</span><span class="p">.</span><span class="na">lock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">try</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">count</span><span class="p">.</span><span class="na">get</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">capacity</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">IllegalArgumentException</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">capacity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">capacity</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">finally</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">putLock</span><span class="p">.</span><span class="na">unlock</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>动态更改线程池大小的方法如下所示：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">ThreadPoolManager</span><span class="w"> </span><span class="p">{</span><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 动态变更线程池（如：扩缩容、扩缩队列大小）
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param threadPoolChange 变更线程池信息
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">changeThreadPool</span><span class="p">(</span><span class="n">ThreadPoolChange</span><span class="w"> </span><span class="n">threadPoolChange</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">ThreadPoolTaskExecutor</span><span class="w"> </span><span class="n">threadPoolTaskExecutor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">threadPoolMap</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">threadPoolChange</span><span class="p">.</span><span class="na">getName</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">threadPoolTaskExecutor</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">IllegalArgumentException</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">threadPoolChange</span><span class="p">.</span><span class="na">getCorePoolSize</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">threadPoolChange</span><span class="p">.</span><span class="na">getMaxPoolSize</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">throw</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">IllegalArgumentException</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">synchronized</span><span class="w"> </span><span class="p">(</span><span class="n">ThreadPoolManager</span><span class="p">.</span><span class="na">class</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">// 增加线程情况：需要修改的最大线程大于当前核心线程，则设置当前核心线程为修改后的最大线程</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">threadPoolChange</span><span class="p">.</span><span class="na">getMaxPoolSize</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">threadPoolTaskExecutor</span><span class="p">.</span><span class="na">getCorePoolSize</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              	</span><span class="c1">// 先调整最大线程数，再调整核心数 （先扩大总量，再扩大局部）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">threadPoolTaskExecutor</span><span class="p">.</span><span class="na">setMaxPoolSize</span><span class="p">(</span><span class="n">threadPoolChange</span><span class="p">.</span><span class="na">getMaxPoolSize</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">threadPoolTaskExecutor</span><span class="p">.</span><span class="na">setCorePoolSize</span><span class="p">(</span><span class="n">threadPoolChange</span><span class="p">.</span><span class="na">getCorePoolSize</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">threadPoolTaskExecutor</span><span class="p">.</span><span class="na">setQueueCapacity</span><span class="p">(</span><span class="n">threadPoolChange</span><span class="p">.</span><span class="na">getQueueCapacity</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">              	</span><span class="c1">// 先减少局部，再减少总量</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">threadPoolTaskExecutor</span><span class="p">.</span><span class="na">setCorePoolSize</span><span class="p">(</span><span class="n">threadPoolChange</span><span class="p">.</span><span class="na">getCorePoolSize</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">threadPoolTaskExecutor</span><span class="p">.</span><span class="na">setMaxPoolSize</span><span class="p">(</span><span class="n">threadPoolChange</span><span class="p">.</span><span class="na">getMaxPoolSize</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">threadPoolTaskExecutor</span><span class="p">.</span><span class="na">setQueueCapacity</span><span class="p">(</span><span class="n">threadPoolChange</span><span class="p">.</span><span class="na">getQueueCapacity</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w"> 
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h1 id="分布式与微服务">分布式与微服务<a hidden class="anchor" aria-hidden="true" href="#分布式与微服务">#</a></h1>
<h2 id="1-springboot实现动态job的实战">1. SpringBoot实现动态Job的实战<a hidden class="anchor" aria-hidden="true" href="#1-springboot实现动态job的实战">#</a></h2>
<p>相关代码：<a href="https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson011">https://github.com/SwimmingLiu/JavaSceneQuiz100/tree/main/lesson011</a></p>
<h3 id="11-job表---表结构">1.1 Job表 - 表结构<a hidden class="anchor" aria-hidden="true" href="#11-job表---表结构">#</a></h3>
<table>
  <thead>
      <tr>
          <th>字段名</th>
          <th>类型</th>
          <th>可空</th>
          <th>默认</th>
          <th>备注</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>id</td>
          <td>varchar(50)</td>
          <td>否</td>
          <td>-</td>
          <td>id，主键</td>
      </tr>
      <tr>
          <td>name</td>
          <td>varchar(100)</td>
          <td>否</td>
          <td>-</td>
          <td>job名称，可以定义一个有意义的名称</td>
      </tr>
      <tr>
          <td>cron</td>
          <td>varchar(50)</td>
          <td>否</td>
          <td>-</td>
          <td>job的执行周期，cron表达式</td>
      </tr>
      <tr>
          <td>bean_name</td>
          <td>varchar(100)</td>
          <td>否</td>
          <td>-</td>
          <td>job需要执行那个bean，对应spring中bean的名称</td>
      </tr>
      <tr>
          <td>bean_method</td>
          <td>varchar(100)</td>
          <td>否</td>
          <td>-</td>
          <td>job执行的bean的方法</td>
      </tr>
      <tr>
          <td>status</td>
          <td>smallint</td>
          <td>否</td>
          <td>0</td>
          <td>job的状态,0：停止，1：执行中</td>
      </tr>
  </tbody>
</table>
<h3 id="12-job执行管理器">1.2 Job执行管理器<a hidden class="anchor" aria-hidden="true" href="#12-job执行管理器">#</a></h3>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">SpringJobRunManager</span><span class="w"> </span><span class="kd">implements</span><span class="w"> </span><span class="n">CommandLineRunner</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  	</span><span class="c1">// applicationContext 主要用于在任务执行时动态获取和调用指定的 Bean 和方法，实现灵活的任务调度。</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 可以把它理解为“Spring 管理的对象工厂和服务总线”</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Autowired</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">ApplicationContext</span><span class="w"> </span><span class="n">applicationContext</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">		</span><span class="c1">// threadPoolTaskScheduler 是 Spring 提供的线程池定时任务调度器，主要用于在应用中以多线程方式执行定时任务（如定时执行、Cron表达式调度等）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Autowired</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">ThreadPoolTaskScheduler</span><span class="w"> </span><span class="n">threadPoolTaskScheduler</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// job表相关服务</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Autowired</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">JobService</span><span class="w"> </span><span class="n">jobService</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 系统重正在运行中的job列表
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">SpringJobTask</span><span class="o">&gt;</span><span class="w"> </span><span class="n">runningJobMap</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ConcurrentHashMap</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm">     * springboot应用启动后会回调
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @param args incoming main method arguments
</span></span></span><span class="line"><span class="cl"><span class="cm">     * @throws Exception
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@Override</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="n">String</span><span class="p">...</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="kd">throws</span><span class="w"> </span><span class="n">Exception</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//1、启动job</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">startAllJob</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="c1">//2、监控db中job的变化（job增、删、改），然后同步给job执行器去执行</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">monitorDbJobChange</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>Springboot应用启动之后会回调 <code>CommandLineRunner</code> 中的 <code>run</code> 方法，依次启动job，并监控job中的变化。</p>
<h4 id="121-启动job">1.2.1 启动job<a hidden class="anchor" aria-hidden="true" href="#121-启动job">#</a></h4>
<p>启动job的方式比较简单，就是从数据库中找出所有需要启动的job（状态为start），然后循环启动。</p>
<p>启动job具体方式如下：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">startAllJob</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Job</span><span class="o">&gt;</span><span class="w"> </span><span class="n">jobList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">jobService</span><span class="p">.</span><span class="na">getStartJobList</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Job</span><span class="w"> </span><span class="n">job</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">jobList</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">startJob</span><span class="p">(</span><span class="n">job</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 启动一个定时任务（job）
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param job 需要启动的任务对象
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">startJob</span><span class="p">(</span><span class="n">Job</span><span class="w"> </span><span class="n">job</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 1. 创建任务执行体，注入Spring上下文，便于任务内获取Bean对象</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">SpringJobTask</span><span class="w"> </span><span class="n">springJobTask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">SpringJobTask</span><span class="p">(</span><span class="n">job</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">applicationContext</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 2. 根据job的cron表达式创建调度触发器</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">CronTrigger</span><span class="w"> </span><span class="n">trigger</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">CronTrigger</span><span class="p">(</span><span class="n">job</span><span class="p">.</span><span class="na">getCron</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 3. 使用线程池调度器注册任务，返回调度句柄</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">ScheduledFuture</span><span class="o">&lt;?&gt;</span><span class="w"> </span><span class="n">scheduledFuture</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">threadPoolTaskScheduler</span><span class="p">.</span><span class="na">schedule</span><span class="p">(</span><span class="n">springJobTask</span><span class="p">,</span><span class="w"> </span><span class="n">trigger</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 4. 记录调度句柄到任务对象，便于后续取消 -&gt; </span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">springJobTask</span><span class="p">.</span><span class="na">setScheduledFuture</span><span class="p">(</span><span class="n">scheduledFuture</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 5. 将任务放入运行中的任务Map，方便管理和查找</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">runningJobMap</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">job</span><span class="p">.</span><span class="na">getId</span><span class="p">(),</span><span class="w"> </span><span class="n">springJobTask</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 6. 记录日志，方便追踪</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">logger</span><span class="p">.</span><span class="na">info</span><span class="p">(</span><span class="s">&#34;启动 job 成功:{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">JSONUtil</span><span class="p">.</span><span class="na">toJsonStr</span><span class="p">(</span><span class="n">job</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 删除（停止）一个定时任务
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param job 需要删除的任务对象
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">deleteJob</span><span class="p">(</span><span class="n">Job</span><span class="w"> </span><span class="n">job</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">job</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 1. 从运行中的任务Map获取任务</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">SpringJobTask</span><span class="w"> </span><span class="n">springJobTask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">runningJobMap</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">job</span><span class="p">.</span><span class="na">getId</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">springJobTask</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="p">;}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 2. 取消任务调度（停止定时执行）</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">springJobTask</span><span class="p">.</span><span class="na">getScheduledFuture</span><span class="p">().</span><span class="na">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 3. 从Map中移除该任务</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">runningJobMap</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">job</span><span class="p">.</span><span class="na">getId</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 4. 记录日志</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">logger</span><span class="p">.</span><span class="na">info</span><span class="p">(</span><span class="s">&#34;移除 job 成功:{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">JSONUtil</span><span class="p">.</span><span class="na">toJsonStr</span><span class="p">(</span><span class="n">job</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 更新一个定时任务（先删除再启动）
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param job 需要更新的任务对象
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">updateJob</span><span class="p">(</span><span class="n">Job</span><span class="w"> </span><span class="n">job</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 1. 先删除旧的任务</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">deleteJob</span><span class="p">(</span><span class="n">job</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 2. 再启动新的任务</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">startJob</span><span class="p">(</span><span class="n">job</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 3. 记录日志</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">logger</span><span class="p">.</span><span class="na">info</span><span class="p">(</span><span class="s">&#34;更新 job 成功:{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">JSONUtil</span><span class="p">.</span><span class="na">toJsonStr</span><span class="p">(</span><span class="n">job</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><h4 id="122-动态监控db中job的变化">1.2.2 动态监控DB中job的变化<a hidden class="anchor" aria-hidden="true" href="#122-动态监控db中job的变化">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 监控db中job的变化，每5秒监控一次，这个频率大家使用的时候可以稍微调大点
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">monitorDbJobChange</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">this</span><span class="p">.</span><span class="na">threadPoolTaskScheduler</span><span class="p">.</span><span class="na">scheduleWithFixedDelay</span><span class="p">(</span><span class="k">this</span><span class="p">::</span><span class="n">jobChangeDispose</span><span class="p">,</span><span class="w"> </span><span class="n">Duration</span><span class="p">.</span><span class="na">ofSeconds</span><span class="p">(</span><span class="n">5</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// 任务变化处理</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">jobChangeDispose</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//1、从db中拿到所有job，和目前内存中正在运行的所有job对比，可得到本次新增的job、删除的job、更新的job</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">JobChange</span><span class="w"> </span><span class="n">jobChange</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">getJobChange</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//2、处理新增的job</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Job</span><span class="w"> </span><span class="n">job</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">jobChange</span><span class="p">.</span><span class="na">getAddJobList</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">startJob</span><span class="p">(</span><span class="n">job</span><span class="p">);}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//3、处理删除的job</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Job</span><span class="w"> </span><span class="n">job</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">jobChange</span><span class="p">.</span><span class="na">getDeleteJobList</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">deleteJob</span><span class="p">(</span><span class="n">job</span><span class="p">);}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//4、处理变化的job</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Job</span><span class="w"> </span><span class="n">job</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">jobChange</span><span class="p">.</span><span class="na">getUpdateJobList</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">updateJob</span><span class="p">(</span><span class="n">job</span><span class="p">);}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="n">JobChange</span><span class="w"> </span><span class="nf">getJobChange</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//新增的job</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Job</span><span class="o">&gt;</span><span class="w"> </span><span class="n">addJobList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//删除的job</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Job</span><span class="o">&gt;</span><span class="w"> </span><span class="n">deleteJobList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//更新的job</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Job</span><span class="o">&gt;</span><span class="w"> </span><span class="n">updateJobList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//从db中拿到所有job，和目前内存中正在运行的所有job对比，可得到本次新增的job、删除的job、更新的job</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">List</span><span class="o">&lt;</span><span class="n">Job</span><span class="o">&gt;</span><span class="w"> </span><span class="n">startJobList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="p">.</span><span class="na">jobService</span><span class="p">.</span><span class="na">getStartJobList</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Job</span><span class="w"> </span><span class="n">job</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">startJobList</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">SpringJobTask</span><span class="w"> </span><span class="n">springJobTask</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">runningJobMap</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">job</span><span class="p">.</span><span class="na">getId</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">springJobTask</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">addJobList</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">job</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="c1">//job的执行规则变了</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">jobIsChange</span><span class="p">(</span><span class="n">job</span><span class="p">,</span><span class="w"> </span><span class="n">springJobTask</span><span class="p">.</span><span class="na">getJob</span><span class="p">()))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">                </span><span class="n">updateJobList</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">job</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//获取被删除的job，springJobTaskMap中存在的，而startJobList不存在的，则是需要从当前运行列表中停止移除的</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">Set</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span><span class="w"> </span><span class="n">startJobIdList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CollUtils</span><span class="p">.</span><span class="na">convertSet</span><span class="p">(</span><span class="n">startJobList</span><span class="p">,</span><span class="w"> </span><span class="n">Job</span><span class="p">::</span><span class="n">getId</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">Map</span><span class="p">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span><span class="w"> </span><span class="n">SpringJobTask</span><span class="o">&gt;</span><span class="w"> </span><span class="n">springJobTaskEntry</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">runningJobMap</span><span class="p">.</span><span class="na">entrySet</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">startJobIdList</span><span class="p">.</span><span class="na">contains</span><span class="p">(</span><span class="n">springJobTaskEntry</span><span class="p">.</span><span class="na">getKey</span><span class="p">()))</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">deleteJobList</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">springJobTaskEntry</span><span class="p">.</span><span class="na">getValue</span><span class="p">().</span><span class="na">getJob</span><span class="p">());</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//返回job变更结果</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">JobChange</span><span class="p">(</span><span class="n">addJobList</span><span class="p">,</span><span class="w"> </span><span class="n">updateJobList</span><span class="p">,</span><span class="w"> </span><span class="n">deleteJobList</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="cm">/**
</span></span></span><span class="line"><span class="cl"><span class="cm"> * 检测两个job是否发生了变化，（cron、beanName、beanMethod）中有任意一项变动了，则返回true
</span></span></span><span class="line"><span class="cl"><span class="cm"> *
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param job1
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @param job2
</span></span></span><span class="line"><span class="cl"><span class="cm"> * @return
</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">private</span><span class="w"> </span><span class="kt">boolean</span><span class="w"> </span><span class="nf">jobIsChange</span><span class="p">(</span><span class="n">Job</span><span class="w"> </span><span class="n">job1</span><span class="p">,</span><span class="w"> </span><span class="n">Job</span><span class="w"> </span><span class="n">job2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">!</span><span class="p">(</span><span class="n">Objects</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">job1</span><span class="p">.</span><span class="na">getCron</span><span class="p">(),</span><span class="w"> </span><span class="n">job2</span><span class="p">.</span><span class="na">getCron</span><span class="p">())</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Objects</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">job1</span><span class="p">.</span><span class="na">getBeanName</span><span class="p">(),</span><span class="w"> </span><span class="n">job2</span><span class="p">.</span><span class="na">getBeanName</span><span class="p">())</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">Objects</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">job1</span><span class="p">.</span><span class="na">getBeanMethod</span><span class="p">(),</span><span class="w"> </span><span class="n">job2</span><span class="p">.</span><span class="na">getBeanMethod</span><span class="p">()));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div>

  </div>



  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://swimmingliu.cn/tags/java/">Java</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://swimmingliu.cn/posts/job/hensheng-interview-questions/">
    <span class="title">Next »</span>
    <br>
    <span>恒生聚源面经记录</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2023-2025 <a href="https://swimmingliu.cn/">SwimmingLiu&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
    <span>
        <a href="https://beian.miit.gov.cn/">浙ICP备2024056260号</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
