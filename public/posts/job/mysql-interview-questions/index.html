<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>MySQL面试题笔记 | SwimmingLiu&#39;s Blog</title>
<meta name="keywords" content="Java, MySQL">
<meta name="description" content="1.MySQL 中的数据排序是怎么实现的？
1.排序方法：索引排序和文件排序 (filesort)
2.索引排序：如果order by xxx的字段为索引字段，则利用索引进行排序。效率最高，索引默认有序。
3.文件排序 (filesort)：内存排序(单路排序和双路排序)和磁盘排序，具体取决于排序数据的大小。其中，内存排序使用单路排序或双路排序，取决于max_length_for_sort_data(默认为4096个字节)
4.双路排序：取row_id(如果有主键，则为主键)和select a,b,c order by xxx的xxx字段放入sort_buffer(排序缓存)中，将排序后的row_id回表查询a,b,c
5.单路排序: 直接把要查的所有字段放入sort_buffer里，排序后直接得到结果集合
6.磁盘排序（归并排序）:将数据分为多份文件，单独对文件进行排序，然后合并成一个有序的大文件
2. MySQL 的 Change Buffer 是什么？它有什么作用？
1.ChangeBuffer定义：Change Buffer是InnoDB缓冲当中的一块缓存区，用于暂存二级索引的修改，避免二级索引页修改产生的随机IO
2.ChangeBuffer注意事项：只能用于二级索引，不能用于其他任何索引，包括主键索引和唯一索引都不行。
3.如果ChangeBuffer挂了，更改操作未执行，是否会出现脏数据？
首先，ChangeBuffer也会保存在磁盘空间里面，redo log会记录Change Buffer当中的修改操作，确保数据一致性。
知识拓展1：一级索引和二级索引区别

一级索引（聚簇索引）：数据表的主键索引，数据和索引存储在同一B&#43;树的叶子节点中。每个表只能有一个一级索引。
二级索引（非聚簇索引）：除主键外的其他索引，叶子节点存储索引列的值和对应的主键值。通过二级索引查询时，需要先通过二级索引获取主键值，再通过主键值查询数据，这个过程称为“回表”。
知识拓展2:  MySQL中有哪些常见索引？都有什么区别？

在MySQL中，索引是提高查询效率的关键工具。常见的索引类型包括主键索引、唯一索引、普通索引、全文索引和空间索引。
1. 主键索引（Primary Key Index）

定义：主键索引是一种特殊的唯一索引，用于唯一标识表中的每一行数据。每个表只能有一个主键索引，且主键列的值不能为空。
特点：主键索引的叶子节点存储完整的数据行，因此查询效率高。在InnoDB存储引擎中，主键索引是聚簇索引，数据存储与索引结构合并。

2. 唯一索引（Unique Index）

定义：唯一索引确保索引列的每个值都是唯一的，但允许有空值。与主键索引类似，不同之处在于唯一索引允许列值为NULL。
特点：唯一索引的叶子节点存储索引列的值和对应的主键值。在InnoDB中，唯一索引是非聚簇索引，数据存储与索引结构分开。

3. 普通索引（Index）

定义：普通索引是最基本的索引类型，没有任何限制。索引列的值可以重复，也可以为NULL。
特点：普通索引的叶子节点存储索引列的值和对应的主键值。在InnoDB中，普通索引是非聚簇索引，数据存储与索引结构分开。

4. 全文索引（Fulltext Index）

定义：全文索引用于对文本数据进行全文搜索，适用于MyISAM存储引擎。它允许对文本字段进行复杂的搜索，如查找包含特定单词的记录。
特点：全文索引的叶子节点存储文档的词项信息。在MyISAM中，全文索引是非聚簇索引，数据存储与索引结构分开。

5. 空间索引（Spatial Index）

定义：空间索引用于对地理空间数据进行索引，支持空间数据类型的快速查询。它适用于存储地理位置、地图等空间数据的表。
特点：空间索引的叶子节点存储空间数据的索引信息。在MyISAM中，空间索引是非聚簇索引，数据存储与索引结构分开。

总结：

主键索引：用于唯一标识每一行数据，值不能为空。
唯一索引：确保索引列的值唯一，但允许有空值。
普通索引：最基本的索引类型，允许重复和空值。
全文索引：用于对文本数据进行全文搜索，适用于MyISAM存储引擎。
空间索引：用于对地理空间数据进行索引，支持空间数据类型的快速查询。

3. 详细描述一条 SQL 语句在 MySQL 中的执行过程。

连接器判断用户是否成功建立连接，数据库连接的权限校验
连接器会查询缓存，key 是 SQL 语句，value 是查询结果。如果命中，直接返回查询结果。(MySQL 8.0之后，就移除这个功能了)。
分析器分析SQL语法和词法是否有误
优化器生成SQL的执行计划，确定使用的索引和调整where的执行顺序（包括连表顺序）
执行器判断当前用户是否有权限查询该表，然后执行该SQL语句

">
<meta name="author" content="SwimmingLiu">
<link rel="canonical" href="https://swimmingliu.cn/posts/job/mysql-interview-questions/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.6ecbb0040febd20e47edd88a662c19f1ea945bf7427774b86594271d18f88faf.css" integrity="sha256-bsuwBA/r0g5H7diKZiwZ8eqUW/dCd3S4ZZQnHRj4j68=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<link rel="apple-touch-icon" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<link rel="mask-icon" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://swimmingliu.cn/posts/job/mysql-interview-questions/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ],
            
            throwOnError: false
        });
    });
</script>

<meta property="og:url" content="https://swimmingliu.cn/posts/job/mysql-interview-questions/">
  <meta property="og:site_name" content="SwimmingLiu&#39;s Blog">
  <meta property="og:title" content="MySQL面试题笔记">
  <meta property="og:description" content="1.MySQL 中的数据排序是怎么实现的？ 1.排序方法：索引排序和文件排序 (filesort)
2.索引排序：如果order by xxx的字段为索引字段，则利用索引进行排序。效率最高，索引默认有序。
3.文件排序 (filesort)：内存排序(单路排序和双路排序)和磁盘排序，具体取决于排序数据的大小。其中，内存排序使用单路排序或双路排序，取决于max_length_for_sort_data(默认为4096个字节)
4.双路排序：取row_id(如果有主键，则为主键)和select a,b,c order by xxx的xxx字段放入sort_buffer(排序缓存)中，将排序后的row_id回表查询a,b,c
5.单路排序: 直接把要查的所有字段放入sort_buffer里，排序后直接得到结果集合
6.磁盘排序（归并排序）:将数据分为多份文件，单独对文件进行排序，然后合并成一个有序的大文件
2. MySQL 的 Change Buffer 是什么？它有什么作用？ 1.ChangeBuffer定义：Change Buffer是InnoDB缓冲当中的一块缓存区，用于暂存二级索引的修改，避免二级索引页修改产生的随机IO 2.ChangeBuffer注意事项：只能用于二级索引，不能用于其他任何索引，包括主键索引和唯一索引都不行。 3.如果ChangeBuffer挂了，更改操作未执行，是否会出现脏数据？ 首先，ChangeBuffer也会保存在磁盘空间里面，redo log会记录Change Buffer当中的修改操作，确保数据一致性。
知识拓展1：一级索引和二级索引区别
一级索引（聚簇索引）：数据表的主键索引，数据和索引存储在同一B&#43;树的叶子节点中。每个表只能有一个一级索引。
二级索引（非聚簇索引）：除主键外的其他索引，叶子节点存储索引列的值和对应的主键值。通过二级索引查询时，需要先通过二级索引获取主键值，再通过主键值查询数据，这个过程称为“回表”。
知识拓展2: MySQL中有哪些常见索引？都有什么区别？
在MySQL中，索引是提高查询效率的关键工具。常见的索引类型包括主键索引、唯一索引、普通索引、全文索引和空间索引。
1. 主键索引（Primary Key Index）
定义：主键索引是一种特殊的唯一索引，用于唯一标识表中的每一行数据。每个表只能有一个主键索引，且主键列的值不能为空。 特点：主键索引的叶子节点存储完整的数据行，因此查询效率高。在InnoDB存储引擎中，主键索引是聚簇索引，数据存储与索引结构合并。 2. 唯一索引（Unique Index）
定义：唯一索引确保索引列的每个值都是唯一的，但允许有空值。与主键索引类似，不同之处在于唯一索引允许列值为NULL。 特点：唯一索引的叶子节点存储索引列的值和对应的主键值。在InnoDB中，唯一索引是非聚簇索引，数据存储与索引结构分开。 3. 普通索引（Index）
定义：普通索引是最基本的索引类型，没有任何限制。索引列的值可以重复，也可以为NULL。 特点：普通索引的叶子节点存储索引列的值和对应的主键值。在InnoDB中，普通索引是非聚簇索引，数据存储与索引结构分开。 4. 全文索引（Fulltext Index）
定义：全文索引用于对文本数据进行全文搜索，适用于MyISAM存储引擎。它允许对文本字段进行复杂的搜索，如查找包含特定单词的记录。 特点：全文索引的叶子节点存储文档的词项信息。在MyISAM中，全文索引是非聚簇索引，数据存储与索引结构分开。 5. 空间索引（Spatial Index）
定义：空间索引用于对地理空间数据进行索引，支持空间数据类型的快速查询。它适用于存储地理位置、地图等空间数据的表。 特点：空间索引的叶子节点存储空间数据的索引信息。在MyISAM中，空间索引是非聚簇索引，数据存储与索引结构分开。 总结：
主键索引：用于唯一标识每一行数据，值不能为空。 唯一索引：确保索引列的值唯一，但允许有空值。 普通索引：最基本的索引类型，允许重复和空值。 全文索引：用于对文本数据进行全文搜索，适用于MyISAM存储引擎。 空间索引：用于对地理空间数据进行索引，支持空间数据类型的快速查询。 3. 详细描述一条 SQL 语句在 MySQL 中的执行过程。 连接器判断用户是否成功建立连接，数据库连接的权限校验 连接器会查询缓存，key 是 SQL 语句，value 是查询结果。如果命中，直接返回查询结果。(MySQL 8.0之后，就移除这个功能了)。 分析器分析SQL语法和词法是否有误 优化器生成SQL的执行计划，确定使用的索引和调整where的执行顺序（包括连表顺序） 执行器判断当前用户是否有权限查询该表，然后执行该SQL语句 ">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-02-19T15:16:42+08:00">
    <meta property="article:modified_time" content="2025-09-07T21:16:42+08:00">
    <meta property="article:tag" content="Java">
    <meta property="article:tag" content="MySQL">
      <meta property="og:image" content="https://swimmingliu.cn/papermod-cover.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://swimmingliu.cn/papermod-cover.png">
<meta name="twitter:title" content="MySQL面试题笔记">
<meta name="twitter:description" content="1.MySQL 中的数据排序是怎么实现的？
1.排序方法：索引排序和文件排序 (filesort)
2.索引排序：如果order by xxx的字段为索引字段，则利用索引进行排序。效率最高，索引默认有序。
3.文件排序 (filesort)：内存排序(单路排序和双路排序)和磁盘排序，具体取决于排序数据的大小。其中，内存排序使用单路排序或双路排序，取决于max_length_for_sort_data(默认为4096个字节)
4.双路排序：取row_id(如果有主键，则为主键)和select a,b,c order by xxx的xxx字段放入sort_buffer(排序缓存)中，将排序后的row_id回表查询a,b,c
5.单路排序: 直接把要查的所有字段放入sort_buffer里，排序后直接得到结果集合
6.磁盘排序（归并排序）:将数据分为多份文件，单独对文件进行排序，然后合并成一个有序的大文件
2. MySQL 的 Change Buffer 是什么？它有什么作用？
1.ChangeBuffer定义：Change Buffer是InnoDB缓冲当中的一块缓存区，用于暂存二级索引的修改，避免二级索引页修改产生的随机IO
2.ChangeBuffer注意事项：只能用于二级索引，不能用于其他任何索引，包括主键索引和唯一索引都不行。
3.如果ChangeBuffer挂了，更改操作未执行，是否会出现脏数据？
首先，ChangeBuffer也会保存在磁盘空间里面，redo log会记录Change Buffer当中的修改操作，确保数据一致性。
知识拓展1：一级索引和二级索引区别

一级索引（聚簇索引）：数据表的主键索引，数据和索引存储在同一B&#43;树的叶子节点中。每个表只能有一个一级索引。
二级索引（非聚簇索引）：除主键外的其他索引，叶子节点存储索引列的值和对应的主键值。通过二级索引查询时，需要先通过二级索引获取主键值，再通过主键值查询数据，这个过程称为“回表”。
知识拓展2:  MySQL中有哪些常见索引？都有什么区别？

在MySQL中，索引是提高查询效率的关键工具。常见的索引类型包括主键索引、唯一索引、普通索引、全文索引和空间索引。
1. 主键索引（Primary Key Index）

定义：主键索引是一种特殊的唯一索引，用于唯一标识表中的每一行数据。每个表只能有一个主键索引，且主键列的值不能为空。
特点：主键索引的叶子节点存储完整的数据行，因此查询效率高。在InnoDB存储引擎中，主键索引是聚簇索引，数据存储与索引结构合并。

2. 唯一索引（Unique Index）

定义：唯一索引确保索引列的每个值都是唯一的，但允许有空值。与主键索引类似，不同之处在于唯一索引允许列值为NULL。
特点：唯一索引的叶子节点存储索引列的值和对应的主键值。在InnoDB中，唯一索引是非聚簇索引，数据存储与索引结构分开。

3. 普通索引（Index）

定义：普通索引是最基本的索引类型，没有任何限制。索引列的值可以重复，也可以为NULL。
特点：普通索引的叶子节点存储索引列的值和对应的主键值。在InnoDB中，普通索引是非聚簇索引，数据存储与索引结构分开。

4. 全文索引（Fulltext Index）

定义：全文索引用于对文本数据进行全文搜索，适用于MyISAM存储引擎。它允许对文本字段进行复杂的搜索，如查找包含特定单词的记录。
特点：全文索引的叶子节点存储文档的词项信息。在MyISAM中，全文索引是非聚簇索引，数据存储与索引结构分开。

5. 空间索引（Spatial Index）

定义：空间索引用于对地理空间数据进行索引，支持空间数据类型的快速查询。它适用于存储地理位置、地图等空间数据的表。
特点：空间索引的叶子节点存储空间数据的索引信息。在MyISAM中，空间索引是非聚簇索引，数据存储与索引结构分开。

总结：

主键索引：用于唯一标识每一行数据，值不能为空。
唯一索引：确保索引列的值唯一，但允许有空值。
普通索引：最基本的索引类型，允许重复和空值。
全文索引：用于对文本数据进行全文搜索，适用于MyISAM存储引擎。
空间索引：用于对地理空间数据进行索引，支持空间数据类型的快速查询。

3. 详细描述一条 SQL 语句在 MySQL 中的执行过程。

连接器判断用户是否成功建立连接，数据库连接的权限校验
连接器会查询缓存，key 是 SQL 语句，value 是查询结果。如果命中，直接返回查询结果。(MySQL 8.0之后，就移除这个功能了)。
分析器分析SQL语法和词法是否有误
优化器生成SQL的执行计划，确定使用的索引和调整where的执行顺序（包括连表顺序）
执行器判断当前用户是否有权限查询该表，然后执行该SQL语句

">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚 Posts",
      "item": "https://swimmingliu.cn/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "💻 Job",
      "item": "https://swimmingliu.cn/posts/job/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "MySQL面试题笔记",
      "item": "https://swimmingliu.cn/posts/job/mysql-interview-questions/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MySQL面试题笔记",
  "name": "MySQL面试题笔记",
  "description": "1.MySQL 中的数据排序是怎么实现的？ 1.排序方法：索引排序和文件排序 (filesort)\n2.索引排序：如果order by xxx的字段为索引字段，则利用索引进行排序。效率最高，索引默认有序。\n3.文件排序 (filesort)：内存排序(单路排序和双路排序)和磁盘排序，具体取决于排序数据的大小。其中，内存排序使用单路排序或双路排序，取决于max_length_for_sort_data(默认为4096个字节)\n4.双路排序：取row_id(如果有主键，则为主键)和select a,b,c order by xxx的xxx字段放入sort_buffer(排序缓存)中，将排序后的row_id回表查询a,b,c\n5.单路排序: 直接把要查的所有字段放入sort_buffer里，排序后直接得到结果集合\n6.磁盘排序（归并排序）:将数据分为多份文件，单独对文件进行排序，然后合并成一个有序的大文件\n2. MySQL 的 Change Buffer 是什么？它有什么作用？ 1.ChangeBuffer定义：Change Buffer是InnoDB缓冲当中的一块缓存区，用于暂存二级索引的修改，避免二级索引页修改产生的随机IO 2.ChangeBuffer注意事项：只能用于二级索引，不能用于其他任何索引，包括主键索引和唯一索引都不行。 3.如果ChangeBuffer挂了，更改操作未执行，是否会出现脏数据？ 首先，ChangeBuffer也会保存在磁盘空间里面，redo log会记录Change Buffer当中的修改操作，确保数据一致性。\n知识拓展1：一级索引和二级索引区别\n一级索引（聚簇索引）：数据表的主键索引，数据和索引存储在同一B+树的叶子节点中。每个表只能有一个一级索引。\n二级索引（非聚簇索引）：除主键外的其他索引，叶子节点存储索引列的值和对应的主键值。通过二级索引查询时，需要先通过二级索引获取主键值，再通过主键值查询数据，这个过程称为“回表”。\n知识拓展2: MySQL中有哪些常见索引？都有什么区别？\n在MySQL中，索引是提高查询效率的关键工具。常见的索引类型包括主键索引、唯一索引、普通索引、全文索引和空间索引。\n1. 主键索引（Primary Key Index）\n定义：主键索引是一种特殊的唯一索引，用于唯一标识表中的每一行数据。每个表只能有一个主键索引，且主键列的值不能为空。 特点：主键索引的叶子节点存储完整的数据行，因此查询效率高。在InnoDB存储引擎中，主键索引是聚簇索引，数据存储与索引结构合并。 2. 唯一索引（Unique Index）\n定义：唯一索引确保索引列的每个值都是唯一的，但允许有空值。与主键索引类似，不同之处在于唯一索引允许列值为NULL。 特点：唯一索引的叶子节点存储索引列的值和对应的主键值。在InnoDB中，唯一索引是非聚簇索引，数据存储与索引结构分开。 3. 普通索引（Index）\n定义：普通索引是最基本的索引类型，没有任何限制。索引列的值可以重复，也可以为NULL。 特点：普通索引的叶子节点存储索引列的值和对应的主键值。在InnoDB中，普通索引是非聚簇索引，数据存储与索引结构分开。 4. 全文索引（Fulltext Index）\n定义：全文索引用于对文本数据进行全文搜索，适用于MyISAM存储引擎。它允许对文本字段进行复杂的搜索，如查找包含特定单词的记录。 特点：全文索引的叶子节点存储文档的词项信息。在MyISAM中，全文索引是非聚簇索引，数据存储与索引结构分开。 5. 空间索引（Spatial Index）\n定义：空间索引用于对地理空间数据进行索引，支持空间数据类型的快速查询。它适用于存储地理位置、地图等空间数据的表。 特点：空间索引的叶子节点存储空间数据的索引信息。在MyISAM中，空间索引是非聚簇索引，数据存储与索引结构分开。 总结：\n主键索引：用于唯一标识每一行数据，值不能为空。 唯一索引：确保索引列的值唯一，但允许有空值。 普通索引：最基本的索引类型，允许重复和空值。 全文索引：用于对文本数据进行全文搜索，适用于MyISAM存储引擎。 空间索引：用于对地理空间数据进行索引，支持空间数据类型的快速查询。 3. 详细描述一条 SQL 语句在 MySQL 中的执行过程。 连接器判断用户是否成功建立连接，数据库连接的权限校验 连接器会查询缓存，key 是 SQL 语句，value 是查询结果。如果命中，直接返回查询结果。(MySQL 8.0之后，就移除这个功能了)。 分析器分析SQL语法和词法是否有误 优化器生成SQL的执行计划，确定使用的索引和调整where的执行顺序（包括连表顺序） 执行器判断当前用户是否有权限查询该表，然后执行该SQL语句 ",
  "keywords": [
    "Java", "MySQL"
  ],
  "articleBody": "1.MySQL 中的数据排序是怎么实现的？ 1.排序方法：索引排序和文件排序 (filesort)\n2.索引排序：如果order by xxx的字段为索引字段，则利用索引进行排序。效率最高，索引默认有序。\n3.文件排序 (filesort)：内存排序(单路排序和双路排序)和磁盘排序，具体取决于排序数据的大小。其中，内存排序使用单路排序或双路排序，取决于max_length_for_sort_data(默认为4096个字节)\n4.双路排序：取row_id(如果有主键，则为主键)和select a,b,c order by xxx的xxx字段放入sort_buffer(排序缓存)中，将排序后的row_id回表查询a,b,c\n5.单路排序: 直接把要查的所有字段放入sort_buffer里，排序后直接得到结果集合\n6.磁盘排序（归并排序）:将数据分为多份文件，单独对文件进行排序，然后合并成一个有序的大文件\n2. MySQL 的 Change Buffer 是什么？它有什么作用？ 1.ChangeBuffer定义：Change Buffer是InnoDB缓冲当中的一块缓存区，用于暂存二级索引的修改，避免二级索引页修改产生的随机IO 2.ChangeBuffer注意事项：只能用于二级索引，不能用于其他任何索引，包括主键索引和唯一索引都不行。 3.如果ChangeBuffer挂了，更改操作未执行，是否会出现脏数据？ 首先，ChangeBuffer也会保存在磁盘空间里面，redo log会记录Change Buffer当中的修改操作，确保数据一致性。\n知识拓展1：一级索引和二级索引区别\n一级索引（聚簇索引）：数据表的主键索引，数据和索引存储在同一B+树的叶子节点中。每个表只能有一个一级索引。\n二级索引（非聚簇索引）：除主键外的其他索引，叶子节点存储索引列的值和对应的主键值。通过二级索引查询时，需要先通过二级索引获取主键值，再通过主键值查询数据，这个过程称为“回表”。\n知识拓展2: MySQL中有哪些常见索引？都有什么区别？\n在MySQL中，索引是提高查询效率的关键工具。常见的索引类型包括主键索引、唯一索引、普通索引、全文索引和空间索引。\n1. 主键索引（Primary Key Index）\n定义：主键索引是一种特殊的唯一索引，用于唯一标识表中的每一行数据。每个表只能有一个主键索引，且主键列的值不能为空。 特点：主键索引的叶子节点存储完整的数据行，因此查询效率高。在InnoDB存储引擎中，主键索引是聚簇索引，数据存储与索引结构合并。 2. 唯一索引（Unique Index）\n定义：唯一索引确保索引列的每个值都是唯一的，但允许有空值。与主键索引类似，不同之处在于唯一索引允许列值为NULL。 特点：唯一索引的叶子节点存储索引列的值和对应的主键值。在InnoDB中，唯一索引是非聚簇索引，数据存储与索引结构分开。 3. 普通索引（Index）\n定义：普通索引是最基本的索引类型，没有任何限制。索引列的值可以重复，也可以为NULL。 特点：普通索引的叶子节点存储索引列的值和对应的主键值。在InnoDB中，普通索引是非聚簇索引，数据存储与索引结构分开。 4. 全文索引（Fulltext Index）\n定义：全文索引用于对文本数据进行全文搜索，适用于MyISAM存储引擎。它允许对文本字段进行复杂的搜索，如查找包含特定单词的记录。 特点：全文索引的叶子节点存储文档的词项信息。在MyISAM中，全文索引是非聚簇索引，数据存储与索引结构分开。 5. 空间索引（Spatial Index）\n定义：空间索引用于对地理空间数据进行索引，支持空间数据类型的快速查询。它适用于存储地理位置、地图等空间数据的表。 特点：空间索引的叶子节点存储空间数据的索引信息。在MyISAM中，空间索引是非聚簇索引，数据存储与索引结构分开。 总结：\n主键索引：用于唯一标识每一行数据，值不能为空。 唯一索引：确保索引列的值唯一，但允许有空值。 普通索引：最基本的索引类型，允许重复和空值。 全文索引：用于对文本数据进行全文搜索，适用于MyISAM存储引擎。 空间索引：用于对地理空间数据进行索引，支持空间数据类型的快速查询。 3. 详细描述一条 SQL 语句在 MySQL 中的执行过程。 连接器判断用户是否成功建立连接，数据库连接的权限校验 连接器会查询缓存，key 是 SQL 语句，value 是查询结果。如果命中，直接返回查询结果。(MySQL 8.0之后，就移除这个功能了)。 分析器分析SQL语法和词法是否有误 优化器生成SQL的执行计划，确定使用的索引和调整where的执行顺序（包括连表顺序） 执行器判断当前用户是否有权限查询该表，然后执行该SQL语句 [参考文献] 执行一条 select 语句，期间发生了什么？\n[补充] 3. MySQL 日志：undo log、redo log、binlog 有什么用？ undo log（回滚日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和 MVCC。 redo log（重做日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的持久性，主要用于掉电等故障恢复； binlog （归档日志）：是 Server 层生成的日志，主要用于数据备份和主从复制；\n直接看参考文献当中的七个问题和其解决方案\n[参考文献] MySQL 日志：undo log、redo log、binlog 有什么用？\n4. MySQL 的存储引擎有哪些？它们之间有什么区别？ InnoDB : 支持事务、行锁、外键; 高并发性能、支持高负载的OLTP应用 (银行交易、电子商务订单、库存管理等); 聚集索引存储，检索效率高\nMyISAM: 表锁、不支持事务和外键; 适用于读多写少的场景(数据仓库); 较高读性能和j较快的表级锁定\nMEMORY: 存储在内存中，速度快，重启后数据丢失; 适用于临时数据存储和快速存储\n5. MySQL 的索引类型有哪些？ 划分方向 索引类型 数据结构 B+树索引、Hash索引、倒排索引 (全文索引)、R-树索引 (多维空间树)、位图索引(Bitmap) 物理存储 聚簇索引、非聚簇索引 字段特性 主键索引、唯一索引、普通索引(二级索引、辅助索引)、前缀索引 字段个数 单列索引、联合索引 6. MySQL InnoDB 引擎中的聚簇索引和非聚簇索引有什么区别？ 聚簇索引：就像是图书馆里按照书籍主题顺序摆放的书架。在这个书架（也就是聚簇索引）上，每本书（也就是数据库中的行数据）都是按照某个主题（通常是主键）来排列的。所以，当你想要找某一主题的书时，只要知道主题名（主键值），就能很快在书架上找到它，而且相邻主题的书也是挨在一起的，找起来很方便。但是，这种方式的缺点是，如果你想要改变某本书的主题（更新主键），可能就需要移动整本书到新的位置，甚至可能需要重新整理整个书架（数据页），这样就比较麻烦了。\n非聚簇索引：则更像是图书馆里的一个索引卡片箱。在这个卡片箱里，每张卡片（也就是非聚簇索引的节点）上都写着书籍的主题（索引列的值）和书籍在书架上的位置（主键值或ROWID）。当你想要找一本书时，可以先在卡片箱里找到对应的卡片，然后根据卡片上的位置信息去书架上找书。这种方式的好处是灵活，你可以为不同的书籍主题制作多张卡片，方便从不同的角度查找书籍。但是，坏处是每次找书都需要两步：先在卡片箱里找卡片，再去书架上找书，这样可能会比直接在书架上找书要慢一些。\n总的来说，聚簇索引和非聚簇索引的主要区别在于它们如何存储数据和索引，以及它们如何影响数据的查询和更新操作。聚簇索引将数据直接存储在索引上，查询效率高，但更新操作可能较复杂；而非聚簇索引则通过索引指向数据，提供了更多的灵活性，但查询时可能需要额外的步骤。在选择使用哪种索引时，需要根据具体的应用场景和查询需求来决定。\n聚簇索引 (Clustered Index)：它的叶子节点存储了 完整的用户数据行。可以理解为“数据就是索引，索引就是数据”。\n非聚簇索引 (Non-Clustered Index)，也叫二级索引(Secondary Index)：它的叶子节点存储的是 索引列的值 以及对应数据行的 主键值。\n特性 聚簇索引 (Clustered Index) 非聚簇索引 (Non-Clustered Index / Secondary Index) 数量 每张表只能有一个 每张表可以有多个 叶子节点存储 完整的行数据 索引列 + 主键值 数据存储方式 数据本身按索引顺序物理存储 索引和数据分离存储 查询效率 基于主键的查询和范围查询速度极快 依赖“回表”，可能需要两次B+树查询，速度相对较慢（除非触发覆盖索引） 插入/更新性能 插入速度依赖于主键的有序性，可能导致“页分裂”，维护成本较高 维护成本相对较低，只需要维护自身的B+树结构 优点 1. 主键查询快。\n2. 范围查询性能好（数据物理连续）。 1. 结构更轻量。\n2. 避免了频繁移动数据行。 缺点 1. 插入无序主键（如UUID）性能差。\n2. 更新主键的代价极高。\n3. 二级索引查询需要回表。 1. 查询可能需要回表，产生额外I/O。\n2. 不适合进行大范围的范围查询。 graph LR subgraph \"非聚簇索引 (name)\" A[B+树根节点] --\u003e B{非叶子节点}; B --\u003e C[叶子节点\nname='Tom', id=18]; end subgraph \"聚簇索引 (id/主键)\" D[B+树根节点] --\u003e E{非叶子节点}; E --\u003e F[叶子节点\nid=18, name='Tom', age=25, ...]; end C -- \"1. 查name索引拿到主键id=18\" --\u003e G((回表过程)); G -- \"2. 用主键id=18查聚簇索引\" --\u003e F; F -- \"3. 获取整行数据,返回age=25\" --\u003e H((查询结果)); style C fill:#f9f,stroke:#333,stroke-width:2px style F fill:#ccf,stroke:#333,stroke-width:2px 7. MySQL 中的回表是什么？ 回表：指使用非聚簇索引（二级索引）查询时，由于索引中只存储了索引列的值和主键值，当需要获取其他列的数据时，必须通过主键再次访问聚簇索引（主键索引）来获取完整行数据的过程。\ngraph LR subgraph \"客户端查询\" A[SELECT age FROM user WHERE name = 'Tom'] end subgraph \"二级索引(name索引)\" B[\"B+树根节点(name索引)\"] C[\"非叶子节点\"] D[\"叶子节点name='Tom', id=18\"] end subgraph \"聚簇索引(主键索引)\" E[\"B+树根节点(主键索引)\"] F[\"非叶子节点\"] G[\"叶子节点id=18, name='Tom', age=25, address='北京'\"] end subgraph \"回表过程\" H[\"步骤1: 查找name索引\"] I[\"步骤2: 获取主键id=18\"] J[\"步骤3: 用主键查聚簇索引\"] K[\"步骤4: 返回完整行数据\"] end A --\u003e B B --\u003e C C --\u003e D D --\u003e H H --\u003e I I --\u003e J J --\u003e E E --\u003e F F --\u003e G G --\u003e K K --\u003e L[\"返回: age=25\"] style D fill:#ffb3ba style G fill:#bae1ff style H fill:#ffffba style I fill:#ffffba style J fill:#ffffba style K fill:#ffffba 为什么需要回表：使用非聚簇索引的二级索引查询时，只能查到索引列的值和其主键值，无法获取其他数据\n回表的缺点：回表会带来随机I/O, 频繁回表会导致效率非常低。所以不推荐使用 select *\n回表的其他场景：当查询的部分列没有包含在索引中时，即便使用了索引，也需要会去获取缺失的列数据，称为覆盖索引缺失。\n覆盖索引缺失发送场景：select 语句当中包含了非索引列; 索引的类型为 Hash 和 full-text 索引 （不存储列的值），不支持覆盖索引。\n如何减少回表：开启索引下推、使用覆盖索引、延迟关联\n覆盖索引：只查询索引中包含的字段 （完全避免回表操作）\n索引下推：在索引层将数据尽可能多的过滤掉，避免将数据查出来之后再过滤（减少回表的数据量）\n延迟关联：手动先获取所有的二级索引的主键，然后一次性通过主键批量化获取数据 （减少回表次数）\n优化策略 适用场景 优点 缺点 实现难度 覆盖索引 查询字段固定且较少 完全避免回表，性能最佳 索引存储空间增大，维护成本高 简单 索引下推 复合条件查询 自动优化，减少回表数量 需要MySQL 5.6+支持 无需额外实现 延迟关联 大数据量分页查询 显著减少回表次数 查询逻辑复杂，需要两次查询 中等 选择合适字段 所有查询场景 减少不必要的数据传输 需要明确业务需求 简单 graph TD A[\"避免回表的策略\"] --\u003e B[\"覆盖索引\"] A --\u003e C[\"索引下推\"] A --\u003e D[\"延迟关联\"] B --\u003e B1[\"创建包含所需列的复合索引\"] B --\u003e B2[\"只查询索引中包含的字段\"] B --\u003e B3[\"完全避免回表\"] C --\u003e C1[\"MySQL 5.6+ 默认开启\"] C --\u003e C2[\"在索引层面过滤数据\"] C --\u003e C3[\"减少回表的数据量\"] D --\u003e D1[\"先通过索引获取主键\"] D --\u003e D2[\"再用主键批量获取数据\"] D --\u003e D3[\"减少回表次数\"] style B fill:#e1f5fe style C fill:#f3e5f5 style D fill:#e8f5e8 8. MySQL索引的最左前缀匹配原则是什么? 最左前缀匹配原则的定义：使用联合索引的时候，查询的条件必须从索引的最左侧开始匹配。如果联合索引包含多个列，查询条件必须包含第一个列，然后是第二个列，以此类推。 最左前缀匹配原则的原理：联合索引在B+树中的排列方式遵循从左到右的原则，例如联合索引(a, b, c)，在查询时，首先按照a的值进行排序，如果a的值相同，再查b的值，以此类推。 常见场景：= 、\u003e= 、\u003c= 、 BETWEEN 、like (xx%) 都包含等值的情况，可以定位到某个数，然后进行范围扫描，不会出现停止匹配的现象。但是 \u003e 和 \u003c 则不行。 部分不符合最左前缀匹配原则也能使用索引的原因：MySQL8当中引入了 Skip Can Range Access Method, 将缺失的左边的值查出来，如果左边缺失的列数据量少，则拼凑左边的索引，让SQL符合最左前缀匹配原则。 9. MySQL的覆盖索引是什么？ 覆盖索引定义：查询的所有字段都是二级索引，从而使查询可以直接访问二级索引二不需要访问实习的表数据(主键索引)。 覆盖索引优点：减少I/O操作 ; 提高查询速度 (索引比表数据更加紧凑); 减少内存占用 (读取的索引页面而不是表数据页面) 对比维度 覆盖索引 非覆盖索引 数据获取方式 直接从二级索引获取全部所需数据 需要通过主键回表到聚簇索引获取数据 I/O操作次数 1次(仅访问二级索引) 2次(访问二级索引+聚簇索引) 查询性能 高(减少磁盘I/O) 相对较低(额外的回表开销) 内存占用 低(索引页面更紧凑) 高(需要加载完整数据页) 适用场景 select字段都在索引中 select字段超出索引范围 graph LR A[客户端发起查询] --\u003e B{分析查询语句} B --\u003e C[解析索引使用情况] C --\u003e D{是否为覆盖索引?} D --\u003e|是| E[直接在二级索引中获取数据] E --\u003e F[返回查询结果] D --\u003e|否| G[在二级索引中查找主键ID] G --\u003e H[使用主键ID回表查询] H --\u003e I[在聚簇索引中查找完整行数据] I --\u003e J[返回查询结果] F --\u003e K[查询完成] J --\u003e K style E fill:#90EE90 style F fill:#90EE90 style H fill:#FFB6C1 style I fill:#FFB6C1 10. MySQL的索引下推 (ICP) 是什么? 索引下推(ICP)定义: 减少回表查询，提高查询效率的行为。允许MySQL使用索引查找数据的时候，将部分查询条件下推到存储引擎层进行过滤，从而减少需要从表中读取的数据行，减少I/O。\n应用场景：比如当前表建了一个联合索引(a, b, c)，使用where条件的时候，由于b用得是 like '%xxx%' 需要回表查询 (like 'xx%' 不需要)。即先查询 a = '1' 的数据， 然后回表查询，最后进行where条件的过滤。如果使用索引下推之后 (MySQL 5.6)，在查完a = '1'的数据之后，可以先由存储引擎层进行where条件过滤，然后再回表查询， 减少回表查询的次数。\nSELECT * FROM people WHERE a='1' AND b LIKE '%123%' 如联合索引index_name_age，假设数据库中有数据（张三，18）、（张三，28）、（张三，48）、（张三，8)\n【没有索引下推】查询name=‘张三’和age\u003e30的数据时，会先匹配有四条数据name=‘张三’匹配成功，回表四次查询出带有name=‘张三’的四条数据，然后再根据age\u003e30对这四条数据进行范围查找\n【使用索引下推】查询name=‘张三’和age\u003e30的数据时，会先匹配有四条数据name=‘张三’匹配成功，然后age\u003e30的数据，过滤完成后，再用主键索引去进行一次回表操作\ngraph TB subgraph \"无索引下推 (MySQL 5.6之前)\" A1[存储引擎层] --\u003e A2[根据索引条件查找记录] A2 --\u003e A3[返回所有符合索引条件的主键] A3 --\u003e A4[Server层] A4 --\u003e A5[逐条回表获取完整记录] A5 --\u003e A6[在Server层应用WHERE条件过滤] A6 --\u003e A7[返回最终结果] end subgraph \"有索引下推 (MySQL 5.6+)\" B1[存储引擎层] --\u003e B2[根据索引条件查找记录] B2 --\u003e B3[在存储引擎层直接应用WHERE条件] B3 --\u003e B4{记录是否满足下推条件?} B4 --\u003e|是| B5[添加主键到结果集] B4 --\u003e|否| B6[丢弃该记录] B6 --\u003e B3 B5 --\u003e B7[返回过滤后的主键列表] B7 --\u003e B8[Server层] B8 --\u003e B9[回表获取完整记录] B9 --\u003e B10[返回最终结果] end style B3 fill:#90EE90 style B4 fill:#90EE90 style A5 fill:#FFB6C1 style A6 fill:#FFB6C1 11. MySQL建索引需要注意哪些事项？ 【索引适合场景】\n频繁使用where 、order by 、group by、distinct 的字段 (加快操作速度) 关联字段 (如果没有索引，连接的过程中，每个只都会进行一次全表扫描) 【不适合场景】\n字段频繁更新 (更新除了修改数据外，还需要维护索引信息 =\u003e 调整B+树会降低性能) 字段值重复率高（区分度低，建立索引更加消耗资源） 参与列计算的字段 (索引会失效) 长字段 (text、 longtext) ：长字段占据的内存大，提升性能不明显。 【注】索引不是越多越好，因为每次修改都需要维护索引数据，消耗资源\n12. MySQL中使用索引一定有效吗？如何排查索引效果？ 【索引失效的情况】\n联合索引不符合最左匹配原则 对索引列使用了运算(where id + 3 = 8)、函数 (lower()、count())、like '%xx%' 等操作 对索引列和非索引列使用 or 操作 (where name = \"swimmingliu\" or age = 34) 索引列类型不匹配导致的强制转换 (where name = 1 ==\u003e where CAST(name AS signed int) = 1) graph TD A[MySQL索引失效场景] --\u003e B[查询条件问题] A --\u003e C[索引结构问题] A --\u003e D[数据类型问题] A --\u003e E[优化器选择问题] B --\u003e B1[最左前缀原则违反] B --\u003e B2[函数和运算操作] B --\u003e B3[通配符问题] B --\u003e B4[范围查询问题] B --\u003e B5[OR操作符问题] C --\u003e C2[索引覆盖失效] D --\u003e D1[数据类型不匹配] D --\u003e D2[隐式类型转换] E --\u003e E1[数据分布不均匀] E --\u003e E2[表数据量过小] E --\u003e E3[查询成本评估] 【如何查看失效】\n利用explain命令 (前面最好加上analyse table xxx)\nEXPLAIN 的 type 表示查询的访问类型，影响查询的效率。常见的值：\nref: 使用索引，查找匹配某个单一列的值（比如通过外键查找）。比 range 更高效。 range: 使用索引扫描某个范围内的值，适用于 BETWEEN、\u003e \u003c 等条件。 index: 全索引扫描，扫描整个索引结构，不读表数据，通常效率比全表扫描好。 all: 全表扫描，没有使用索引 总结：ref \u003e range \u003e index \u003e all。\n13. MySQL的索引数是否越多越好？why? 索引不是越多越好，因为对索引字段进行更新操作，需要调整B+树的结构，会导致数据库增加开销。\n【注】阿里巴巴规范上表示索引一般不超过16个\n**【时间开销】**进行增删改操作的时候，索引也必须更新。索引越多，需要修改的地方就越多，时间开销大。B+树可能会出现页分裂、合并等操作，时间开销更大。\n【空间开销】 建立二级索引，都需要新建一个B+树，每个数据页面都是16KB。如果数据大，索引又多，占用的空间不小。\n14. 为什么 MySQL 选择使用 B+ 树作为索引结构？ 【B+树结构】\ngraph TD subgraph \"B+树整体结构\" Root[\"根节点索引页[20, 50, 80]\"] subgraph \"第二层-非叶子节点\" Node1[\"非叶子节点1[5, 10, 15]\"] Node2[\"非叶子节点2[25, 35, 45]\"] Node3[\"非叶子节点3[55, 65, 75]\"] Node4[\"非叶子节点4[85, 90, 95]\"] end subgraph \"第三层-叶子节点(数据页)\" Leaf1[\"叶子节点1key: 1,3,5data: 行记录1,3,5\"] Leaf2[\"叶子节点2key: 8,10,12data: 行记录8,10,12\"] Leaf3[\"叶子节点3key: 15,18,20data: 行记录15,18,20\"] Leaf4[\"叶子节点4key: 22,25,28data: 行记录22,25,28\"] Leaf5[\"叶子节点5key: 32,35,38data: 行记录32,35,38\"] Leaf6[\"叶子节点6key: 42,45,48data: 行记录42,45,48\"] Leaf7[\"叶子节点7key: 52,55,58data: 行记录52,55,58\"] Leaf8[\"叶子节点8key: 62,65,68data: 行记录62,65,68\"] Leaf9[\"叶子节点9key: 72,75,78data: 行记录72,75,78\"] Leaf10[\"叶子节点10key: 82,85,88data: 行记录82,85,88\"] Leaf11[\"叶子节点11key: 90,92,95data: 行记录90,92,95\"] Leaf12[\"叶子节点12key: 97,98,99data: 行记录97,98,99\"] end Root --\u003e Node1 Root --\u003e Node2 Root --\u003e Node3 Root --\u003e Node4 Node1 --\u003e Leaf1 Node1 --\u003e Leaf2 Node1 --\u003e Leaf3 Node2 --\u003e Leaf4 Node2 --\u003e Leaf5 Node2 --\u003e Leaf6 Node3 --\u003e Leaf7 Node3 --\u003e Leaf8 Node3 --\u003e Leaf9 Node4 --\u003e Leaf10 Node4 --\u003e Leaf11 Node4 --\u003e Leaf12 Leaf1 -.-\u003e Leaf2 Leaf2 -.-\u003e Leaf3 Leaf3 -.-\u003e Leaf4 Leaf4 -.-\u003e Leaf5 Leaf5 -.-\u003e Leaf6 Leaf6 -.-\u003e Leaf7 Leaf7 -.-\u003e Leaf8 Leaf8 -.-\u003e Leaf9 Leaf9 -.-\u003e Leaf10 Leaf10 -.-\u003e Leaf11 Leaf11 -.-\u003e Leaf12 end 【B+树的优势】\n高效的查找性能：B+树是一种自平衡树，每个叶子结点到根节点的路径长度相同。增删改查的事件复杂度都是O(logn)，且具有一定的冗余节点，删除节点的时候，树的结构变化较小。 I/O次数相对较少：首先，B+树不会像红黑树一样，随着数据的增多树变得越来越高，它是多叉树。计算机访问数据时，往往具有局部性原理。当读取一个节点时，B树和B+树会将多个相关的数据加载到内存中，后续直接从内存反问，减少了磁盘的I/O。另外，相较于B树来说， B+树所有的数据都存放在叶子节点，而不像B树会在非叶子节点存储数据。B+树的非叶子节点仅存储索引值/主键和页面指针。 对范围查询友好：B+树的叶子节点之间通过链表链接。当使用between语句时，会从根节点找到满足条件的起始记录。然后从起始记录，沿着叶子结点的链表进行顺序遍历。 【B+树存在的部分缺点】\n当插入和删除节点，会触发分裂和合并操作，保持树的平衡，有一定的开销。\n【跳表】\n跳表其实就是一个多级链表，为了让链表更高效的查询。在不同的部分插入高级索引，让其能够缩小查找范围。有一种二分的思想在里面。其中，Redis的有序集合(sorted set)底层的结构就是跳表结构。\n【为什么MySQL不用跳表而用B+树】\n跳表的I/O效率低：B+树通常只有3~4层，可以存储海量的数据。B+树的节点大小设计适配磁盘页的大小，磁盘页能够顺序存储大量数据。一次磁盘I/O操作就能读取节点的数据，减少I/O。跳表是多级索引的结构，虽然可以加速查找，但是其查找的过程当中会涉及到多次随机的I/O。 范围查询： B+树的叶子节点是有序链表，在采用between时，能够找从叶子结点按照链表顺序遍历即可。跳表虽然支持范围查询，但是实现起来很复杂， 而且其多层的索引结构，范围查询时不能像B+树那样直接高效。 跳表维护成本高：B+树在增删改的时候，有高效的算法平衡树结构，确保性能稳定。而跳表在新增和删除操作的时候，涉及多层链表的调整，开销较大，容易出现性能波动。 跳表内存占用大：B+树的节点紧凑，非叶子节点只存储索引项和页面指针。而跳表除了每个节点存储数据以外，还需要额外的开销存储多层索引。相同数据量下，跳表的开销比B+树大得多。 【B+树索引的SQL执行过程】\nsequenceDiagram participant Client as SQL客户端 participant Parser as SQL解析器 participant Optimizer as 查询优化器 participant Engine as 存储引擎 participant Buffer as 缓冲池 participant Disk as 磁盘 Client-\u003e\u003eParser: SELECT * FROM users WHERE id = 45 Parser-\u003e\u003eOptimizer: 解析后的查询树 Optimizer-\u003e\u003eEngine: 选择索引访问路径 Note over Engine: 开始B+树索引查找 Engine-\u003e\u003eBuffer: 检查根节点页面是否在内存 alt 根节点不在内存 Buffer-\u003e\u003eDisk: 读取根节点页面 Disk--\u003e\u003eBuffer: 返回根节点数据 end Buffer--\u003e\u003eEngine: 根节点: [20, 50, 80] Note over Engine: 45 \u003e= 20 \u0026\u0026 45 \u003c 50, 选择第二个指针 Engine-\u003e\u003eBuffer: 检查中间节点页面是否在内存 alt 中间节点不在内存 Buffer-\u003e\u003eDisk: 读取中间节点页面 Disk--\u003e\u003eBuffer: 返回中间节点数据 end Buffer--\u003e\u003eEngine: 中间节点: [25, 35, 45] Note over Engine: 45 \u003e= 45, 选择第三个指针 Engine-\u003e\u003eBuffer: 检查叶子节点页面是否在内存 alt 叶子节点不在内存 Buffer-\u003e\u003eDisk: 读取叶子节点页面 Disk--\u003e\u003eBuffer: 返回叶子节点数据 end Buffer--\u003e\u003eEngine: 叶子节点: [42, 45, 48] + 对应行数据 Note over Engine: 在叶子节点中找到key=45对应的完整行记录 Engine--\u003e\u003eOptimizer: 返回查询结果 Optimizer--\u003e\u003eParser: 格式化结果 Parser--\u003e\u003eClient: 返回查询结果集 15. MySQL 三层 B+ 树能存多少数据？ 算法名称 数据页大小 叶子节点存储的数据记录大小 (假设) 节点的索引值(主键大小) 节点的页面指针大小 B+树 16KB 1KB 8B （bigint） 6B 【三层B+树存储数据计算】\nnodesCount = 16 * 1024 / (6 + 8) = 1170 // 每个节点可以存多少个子节点 recordCount = 16KB / 1KB = 16 // 每个节点可以存多少条数据记录 dataCount = nodesCount * nodesCount * recordCount = 1170 * 1170 * 16 = 21,902,400 所以如果一条数据为1KB大小，B+树大约能存2000w条数据 【拓展】\nMySQL的InnoDB引擎中，B+树m每个节点的数据页大小可以通过调整innodb_page_size来修改 (一般为 4KB / 8KB / 16KB)\n16. MySQL如何进行SQL调优 分为预防和解决慢查询两个角度阐述。总结起来就三点，命中索引、减少回表、减少I/O.\n【预防】\n合理设计索引，减少回表次数，减少I/O 避免 select * 操作。因为正常情况下，部分字段是没有二次索引的，它会用主键id或者rowid 进行回表查询，会增加系统的I/O。 避免让索引失效，比如对索引字段进行计算、聚合函数、非同类型比较 (强制转换)和范围查询 (\u003e、\u003c、like %xxx%)。还有联合索引不匹配最左前缀原则 避免对非索引字段，使用group by、order by、dinstinct等函数 连表查询的是否需要保持不同字段的字符集一致，不然也会导致全表扫描。比如A表用utf-8，B表用latin1，查询的是否需要进行字符集转换，需要额外的计算，不能使用索引。 【解决慢查询】\n开启慢SQL日志记录功能，使用set global slow_query_log = \"ON\"， 默认是关闭的。设置一个查询延迟的阈值，把超过规定时间的SQL查询找出来。 利用explain关键字分析慢SQL的原因，比如看看是否有索引失效、select *等情况 graph LR subgraph \"MySQL性能调优方法体系\" A[\"SQL层面优化\"] --\u003e A1[\"索引优化\"] A --\u003e A2[\"SQL语句优化\"] A --\u003e A3[\"表结构优化\"] A1 --\u003e A11[\"创建合适索引\"] A1 --\u003e A12[\"避免索引失效\"] A1 --\u003e A13[\"覆盖索引\"] A1 --\u003e A14[\"索引下推ICP\"] A2 --\u003e A21[\"避免SELECT *\"] A2 --\u003e A22[\"优化JOIN查询\"] A2 --\u003e A23[\"合理使用分页\"] A2 --\u003e A24[\"批量操作\"] A3 --\u003e A31[\"字段类型选择\"] A3 --\u003e A32[\"范式反范式权衡\"] A3 --\u003e A33[\"垂直分表\"] B[\"架构层面优化\"] --\u003e B1[\"读写分离\"] B --\u003e B2[\"分库分表\"] B --\u003e B3[\"缓存机制\"] B --\u003e B4[\"数据冷热分离\"] B1 --\u003e B11[\"主从复制\"] B1 --\u003e B12[\"负载均衡\"] B2 --\u003e B21[\"水平分片\"] B2 --\u003e B22[\"垂直分片\"] B3 --\u003e B31[\"Redis缓存\"] B3 --\u003e B32[\"查询缓存\"] C[\"系统层面优化\"] --\u003e C1[\"硬件配置\"] C --\u003e C2[\"参数调优\"] C --\u003e C3[\"连接池配置\"] C1 --\u003e C11[\"SSD硬盘\"] C1 --\u003e C12[\"增加内存\"] C2 --\u003e C21[\"innodb_buffer_pool_size\"] C2 --\u003e C22[\"max_connections\"] C3 --\u003e C31[\"连接池大小\"] C3 --\u003e C32[\"超时设置\"] D[\"监控诊断\"] --\u003e D1[\"慢查询日志\"] D --\u003e D2[\"EXPLAIN分析\"] D --\u003e D3[\"Performance Schema\"] D --\u003e D4[\"监控工具\"] end [补充] 16.1 MySQL中的慢SQL如何排查 （完整排查链路） 【慢SQL完成排查流程】\nflowchart LR A[\"发现慢SQL\"] --\u003e B{\"慢SQL来源\"} B --\u003e B1[\"慢查询日志\"] B --\u003e B2[\"监控告警\"] B --\u003e B3[\"应用响应慢\"] B1 --\u003e C[\"开启慢查询日志\nlong_query_time=1\"] B2 --\u003e C B3 --\u003e C C --\u003e D[\"定位具体SQL语句\"] D --\u003e E[\"使用EXPLAIN分析执行计划\"] E --\u003e F{\"执行计划分析\"} F --\u003e F1[\"type: ALL/index\n(全表扫描)\"] F --\u003e F2[\"key: NULL\n(未使用索引)\"] F --\u003e F3[\"rows: 很大\n(扫描行数多)\"] F --\u003e F4[\"Extra: Using filesort\nUsing temporary\"] F1 --\u003e G[\"索引优化\"] F2 --\u003e G F3 --\u003e G F4 --\u003e G G --\u003e H{\"优化策略选择\"} H --\u003e H1[\"创建索引\"] H --\u003e H2[\"SQL重写\"] H --\u003e H3[\"表结构调整\"] H --\u003e H4[\"分库分表\"] H1 --\u003e I1[\"单列索引\n复合索引\n覆盖索引\"] H2 --\u003e I2[\"JOIN优化\n子查询优化\n分页优化\"] H3 --\u003e I3[\"字段类型优化\n冗余字段\n垂直分表\"] H4 --\u003e I4[\"水平分片\n垂直分片\n读写分离\"] I1 --\u003e J[\"执行优化方案\"] I2 --\u003e J I3 --\u003e J I4 --\u003e J J --\u003e K[\"再次EXPLAIN验证\"] K --\u003e L{\"性能是否满足要求\"} L --\u003e L1[\"是\"] L --\u003e L2[\"否\"] L1 --\u003e M[\"持续监控\"] L2 --\u003e N[\"继续深度优化\"] N --\u003e N1[\"查看Profile\"] N --\u003e N2[\"分析锁等待\"] N --\u003e N3[\"优化参数配置\"] N1 --\u003e H N2 --\u003e H N3 --\u003e H M --\u003e O[\"优化完成\"] 17. 如何使用MySQL的EXPLAIN语句进行查询分析? 【EXPLAIN查询结果解释】\n名称 id select_type type key rows Extra 中文名称 查询的执行顺序 查询的类型 访问类型 关键索引 扫描行数 额外信息 说明 值越大优先级越高 SIMPLE简单查询、PRIMARY主查询、SUBQUERY 子查询 const \u003e eq_ref \u003e ref \u003e range \u003e index \u003e ALL 实际用到的索引 值越小越好 Using index 表示覆盖索引、Using where 表示where条件过滤、Using temporary 表示临时表、Using filesort 表示需要额外的排序步骤 【type说明】\nsystem: 表明查询的表只有一行 (系统表)\nconst : 表明查询的表最多只有一行匹配结果。通常是查询条件为主键或唯一索引， 并且是常量比较。\neq_ref: 表明对于每个来自钱一张表的行，MySQL只访问一次该表，通常发生在链接查询中使用主键或唯一索引的情况下。\nref：MySQL 使用非唯一索引查询。查询的条件是非唯一的\nrange: MySQL 会扫描表的一部分，不是全部行。通常出现在索引的范围查询中 (比如\u003e=、\u003c=、BETWEEN)\nindex: 表示MySQL扫描索引中的所有行，但不是扫描表的所有行。\nall：表示需要扫描表的所有行，全表扫描。一般出现在没有索引的查询条件中。\n18. 请详细描述 MySQL 的 B+ 树中查询数据的全过程 【B+树查询过程】\n可以类比成去电影院 (4号厅 ) 找位置 的过程\n买票进门，从根节点(Page 20)出发，主键值为4, 范围在[1,5)中间，需要到 Page 2 非叶子节点查询 进入 Page 2 非叶子节点，主键值大于3，需要到Page 5 的叶子节点查询 进入Page 5 的叶子节点，通过Page Directory 内的槽查找记录，使用二分法快速定位查询记录在那个槽。 定位到槽之后遍历所有的记录，找到主键为 4 的记录 【Page Directory 页目录查找过程】\n假如页目录当中有5个槽，现在需要查找主键值为3的记录。查找过程如下：\n二分查找定位到槽2 槽2的最大记录是4，记录二分查找定位到槽1 槽1的最大记录是2，因为3 \u003e 2， 直接向前遍历查询到主键值为 3 的记录 【B+树数据页的结构】\nInnoDB 当中B+树的每个节点以数据页(Page)为单位存储，每页默认大小为16KB。\n文件头： 记录叶子节点的上下页 (因为叶子节点是双向链表连接起来的) 最大和最小记录：表示页面当中最小的记录和最大的记录 （虚拟的记录） 在真实行记录的两侧 页目录: 数据页被分为若干个组，每个组对应一个槽 (Slot)。页目录内记录这些槽的位置，实现基于当前数据也的二分查找的快速定位。 【B+树的优势】\n参见问题14. 为什么 MySQL 选择使用 B+ 树作为索引结构？\n19. MySQL 中 count(*)、count(1) 和 count(字段名) 有什么区别？ 【效率层面】 count(*) ≈ count(1) \u003e count(唯一索引) \u003e count(主键) \u003e count(其他字段)\n【具体区别】\n类型 统计内容 说明 count(*) 表中所有记录，包括NULL值 直接统计表的记录数，不依赖字段内容。MySQL特定优化，开销最低 count(1) 表中所有记录，包括NULL值 参数1被视为常量，不依赖字段内容。未优化，性能略低于count(*) count(唯一索引) 唯一索引字段中的所有非 NULL 的记录 遍历非聚簇索引统计字段行数，因为没有NULL 值，所以结果和count(*)差不多 count(主键) 主键字段中的所有非 NULL 的记录 遍历聚簇索引统计主键字段行数，因为没有NULL 值，所以结果和count(*)差不多。但是，有回表操作，会产生额外的I/O。 count(其他字段) 其他字段中的所有非 NULL 的记录 读取字段值，判断是否未NULL。如果记录较大，性能较差。 20. MySQL 中 varchar 和 char 有什么区别？ 【主要区别】\n特点 char varchar 长度 固定长度，不足的用空格补齐 (InnoDB会自动忽略补齐的空格) 非固定长度 存储空间 始终占用固定长度空间 随着长度的变化而变化，还有1~2字节的额外空间，用于说明长度信息 性能影响 如果长度忽大忽小，可能浪费 比较节省空间 使用场景 存储长度固定且较短的字符串 存储变化或稍微较长的字符串 【注意事项】\nvarchar 长度不要太大：因为MySQL在利用order by排序的过程当中，会用到 sort_buff。如果varchar所设定的长度过大，就会使用双路排序。而双路排序在对排序字段排序之后，只能拿到主键值和索引列的值。需要使用主键值再进行回表查询操作，会增加系统的I/O，降低系统性能。 varchar(n) 当中的n 表示的是字符数，而不是字节数。通常最大行长度是 65535 字节，如果允许未null， 需要额外一个字节标注是否未null。 而varchar 需要1~2个字节来标注字段的长度。所以，支持的最大长度为65535-2 = 65533 字节。一般情况下，UTF-8字符集占用3个字节。所以，最大字符数n 为 65533 / 3 = 21844 个字符 21. MySQL 是如何实现事务的？ 【事务四个特性 - AIDC】\n原子性：事务要么全部执行成功，要么全部执行失败 隔离性：并发的事务之间相互是不干扰的，可见性由隔离级别进行控制。MySQL的默认隔离级别是RR，可重复读 持久性：事务一旦提交，确保修改的数据会被永久保存 一致性：事务执行前后，数据库要保持一直的状态，所有的业务规则、约束和触发器的规则必须满足。 【如何实现事务】\n实现事务其实就是要确保满足事务的四个特性，如何满足呢？\n原子性：通过Uodo Log 实现，从事务开始的时候，Undo Log 里面会存储事务的反向操作。就是保存数据的历史版本把，用于事务的回滚，让事务执行失败之后可以恢复到之前的样子。\n隔离性: 通过锁和MVCC 多版本并发控制来实现的，主要是控制不同隔离级别下事务间的方法，确保事务之间不相互干扰。\n持久性：通过Redo Log来实现的，Redo Log会记录事务对数据库的所有修改操作。当MySQL发送宕机或崩溃的时候，可以根据Redo Log 里面的记录来恢复数据。满足事务的持久性。\n一致性： 其实事务的一致性就是AID实现的，也就是说事务是通过原子性、隔离性、持久性来满足一致性的。\n22. MySQL有哪些锁的类型? 【按粒度分类】\n全局锁: 对整个数据库进行加锁，处于只读的状态，一般用于数据库逻辑备份。这个时候所有的数据操作(增删改)和表结构操作(ALTER 和 DROP)都会被阻塞。 表级锁: 锁的是整张表。实现比较简单，资源消耗低。 行级锁：锁的是某一行。粒度最小，支持高并发。但是加锁的开销大，可能导致死锁。 【按功能分类】\n共享锁 (S 锁, share Lock): 读锁，顾名思义是共享的，所以可以共享锁之间可以兼容，一般用于事务读取数据的时候 排他锁 (X 锁, exclusive lock)：写锁，顾名思义是拒绝别人的，所以不允许多个事务同时获取，排他锁之间不兼容。一般用于事务修改记录的时候。 -- 添加共享锁 SELECT ... LOCK IN SHARE MODE;\t-- 共享锁 SELECT ... FOR SHARE # MySQL 8.x 版本 -- 排他锁 SELECT .... FOR UPDATE; 【全局锁】\n直接锁住整个数据库，处于只读模式。业务只能读取数据，不能更新数据。\nFLUSH TABLES WITH READ LOCK 【表级锁】\n表锁\n表级共享锁：阻止其他会话对表的写操作，当前会话只能读该表，不能访问其他表 表级排他锁：阻止其他会话对标进行任何操作（读和写），当前会话只能读该表，不能访问其他表 # 添加表级共享锁 lock tables user read; # 添加表级别排它锁 lock tables user write; 元数据锁：事务执行SELECT 的时候，其他线程的DDL操作(ALTER、DROP)操作会被阻塞，直到事务提交\n意向锁\n意向共享锁 (IS)：表明有意向对该表某些记录添加共享锁 (S 锁) 意向排他锁 (IX)：表明有意向对该表某些记录添加排他锁 (X 锁) 意向锁之间相互兼容，不会和行级别的共享锁和排他锁发生冲突。但是，意向排他锁和共享锁、排他锁之间是冲突的。\n锁名称 S X IS IX S ✅ ❌ ✅ ❌ X ❌ ❌ ❌ ❌ IS ✅ ❌ ✅ ✅ IX ❌ ❌ ✅ ✅ 自增锁\n用于主键自增的一种锁。事务向有自增列的表插入数据是会先获取自增锁，拿不到锁就被阻塞。但是可以通过修改innodb_autoinc_lock_mode自增锁模式进行调整，自增锁的具体实现方式：\n自增锁模式 介绍 说明 0 传统模式 采用AUTO-INC 锁，语句执行结束释放 1 连续模式 对普通insert，自增锁申请后马上释放。对于批量插入，等语句执行结束之后释放 2 交错模式 申请自增主键后马上释放，无需等待语句执行完 【行级锁】\n记录锁\n事务对某条记录加S锁，其他记录也可以加，但是不能加X锁 事务对某条记录加X锁，其他事务既不能加S锁也不能加X锁 BEGINE; # 针对主键 id 为 2 的这条记录添加 X 型的记录锁；其他事务就无法对这条记录进修改 SELECT * FROM user WHERE id = 2 FOR UPDATE; 间隙锁\n防止在可重复读的隔离级别下，出现幻读问题。\n比如，事务A开始读取数据, 发现是3条数据。然后，事务B加了一条数据进去。事务A在读去数据,发现是4条数据, 前后数据总数不一致就是幻读。\n临键锁：记录锁 + 间隙锁的组合，既可以锁住记录，也可以防止幻读\n插入意向锁\n意向锁用于快速判断是否可以对某张表加表锁，而无需判断表中具体行的锁定情况。\n插入意向锁的作用：\n标记插入意向图：事务告诉InnoDB，它计划在某个间隙范围内插入新数据。 允许多个事务并发插入不同位置：也就是说如果插入的范围不同，插入意向锁之间互不从突。 【注意】\n一个事务有间隙锁时，另外一个事务不能在相同范围内加插入意向锁 一个事务有插入意向锁是，另外一个事务不能在相同范围内假如间隙锁 23. MySQL 中的 MVCC 是什么？ 【当前读和快照读】\n当前读：select ... lock in share mode、select ... for update、insert/delete/upate 有锁，会阻塞其他事务。当前读不会生成ReadView， 只会加上临键锁next-key lock (记录锁+间隙锁) 快照读：直接 select，普通的查询操作，不加任何锁，不会阻塞其他事务。会生成ReadView，不会有幻行 【当前读和快照读事务执行流程区别】\nsequenceDiagram participant T1 as 事务1 participant T2 as 事务2 participant DB as 数据库 participant MVCC as MVCC版本链 Note over T1, MVCC: 场景1：快照读 T1-\u003e\u003eDB: BEGIN T1-\u003e\u003eMVCC: SELECT * FROM users WHERE id=1 (快照读) MVCC--\u003e\u003eT1: 返回快照版本数据: name='Alice' T2-\u003e\u003eDB: BEGIN T2-\u003e\u003eDB: UPDATE users SET name='Bob' WHERE id=1 T2-\u003e\u003eDB: COMMIT T1-\u003e\u003eMVCC: SELECT * FROM users WHERE id=1 (快照读) MVCC--\u003e\u003eT1: 仍返回快照版本: name='Alice' T1-\u003e\u003eDB: COMMIT Note over T1, MVCC: 场景2：当前读 T1-\u003e\u003eDB: BEGIN T1-\u003e\u003eDB: SELECT * FROM users WHERE id=1 FOR UPDATE (当前读) DB--\u003e\u003eT1: 获取排他锁，返回最新数据: name='Bob' T2-\u003e\u003eDB: BEGIN T2-\u003e\u003eDB: SELECT * FROM users WHERE id=1 FOR UPDATE (当前读) Note over T2, DB: 等待T1释放锁 T1-\u003e\u003eDB: UPDATE users SET name='Charlie' WHERE id=1 T1-\u003e\u003eDB: COMMIT DB--\u003e\u003eT2: 获取锁成功，返回最新数据: name='Charlie' T2-\u003e\u003eDB: COMMIT 【隔离级别】\n不同的隔离级别分别解决了脏读、不可重复读、幻读的问题。\n隔离性 读未提交 RU 读已提交 RC 可重复读 RR 串行读 脏读 ❌ ✅ ✅ ✅ 不可重复读 ❌ ❌ ✅ ✅ 幻读 ❌ ❌ ❌ ✅ 【注意】只有读已提交 RC 和可重复读 RR 才会用到快照读\n可重复读 RR，快照会在事务开始时生成，对数据进行更改才修改快照 读已提交 RC ，每次读取都会重新生成快照，总是读取行的最新版本，所以不可重复读 【MVCC】\nMVCC多版本控制并发主要是用来解决 读-写并发 所引起的问题的\n隐藏字段： db_row_id: 如果没有创建主键，就用这个字段来创建聚簇索引 db_trx_id：对该记录左最新一次修改的事务的ID db_roll_ptr: 回滚指针，指向当前行记录的上一个版本，也就是指向undo log当中上一个版本的快照地址 Read View: 隐藏字段和 undo log版本决定的是返回的数据，但是具体返回哪个版本，由read view 和版本链返回规则可见性算法控制\ntrx_ids : 表示生成readview是,当前系统中活跃的读写事务的事务ID列表 low_limit_id：应该分配给下一个事务的id值 (最大事务id + 1) up_limit_id: 未提交的事务中最小的事务id (最小事务id) creator_trx_id: 创建该readview的事务id 什么情况是可以看见的? trx_id == creator_trx_id (当前事务修改的)、trx_id \u003c up_limit_id (事务已提交)，up_limit_id \u003c trx_id \u003c low_limit_id (如果trx_id 不在 trx_ids 里面，说明不是这条数据不是存活的事务掌控的，数据已经提交了) 都是可见的。 trx_id \u003e low_limit_id 是不可以访问的\n如果发现当前的记录是不可见的，那么就需要找undo log日志的历史快照了，如果找不到，则返回空。\n【不同隔离版本ReadView的产生时机】\n读已提交 RC，每次select 都会获取一次Read View 读未提交 RR， 只有第一次select才会获取Read View 【二级索引在索引覆盖通过的时候可以用MVCC吗？】\n已知如果查询字段包含了所有的二级索引，那么就会走索引覆盖，而不会回表用主键或row_id去读主键索引的页记录。但是，版本链的头节点在主键索引当中 ( 版本链包含row_id ), 通过二级索引的记录没法儿直接找到版本链。这种情况如何用MVCC？\n二级索引中，用一个额外的page_max_trx_id 来记录修改过该页的最大事务id\n如果查询到的readview 的最小未提交的事务id \u003e page_max_trx_id， 说明在创建该readview时，最后一次更新二级索引的事务已经提交了，也就是说对当前查询是可见的，如果二级索引的记录没有被删除，就直接走索引覆盖。 如果最小未提交的事务id \u003c= page_max_trx_id， 意味着数据可能被修改了。不能直接查询，需要回表，用聚簇索引进行查询。聚簇索引中，叶子结点行记录包含了版本链，可以用MVCC。 【可重复读RR隔离级别是否可以解决幻读】\nRR隔离机制不能完全解决幻读的现象，虽然它用了间隙锁，在一定程度上可以解决幻度。\n但是，如果存在下面这种情况就不行。\n事务A进行快照读, 然后事务B插入了一条记录并提交。此时，事务A是可以update 这条语句的，这样就出现了幻读。 当事务中先执行快照读，再执行当前读时，可能因读取最新数据而触发幻读 -- 事务A（RR隔离级别） BEGIN; SELECT * FROM users WHERE age \u003e 20; -- 快照读，返回空结果 -- 事务B插入 age=25 的记录并提交 SELECT * FROM users WHERE age \u003e 20 FOR UPDATE; -- 当前读，返回事务B插入的记录 下面是快速图解版\n【MVCC 结构】\ngraph TB subgraph \"数据表\" T[账户表] --\u003e R1[\"记录1: 余额=100万\"] R1 --\u003e H1[\"db_trx_id: 事务ID\"] R1 --\u003e H2[\"db_roll_ptr: 回滚指针\"] R1 --\u003e H3[\"db_row_id: 行ID\"] end subgraph \"Undo Log版本链\" U1[\"[版本1]余额 = 100万trx_id = 1roll_ptr → U2\"] U2[\"[版本2]余额 = 80万trx_id = 2roll_ptr → U3\"] U3[\"[版本3]余额 = 50万trx_id = 3roll_ptr → NULL\"] U1 --\u003e U2 U2 --\u003e U3 end subgraph \"Read View 结构\" RV[\"Read View\"] RV --\u003e TV[\"trx_ids: [活跃事务ID列表]\"] RV --\u003e LT[\"low_limit_id: 下一个事务ID\"] RV --\u003e UT[\"up_limit_id: 最小活跃事务ID\"] RV --\u003e CT[\"creator_trx_id: 创建者事务ID\"] end subgraph \"MVCC判断流程\" J1[\"判断 trx_id == creator_trx_id?\"] J2[\"判断 trx_id \u003c up_limit_id?\"] J3[\"判断 trx_id \u003e= low_limit_id?\"] J4[\"判断 trx_id 在 trx_ids 中?\"] J1 --\u003e|是| V1[\"可见\"] J1 --\u003e|否| J2 J2 --\u003e|是| V2[\"可见\"] J2 --\u003e|否| J3 J3 --\u003e|是| NV1[\"不可见\"] J3 --\u003e|否| J4 J4 --\u003e|在| NV2[\"不可见\"] J4 --\u003e|不在| V3[\"可见\"] end H2 -.-\u003e|指向| U1 RV -.-\u003e|查找版本链| U1 【MVCC - 执行过程】\nsequenceDiagram participant T as 事务线程 participant RV as Read View participant UL as Undo Log版本链 participant R as 记录版本 Note over T: 事务开始读取操作 T-\u003e\u003eRV: 创建/获取Read View RV--\u003e\u003eT: 返回Read View(trx_ids, up_limit_id, low_limit_id, creator_trx_id) T-\u003e\u003eUL: 获取当前记录版本 UL--\u003e\u003eT: 返回最新版本记录 loop 遍历版本链直到找到可见版本 T-\u003e\u003eR: 获取当前版本的trx_id R--\u003e\u003eT: 返回版本的trx_id Note over T,RV: 开始可见性判断 T-\u003e\u003eRV: 判断 trx_id == creator_trx_id? alt trx_id 等于 creator_trx_id RV--\u003e\u003eT: 可见(自己修改的记录) Note over T: 返回当前版本数据 else 不等于 creator_trx_id T-\u003e\u003eRV: 判断 trx_id \u003c up_limit_id (最小未提交的事务id)? alt trx_id \u003c up_limit_id RV--\u003e\u003eT: 可见(已提交的旧事务) Note over T: 返回当前版本数据 else trx_id \u003e= up_limit_id T-\u003e\u003eRV: 判断 trx_id \u003e= low_limit_id (下一个待分配的事务id)? alt trx_id \u003e= low_limit_id RV--\u003e\u003eT: 不可见(未来事务) T-\u003e\u003eUL: 通过roll_ptr获取上一版本 UL--\u003e\u003eT: 返回上一版本记录 else trx_id \u003c low_limit_id T-\u003e\u003eRV: 判断 trx_id 是否在 trx_ids 中? alt trx_id 在 trx_ids 中 RV--\u003e\u003eT: 不可见(活跃未提交事务) T-\u003e\u003eUL: 通过roll_ptr获取上一版本 UL--\u003e\u003eT: 返回上一版本记录 else trx_id 不在 trx_ids 中 RV--\u003e\u003eT: 可见(已提交事务) Note over T: 返回当前版本数据 end end end end end Note over T: 找到可见版本或到达版本链末尾 [补充] 23.1 MySQL事务的四大隔离级别实现原理？ 读未提交：可以读到未提交的数据，所以直接读最新的数据即可 读已提交和可重复读：是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。 读已提交：每个语句执行前， 都会重新生成一个 Read View 。可以确保只读到已经提交过的事务，如果没提交在Read View里面是看不到的。 可重复读：启动事务时，生成一个 Read View，整个事务期间都在用这个 Read View 。所以，可以确保读取到的都是同一个事务内修改过的数据。即便事务执行过程中有其他已经事务提交，也看不到其他事务修改过的数据记录。 串行化：通过加读写锁的方式来避免并行访问 【案例分析】\n假设有一张账户余额表，里面有一条账户余额为 100 万的记录。然后有两个并发的事务，事务 A 只负责查询余额，事务 B 则会将我的余额改成 200 万，下面是按照时间顺序执行两个事务的行为：\n【分析】\n可重复读：下面事务并发的执行过程，利用MVCC的快照读解决了不可重复读的问题。（因为在事务开始的时候，就生成了一个ReadView。确保读取到的数据一定是当前事务和之前已提交事务的数据记录，后面的记录都读取不到） 读已提交：如果是读已提交，每次执行都会生成一个ReadView。当事务A第二次读区的时候，就可以读区到事务B提交的数据了。 sequenceDiagram participant DB as 数据库记录 participant UA as 事务A的Undo Log participant UB as 事务B的Undo Log participant TA as 事务A(trx_id=100) participant TB as 事务B(trx_id=101) Note over DB: 初始状态: 余额=100万, trx_id=99 Note over TA: 1. 事务A启动 TA-\u003e\u003eTA: 生成Read View Aup_limit_id=100low_limit_id=102trx_ids=[100]creator_trx_id=100 Note over TA: 2. 事务A首次读取 TA-\u003e\u003eDB: SELECT 余额 DB--\u003e\u003eTA: 返回100万(trx_id=99 \u003c up_limit_id=100, 可见) Note over TB: 3. 事务B启动 TB-\u003e\u003eTB: 生成Read View Bup_limit_id=100low_limit_id=102trx_ids=[100,101]creator_trx_id=101 Note over TB: 4. 事务B首次读取 TB-\u003e\u003eDB: SELECT 余额 DB--\u003e\u003eTB: 返回100万(trx_id=99 \u003c up_limit_id=100, 可见) Note over TB: 5. 事务B更新数据 TB-\u003e\u003eUB: 创建Undo Log记录old_value=100万, trx_id=99 TB-\u003e\u003eDB: UPDATE 余额=200万, trx_id=101 Note over DB: 当前记录: 余额=200万, trx_id=101roll_ptr→Undo Log(100万, trx_id=99) Note over TA: 6. 事务A第二次读取(V1) TA-\u003e\u003eDB: SELECT 余额 Note over TA,DB: 使用事务A的Read View判断可见性 Note over TA: trx_id=101 在 trx_ids=[100] 中? 不在trx_id=101 \u003e= low_limit_id=102? 否但 trx_id=101 \u003e up_limit_id=100 TA-\u003e\u003eUB: 通过roll_ptr访问Undo Log UB--\u003e\u003eTA: 返回100万(trx_id=99 \u003c up_limit_id=100, 可见) Note over TB: 7. 事务B提交 TB-\u003e\u003eDB: COMMIT Note over DB: 事务B提交，记录持久化 Note over TA: 8. 事务A第三次读取(V2) TA-\u003e\u003eDB: SELECT 余额 Note over TA: 仍使用原来的Read View A(RR级别下Read View不变) TA-\u003e\u003eUB: 通过roll_ptr访问Undo Log UB--\u003e\u003eTA: 返回100万(可重复读保证) Note over TA: 9. 事务A提交 TA-\u003e\u003eDB: COMMIT Note over DB: 10. 最终读取(V3) Note over DB: 新事务读取会看到200万(事务B的修改已提交) [补充] 23.2 MySQL事务的四大特性的底层原理？ 【事务的四大特性定义】\n原子性（Atomicity）：事务中的所有操作要么全部成功执行并提交，要么全部失败并回滚，不存在部分执行的情况。就像转账操作，扣款和加款必须同时成功或同时失败。\n隔离性（Isolation）：并发执行的多个事务之间相互隔离，一个事务的执行不应该被其他事务干扰。通过不同的隔离级别来控制并发访问。\n持久性（Durability）：事务一旦提交，其对数据库的修改就是永久性的，即使系统崩溃也不会丢失。\n【为什么需要持久化？】\ngraph LR A[用户发起转账请求转账1000元] --\u003e B[MySQL处理事务] B --\u003e C[在内存中修改数据账户A: 5000→4000账户B: 3000→4000] C --\u003e D[返回成功响应给用户用户认为转账完成] D --\u003e E{系统是否崩溃?} E -- 正常运行 --\u003e F[数据最终写入磁盘数据安全保存] E -- 突然断电/崩溃 --\u003e G[内存数据丢失修改全部消失] G --\u003e H[严重后果] H --\u003e I[用户金钱损失账户A已扣款账户B未到账] H --\u003e J[银行信誉受损监管合规问题] H --\u003e K[数据不一致总金额不守恒] F --\u003e L[数据一致性保证业务正常运行] style A fill:#e1f5fe style G fill:#ffebee style H fill:#ffcdd2 style I fill:#ffcdd2 style J fill:#ffcdd2 style K fill:#ffcdd2 style L fill:#e8f5e8 一致性（Consistency）：事务执行前后，数据库必须处于一致性状态。所有数据完整性约束都得到满足，不会出现数据不一致的情况。\n【四大特性的关系】\ngraph TB subgraph \"MySQL事务ACID特性\" A[\"原子性 Atomicity事务要么全部成功要么全部失败\"] I[\"隔离性 Isolation并发事务之间相互独立\"] D[\"持久性 Durability事务提交后永久保存\"] C[\"一致性 Consistency数据库状态保持一致\"] end A --\u003e C I --\u003e C D --\u003e C style A fill:#e1f5fe style I fill:#f3e5f5 style D fill:#e8f5e8 style C fill:#fff3e0 【四大特性实现原理】\n原子性：原子性主要通过 Undo Log （回滚日志）来实现，Undo Log 的生命周期有三个阶段。\n操作记录阶段：当事务对数据进行修改时，MySQL会先将原始数据记录到 Undo Log 中，然后再执行实际的修改操作。如果是修改操作，Undo Log 存的是数据、trx_id、row_id、rollback_pt (MVCC 记录)。如果是新增操作，会记录一条对应的删除操作，用于后续回滚。\n回滚处理阶段：如果事务需要回滚（主动ROLLBACK或系统异常），MySQL会读取 Undo Log 中记录的原始数据，并使用这些数据将数据库恢复到事务开始前的状态。\n提交处理阶段：如果事务成功提交，Undo Log 中的数据会被标记为可清理状态，等待后台进程回收。\nsequenceDiagram participant Client as 客户端 participant Server as MySQL服务器 participant UndoLog as Undo Log participant Buffer as 缓冲池 participant Storage as 存储引擎 Client-\u003e\u003eServer: BEGIN TRANSACTION Server-\u003e\u003eUndoLog: 创建事务ID和Undo Log空间 Client-\u003e\u003eServer: UPDATE users SET balance=1000 WHERE id=1 Server-\u003e\u003eUndoLog: 记录原始数据(id=1, balance=500) Server-\u003e\u003eBuffer: 修改缓冲池数据(id=1, balance=1000) Client-\u003e\u003eServer: INSERT INTO orders VALUES(1, 'item1') Server-\u003e\u003eUndoLog: 记录插入操作的反向删除记录(DELETE FROM orders WHERE id=1) Server-\u003e\u003eBuffer: 在缓冲池中插入新记录 alt 事务提交成功 Client-\u003e\u003eServer: COMMIT Server-\u003e\u003eStorage: 将缓冲池数据刷新到磁盘 Server-\u003e\u003eUndoLog: 标记Undo Log为可清理状态 Server--\u003e\u003eClient: 事务提交成功 else 事务回滚 Client-\u003e\u003eServer: ROLLBACK (或系统异常) Server-\u003e\u003eUndoLog: 读取Undo Log中的历史数据 Server-\u003e\u003eBuffer: 使用Undo Log恢复原始数据(id=1, balance=500) Server-\u003e\u003eBuffer: 删除已插入的订单记录 Server--\u003e\u003eClient: 事务回滚完成 end 持久性：主要通过 Redo log 、双阶段提交、双写缓存区来确保事务的持久性\nRedo Log机制：MySQL使用WAL（Write-Ahead Logging）策略，先写日志再写数据。即使系统崩溃，也能通过重放Redo Log恢复数据。\n两阶段提交：协调Redo Log和Binary Log的写入顺序，确保事务的一致性和持久性。\n双写缓冲区：防止页面写入过程中的部分写问题，确保数据页的完整性。\n【持久化机制流程图】\ngraph LR subgraph \"崩溃恢复机制\" direction LR Y[系统重启] --\u003e Z[读取Redo Log] Z --\u003e AA[从检查点开始重放] AA --\u003e BB[恢复未刷盘的修改] BB --\u003e CC[数据完整性验证] end subgraph \"二阶段提交\" direction LR DD[Phase 1: Prepare] --\u003e EE[写入Prepare状态] EE --\u003e FF[刷新Redo Log] FF --\u003e GG[写入Binary Log] GG --\u003e HH[Phase 2: Commit] HH --\u003e II[写入Commit状态] II --\u003e JJ[事务完成] end subgraph \"用户层\" A[客户端应用] --\u003e B[事务提交请求] end subgraph \"MySQL服务器层\" B --\u003e C[SQL解析器] C --\u003e D[事务管理器] D --\u003e E[存储引擎接口] end subgraph \"InnoDB存储引擎\" E --\u003e F[缓冲池 Buffer Pool] subgraph \"内存结构\" F --\u003e G[数据页缓存] F --\u003e H[索引页缓存] F --\u003e I[Undo页缓存] J[Log Buffer] --\u003e K[Redo Log Records] end subgraph \"磁盘持久化机制\" L[Redo Log Files] --\u003e M[ib_logfile0] L --\u003e N[ib_logfile1] O[数据文件] --\u003e P[表空间 .ibd] O --\u003e Q[系统表空间 ibdata] R[双写缓冲区] --\u003e S[Double Write Buffer连续的磁盘区域] end subgraph \"WAL写入流程\" G --\u003e T{数据页修改} T --\u003e U[1. 记录到Redo Log Buffer] U --\u003e V[2. 写入Redo Log Filesfsync强制刷盘] V --\u003e W[3. 标记页面为脏页] W --\u003e X[4. 后台异步刷脏页] end end K --\u003e U V --\u003e L X --\u003e R R --\u003e O style F fill:#e3f2fd style L fill:#fff3e0 style R fill:#f3e5f5 style DD fill:#e8f5e8 【持久化机制-执行过程详细时序图】\nsequenceDiagram participant Client as 客户端 participant Server as MySQL服务器 participant Buffer as 缓冲池 participant RedoLog as Redo Log participant BinLog as Binary Log participant Disk as 磁盘存储 participant DoubleWrite as 双写缓冲区 Client-\u003e\u003eServer: BEGIN TRANSACTION Client-\u003e\u003eServer: UPDATE users SET balance=1000 WHERE id=1 Note over Server: 开始两阶段提交过程 Server-\u003e\u003eBuffer: 在缓冲池中修改数据页(balance=1000) Server-\u003e\u003eRedoLog: 写入Redo Log记录(LSN=1001, 页面修改详情) RedoLog-\u003e\u003eRedoLog: 将日志写入Log Buffer Client-\u003e\u003eServer: COMMIT Note over Server: 第一阶段：准备提交 Server-\u003e\u003eRedoLog: 写入Prepare状态的Redo Log(XID=12345, state=PREPARE) RedoLog-\u003e\u003eDisk: 强制刷新Redo Log到磁盘(fsync调用) Server-\u003e\u003eBinLog: 写入Binary Log记录(XID=12345, SQL语句) BinLog-\u003e\u003eDisk: 强制刷新Binary Log到磁盘(fsync调用) Note over Server: 第二阶段：最终提交 Server-\u003e\u003eRedoLog: 写入Commit状态的Redo Log(XID=12345, state=COMMIT) RedoLog-\u003e\u003eDisk: 刷新Commit记录到磁盘 Server--\u003e\u003eClient: 返回提交成功响应 Note over Server: 后台异步刷脏页过程 par 脏页刷新 Server-\u003e\u003eDoubleWrite: 将脏页先写入双写缓冲区 DoubleWrite-\u003e\u003eDisk: 刷新双写缓冲区到磁盘 DoubleWrite--\u003e\u003eServer: 双写完成确认 Server-\u003e\u003eDisk: 将脏页写入实际数据文件位置 and 检查点处理 Server-\u003e\u003eRedoLog: 推进检查点LSN Server-\u003e\u003eRedoLog: 清理已刷新脏页对应的Redo Log end Note over Server: 崩溃恢复场景 alt 系统崩溃后重启 Server-\u003e\u003eRedoLog: 从检查点开始读取Redo Log Server-\u003e\u003eBuffer: 根据Redo Log重放未刷盘的修改 Server-\u003e\u003eDisk: 重新应用所有已提交事务的修改 Note over Server: 持久性得到保证，数据不会丢失 end 隔离性: 主要通过锁和MVCC两大机制来保证并发事务之间，事务能够相互独立。\nsequenceDiagram participant T1 as 事务1(Transaction ID: 100) participant T2 as 事务2(Transaction ID: 101) participant LockManager as 锁管理器 participant MVCC as MVCC引擎 participant UndoLog as Undo Log participant DataPage as 数据页 Note over T1, T2: 假设两个并发事务同时操作用户余额 T1-\u003e\u003eLockManager: BEGIN TRANSACTION LockManager-\u003e\u003eT1: 分配事务ID: 100 T2-\u003e\u003eLockManager: BEGIN TRANSACTION LockManager-\u003e\u003eT2: 分配事务ID: 101 T1-\u003e\u003eLockManager: 请求修改用户ID=1的数据UPDATE users SET balance=1000 WHERE id=1 LockManager-\u003e\u003eT1: 获得行级写锁(X锁) T1-\u003e\u003eUndoLog: 记录原始数据(balance=500) T1-\u003e\u003eDataPage: 修改数据页(balance=1000, trx_id=100) T2-\u003e\u003eMVCC: 读取用户ID=1的数据SELECT balance FROM users WHERE id=1 MVCC-\u003e\u003eUndoLog: 检查当前活跃事务列表发现事务100未提交 MVCC-\u003e\u003eUndoLog: 通过Undo Log找到事务100之前的版本 MVCC-\u003e\u003eT2: 返回快照读结果(balance=500)基于ReadView机制 T2-\u003e\u003eLockManager: 尝试修改同一数据UPDATE users SET balance=800 WHERE id=1 LockManager-\u003e\u003eT2: 等待锁释放(阻塞状态) alt 事务1提交 T1-\u003e\u003eLockManager: COMMIT T1-\u003e\u003eDataPage: 将修改写入磁盘 LockManager-\u003e\u003eT2: 释放行级写锁唤醒等待的事务2 T2-\u003e\u003eLockManager: 获得行级写锁 T2-\u003e\u003eDataPage: 修改数据页(balance=800, trx_id=101) T2-\u003e\u003eLockManager: COMMIT else 事务1回滚 T1-\u003e\u003eLockManager: ROLLBACK T1-\u003e\u003eUndoLog: 恢复原始数据(balance=500) LockManager-\u003e\u003eT2: 释放行级写锁 T2-\u003e\u003eLockManager: 获得行级写锁 T2-\u003e\u003eDataPage: 基于原始值修改(balance=800, trx_id=101) end 24. MySQL 中的日志类型有哪些？binlog、redo log 和 undo log 的作用和区别是什么？ binlog 二进制日志: binlog是MySQL的二进制文件，用于记录所有的增删改操作 (包括表结构和数据的操作)。binlog是在事务提交后生成的，可以用于恢复数据库和备份数据库。(一般MySQL都有主库+从库两个数据库，防止单台故障，binlog就是为了同步主库和从库的) redo log 重做日志: redo log使用来恢复数据的，保证数据的一致性和持久性。当MySQL发生修改是，redolog会将这些操作记录下来，并写入磁盘。当数据库宕机时，可以通过重放redo log恢复数据 undo log 回滚日志: undo log是用于回滚操作的。当MySQL开始事务的时候，undo log会记录这些操作的反向操作。当需要回滚的时候，通过执行相反的操作，就可以回滚事务。 【区别】\n日志名称 作用层级 作用 内容 写入方式 写入时间点 binlog Server层 记录所有操作，支持备份恢复和主从复制 记录逻辑操作 (SQL语句 / 行的变化) 追加写入，写满之后创建新文件，再写 事务提交完成后，写入一次 redo log InnoDB存储引擎层 保证数据的一致性和持久性，用于故障恢复(断电宕机) 记录物理修改 (数据页的修改) 循环写入，固定大小，写完之后从头开始写 事务进行中，不断写入 undo log InnoDB存储引擎层 保证事务的原子性，用于回滚数据 记录事务修改钱的数据，用于回滚和MVCC 随事务变化生成，形成版本链 事务进行中，不断写入 【undo log 结构图】 【Redo Log + Undo log 结构图】\n25. MySQL隔离级别有哪些? MySQL的隔离级别包括四类: 读未提交 RU、读已提交 RC、可重复读 RR、串行化\n读未提交 RU : 顾名思义，如果有两个事务，事务A会在执行过程中读取,事务B还没有提交的修改数据。会出现脏读的情况， 就是读取了其他事务还没提交的数据。 读已提交 RC: 顾名思义，如果有两个事务，事务A会在执行过程中，读取事务B提交之后的数据，若未提交不会读取。但是会出现不可重复读的现象，过程如下。 事务A第一次select name where id = 1读取的数据为 小邓 事务B update user set name = '小刘' 并提交 事务A再次select name where id = 1读取的数据为 小刘 ，结果发生了变化 (你**的究竟是谁) 可重复读 RR: 为了解决不可重复读的现象，RR 隔离级别下，事务A会只用第一次 select (快照读)的时候，生成read view。如果事务B修改同一行的数据并提交。事务A第二次select (快照读)的时候，会用第一次的查询结果。但是，它会出现幻读的现象，过程如下。 事务A第一次select count(*) 读取的数据为 10， 采用的快照读 事务B insert xxx 新增了一条数据并提交 事务A第二次用select count(*) for update，采用当前读。读出来的数据为11条 串行化： 可以理解成把RR隔离级别下，所有的快照读都替换成当前读。当前读的状态下，其他事务不能修改正在读取的数据，实现了读的一致性，避免了幻读。 但是并发性能很低。 【不同隔离级别的特性】\n特性 读未提交 RU 读已提交 RC 可重复读 RR 串行读 脏读 ❌ ✅ ✅ ✅ 不可重复读 ❌ ❌ ✅ ✅ 幻读 ❌ ❌ ❌ ✅ 并发量 高 较高 较低 低 【RR 隔离级别幻读的解决方案】\n只采用下面的某一种方式进行读，就不会出现幻读\n快照读 (MVCC机制)：利用MVCC多版本控制，不会出现幻读。 当前读 (加锁查询)：通过临键锁Next-key Lock (记录锁 + 间隙锁)，避免其他事务修改数据，防止幻读。其实就是串行化隔离级别。 26. 数据库的脏读、不可重复读和幻读分别是什么？ 名称 定义 定义(整活版) 脏读 事务A读取到了事务B还没提交的数据 骗子啊!!! 不可重复读 事务A第一次读取的数据和后面读取到的数据不一致 谁**动我东西了? 幻读 事务A第一次读取的数据总数和第二次读取的数据总数不一样 闹鬼了，进去前3个人，出来了4个人 整活版解释参见ID为 小明 的天才选手\n27. MySQL 默认的事务隔离级别是什么？为什么选择这个级别？ MySQL默认的事务隔离级别是可重复读 RR 。\n【为什么选 RR 隔离级别】\n因为MySQL当中一般是有主库 + 从库两个数据库，为了避免一个库突然g了，数据库就全g了。主库和从库之间是采用binlog进行备份的，如果binlog是statement格式，在RU和RC的隔离级别下，主库和从库就会出现数据不一致的问题。\n【binlog 格式】\n格式名称 内容 优点 缺点 statement 记录执行的SQL语句，发送到从库执行 日志量少，传输率高，简单操作 limit 这种依赖环境的函数，可能出现数据不一致情况 row 记录每行数据变化，发送到从库应用 准确复制数据，避免主从不一致的情况 日志量大，占用带宽和空间 mixed 结合语句和行复制，自动切换 日志量一般，主从一致性较高 自动切换操作复杂 【RU 和 RC 导致主从不一致】\nsession1 session2 事务A开始 delete from user where age \u003c 10 事务B开始 insert into user value(5,...) 事务B提交 事务A提交 此时，binlog里面记录的如下，执行顺序显然和原始的不一样，从库里面age = 5 这条数据肯定没了\ninsert into user value(10,...) delete from user where age \u003c 10 【为什么 RR 不会出现主从数据不一致】\n因为 RR 隔离级别不仅会对更新的数据行添加行级的记录锁， 还会添加间隙锁和临键锁。如果有这两个锁的话，在事务B执行insert的时候，会被阻塞的。\n【为什么大厂一般用 RC 】\n先来对比一下RC 和 RR 隔离级别的区别\n特性 RC RR binlog格式 只能用row, 用mixed也会自动切换未row statement、row、mixed 锁机制 只有行级的记录锁 记录锁、间隙锁、临键锁 读机制 当前读：每次都生成新的快照，读取行的最新版本 同时支持当前读和快照读，默认select是快照读 并发性 并发性高 并发性低：因为有间隙锁、临键锁，会导致锁竞争加剧，降低系统的并发性能。 用RC的原因有两个:\n提高并发：因为相较于RR，RC 的并发率更高 减少死锁：因为RR 当中的间隙锁和临键锁会使得锁的粒度变大，死锁的几率会变大。 【 RC 如何解决不可重复读问题】\n如果只是单纯的不可重复读，其实还好，只要后面修改数据不基于这个值。所以，在修改核心表的时候，增加乐观锁的标记。更新的时候带上乐观锁进行版本判断之后，再更新。\n28. MySQL 事务的二阶段提交是什么？/ MySQL里面的 Redolog 和 BinLog 怎么保持一致? 首先，事务的二阶段提交就是为了让MySQL中的 binlog 和 redo log 保持一致。\n【为什么需要两阶段提交】\n如果没有两阶段提交，可能会导致binlog和redo log不一致，可以参考下面两种情况\n**情况一：**先写完 redo log，再写binlog：如果写完redo log后，MySQL突然宕机了，binlog还没写入数据。此时，MySQL重启后，根据 redo log 恢复事务的修改，但是binlog没有本次事务提交的数据。所以通过binlog恢复的时候，这次事务的修改就丢了。\n**情况二：**先写完binlog，再写redo log：如果写完binlog之后，突然MySQL宕机了，redo log还没写入数据。重启后因为redo log里面没有记录，所以没法儿恢复事务的修改。但是binlog记录了本次事务提交的数据，后续用binlog恢复数据的时候，就导致和原库不一样了。(binlog是用来给从库复制的)\n为了避免上面的两种情况发生，就把单个事务的提交拆分为2个阶段：准备阶段(prepare) + 提交阶段(commit)\n【事务的二阶段提交过程】\nprepare 准备阶段: InnoDB 将内部事务id XID 写入redo log，并将其标记为 prepare 状态。然后将redo log 持久化到磁盘或者写入redo log buffer，具体取决于 innodb_flush_log_at_trx_commit 参数 commit 提交阶段：将内部事务id XID写入到binlog，调用write()函数写入到文件系统的Page Cache。当binlog写入磁盘成功就认为事务就是执行完成了，就算redo log 还是prepare状态也没事儿。 如何解决的上面提到的两种情况呢？\n情况一： 写完 redo log 之后，还处于prepare状态，还没写入binlog， 突然宕机了。 MySQL重启后，会顺序扫描redo log文件，如果还处于prepare状态，就查看redo log当中的内部事务IDXID在binlog中是否存在 如果binlog不存在内部事务idXID，表明redolog已经刷盘(写入磁盘了)，但是binlog还没有刷盘，直接回滚事务，就当这条事务执行失败 情况二： 写完bin log之后，还处于prepare状态，还没commit， 突然宕机了。 MySQL重启后，会顺序扫描redo log文件，如果还处于prepare状态，就查看redo log当中的内部事务IDXID在binlog中是否存在。 (一般都是先扫描redolog，再看binlog) 如果binlog里面有当前内部事务idXID，说明redolog和binlog都刷盘了，直接提交事务就好了。 【两阶段提交有没有什么问题】\n两阶段提交确实会导致磁盘I/O次数增高和锁的竞争变得激烈\n磁盘I/O的次数增高: 每次事务提交都会进行两次写入磁盘 fsync，一次redolog刷盘，一次binlog刷盘 锁竞争激烈：为了保证单事务的两个日志内容一致，所以需要在提交流程上，添加锁保证两阶段的原子性。确保日志里面的顺序，不受多事务提交的影响。 【优化二阶段提交：组提交】\n为了减少二阶段提交的I/O次数和锁的竞争，MySQL新增了组提交机制，可以让多个事务提交时合并多个binlog，只进行一次刷盘操作。组提交版本的二阶段提交只有commit提交部分有些变化：\nflush阶段：多个事务按照顺序将binlog从Cache写入到文件 (不刷盘)， 为了支撑redo log组提交 sync同步阶段：对binlog进行写入磁盘fsync操作，多个事务的binlog一并写入磁盘，为了支撑binlog的组提交 commit阶段: 所有事务按照顺序进行commit提交操作 每个阶段都有队列维护，锁针对队列进行保护，减小锁的范围的同时，提高效率。\n【binlog刷盘时间】\n事务执行过程中，线写日志到binlog cache (Server层的cache) 事务提交的时候，从binlog cache 写入到 binlog文件。单个事务的binlog不能拆开，只能一次性写入。 ​ MySQL分配了一片内存用于缓冲binlog ，就是binlog cache。可以用binlog_cache_size修改它的大小。\n29. 什么是 Write-Ahead Logging (WAL) 技术？它的优点是什么？MySQL 中是否用到了 WAL？ WAL 是用来确保在修改真正的数据之前，先将修改记录写入日志的技术。为了当系统宕机的时候，通过日志也可以恢复数据，MySQL的redo log就是依靠的 WAL技术。它的核心就是, 先写日志，再写数据\nMySQL事务从开启到提交的过程，大致如下：\n开启事务 -\u003e 查询数据到内存 -\u003e 记录undo log -\u003e 记录redo log(prepare阶段) -\u003e 更新内存 -\u003e 记录binlog -\u003e 记录redo log (commit之后)\ngraph LR subgraph \"传统写入方式（无WAL）的问题\" A1[用户提交事务] --\u003e B1[直接修改数据文件] B1 --\u003e C1{数据文件写入完成?} C1 -- 写入中断电 --\u003e D1[数据文件损坏原始数据丢失新数据不完整] C1 -- 写入成功 --\u003e E1[数据安全] D1 --\u003e F1[❌ 数据无法恢复] end subgraph \"WAL策略的优势\" A2[用户提交事务] --\u003e B2[1. 先写Redo Log记录：在页面X的偏移Y将值从A改为B] B2 --\u003e C2[2. 强制刷新Redo Log到磁盘fsync系统调用] C2 --\u003e D2[3. 返回用户事务成功] D2 --\u003e E2[4. 后台异步刷新数据页] subgraph \"崩溃恢复场景\" F2[系统崩溃重启] --\u003e G2[读取Redo Log] G2 --\u003e H2[重放所有已提交事务的修改] H2 --\u003e I2[✅ 数据完整恢复] end E2 --\u003e J2{系统崩溃?} J2 -- 正常运行 --\u003e K2[数据最终写入数据文件] J2 -- 崩溃 --\u003e F2 end subgraph \"WAL性能优势\" L1[顺序写入Redo Log高性能] --\u003e M1[随机写入数据文件可异步执行] N1[小尺寸日志记录快速I/O] --\u003e O1[大尺寸数据页面批量写入] end style D1 fill:#ffcdd2 style F1 fill:#ffcdd2 style I2 fill:#e8f5e8 style L1 fill:#e3f2fd style N1 fill:#e3f2fd 30. MySQL 中如果发生死锁应该如何解决？ 【如何处理MySQL死锁】\n设置MySQL死锁自动检测机制\nMySQL自带死锁检测机制innodb_deadlock_detect，开启即可。如果检查到死锁的发生，数据库会自动回滚一个持有资源较少的事务，然后另一个事务就可以执行了。\n-- 查看主动死锁检测是否开启 show variable like '%innodb_deadlock_detect%' -- 开启主动死锁检测 (默认为ON) set global innodb_deadlock_detect='ON' 设置锁等待超时参数\n可以设置获取锁的等待时间(默认为50s)，如果超过了这个时间，就会主动释放锁，让事务回滚\n-- 事务等待锁的超时时间 (默认为50s) show variable like '%innodb_lock_wait_timeout%' KILL死锁事务\n如果MySQL已经上线了，且没有设置那些检测，可以直接把死锁的事务kill掉。kill之前，需要查看一下执行的事务和表信息，用show engine innodb status\n-- 查看死锁日志 -- 查看正在执行的事务, 和相关的表信息 SHOW ENGINE INNODB STATUS -- 通过线程ID, 手动KILL死锁事务 kill 线程ID 【如何避免死锁的发生】\n避免大事务: 大事务占用的时间比较长，容易导致死锁发生。可以把大事务拆解成多个小事务，就可以降低死锁的发生概率。 更改数据库的隔离级别：MySQL的默认隔离级别是RR，它包含间隙锁和临键锁。如果改成RC，可以减少死锁的概率。 合理加索引，减少加锁范围：命中索引会对该行加上行锁，没有命中则会对整张表加上表锁。表锁的冲突概率比较大，容易导致死锁。 31. MySQL 中如何解决深度分页的问题？ 深度分页问题定义：深度分页是指当用户需要查询很久以前的数据，比如早年某个范围的订单。 SQL语句当中的 limit 偏移量变得非常大，MySQL性能直线下降的现象。\n为什么会性能下降: 因为MySQL会选择全表扫描，而不用索引扫描，导致效率低下。当 limit 偏移量偏大的时候，查询流程如下：\n扫描偏移量之前的1000000行，丢弃不符合条件的结果 每一次查询都需要用 age 列查到的主键值去回表，效率很低。(MySQL优化器就选择了，全表扫描 + 文件排序) 返回符合条件的最终记录 select * from user where sex = '女' order by age limit 1000000, 10 【如何解决深度分析带来的性能问题】\n记录上一次的最大ID，修改为范围查询 (如果能够保证 id 连续递增)\n查询的过程中，会走主键索引，加快查询速度。但是高并发的情况下，可能出现数据重复或者遗漏的情况。\n# 可以通过记录上次查询结果的最后一条记录进行下一页的查询 SELECT * FROM user WHERE id \u003e 1000000 LIMIT 10; 子查询\n通过子查询来获取 id 的起始值，把 limit 2000000 的条件转移到子查询。 查询过程如下：\n子查询语句利用id的主键索引快速找到这条记录，然后定位到 1000001 这条记录的主键 主查询语句将子查询返回的起始 ID 作为过滤条件，然后使用查询条件过滤掉前面的数据 可以减少全表扫描，提高性能。但是，子查询会生成临时表，复杂场景会导致性能下降。\nSELECT * FROM user WHERE id \u003e= ( SELECT id FROM user order by id limit 1000000,1 ) LIMIT 10; 延迟关联\n和子查询类似，将limit 操作转移到主键索引上，让其减少回表次数来优化查询 (只查询id不用回表)。然后将子查询中的结果合并到主查询当中，避免创建临时表。整体性能比子查询好。查询过程如下:\n子查询语句利用 id 的主键索引来快速找到符合条件的前10条记录的id 通过inner join 内连接将id 和 主表进行关联，获取完整记录 select user.* from user t1 inner join (SELECT id FROM user order by id limit 1000000, 10) t2 on t1.id = t2.id 覆盖索引：\n覆盖索引包含所有需要查询的字段(都是索引的，可以避免回表操作\n-- 覆盖索引查询 SELECT id, name FROM user by id limit 1000000, 10 优化方法 适用场景 优点 缺点 范围查询 主键或索引字段，连续性高 简单高效，减少扫面范围 不适用于非主键字段; 如果有高并发，可能会出现数据重复或者遗漏的情况。 子查询 偏移量大，索引列存在 利用索引快速定位，减少全表扫描 需要创建临时表，增加开销，复杂场景性能下降 延迟关联 主键索引存在，查询字段多 减少回表次数 查询逻辑复杂 覆盖索引 需要查询字段都包含在索引里面 无需回表查询，查询效率高 只能用于简单字段查询，查询的字段有优先 【如果出现表分页怎么办】\n假如出现表分页，比如现在有表1和表2。表1中按score字段排序为100,90,80，表2中按score字段排序为95,85,75。然后适用select score from student_info limit 1, 2 查询出来的是 90 (表1) 和 85 (表2)的合并结果。\n解决方案：将分页条件改写为limit 0, 3，取出所有前两页数据，再结合排序条件计算出正确的数据。如果遇到表分页的情况，必须从offset = 0的地方开始查询，避免漏掉数据。\n32. 什么是 MySQL 的主从同步机制？它是如何实现的？ 主从同步机制: 将主数据库上的数据同步到多个从数据库中的技术 为什么会有主从同步?: 因为如果MySQL只有一个数据库，当数据库文件损坏了，所有的数据都没了。为了防止这种单台故障，就有了主从数据库。主从数据库之间为了保持数据一致，就有了主从同步。 【主从同步的流程】\n从服务器创建线程: 从服务器开启主从复制之后，创建I/O线程和SQL线程 从服器和住服务器建立连接：从服务器的I/O线程和主服务器建立连接，主服务器的binlog dump 线程和从服务器进行交互 从服务器告知同步位置：从服务器的I/O线程会告知住服务器的 dump 线程从哪里开始接受 binlog。 **主服务器更新binlog：**主服务器把所有的更新记录从Page Cache 写入binlog 文件 (有三种格式：statement、row、mixed) dump线程控制binlog传输： 主服务器的dump线程检测到binlog变化，从指定位置读取。从服务器的I/O线程开始拉取binlog 文件，采用拉取模式有利于从库管理同步进度和处理延迟 中继存储到relay log： 从服务器的I/O线程将接收到的来自binlog中的内容，存储到relay log 重放relay log，写入数据：从服务器的SQL线程读取relay log 内容，解析成具体操作之后写入到对应的表中 【主从同步的三种方式】\n同步模式 说明 优点 缺点 异步复制(默认) 主库执行完事务马上给客户端返回，从库异步进行复制操作。 性能高 数据一致性低 同步复制 主库执行完事务等待从库复制完的信息，然后再给客户端返回 数据一致性高 性能较差，延迟大 半同步复制 主库执行完事务等待指定个数的从库复制完信息，然后给客户端返回 数据一致性和性能都居中 仍有丢失数据的可能 下面图片就是半同步复制/同步复制的过程，半同步复制可以设置检查从库的个数\n【从数据库的并行复制】\n从数据库默认是按照顺序逐条执行binlog的日志指令(也就是重放relay log)，但是串行执行可能导致从库的复制数据赶不上主库，所以就出现了下面的几种并行复制模式\n并行复制模式 特点 优缺点 MySQL 5.6 库级别并行 将不同数据库db1和db2的事务同时分开执行 事务都在同一个库时，失效 MySQL 5.7 组提交事务 将组提交的事务当作独立的事务，多线程并行执行 如果事务的last_commited相同，则说明再同一个组提交的，即便不冲突，也不能并发执行 MySQL 5.7 逻辑时钟 给prepare阶段的不存在锁冲突的事务打上时间标记sequece_number，后面直接提交 sequence_number就是last_commited，假如这个值相同，不冲突，也不能并发 MySQL 8.0 WriteSet WriteSet可以通过哈希算法对主键生成标识，来判断事务之间是否冲突，不冲突就可以并行复制 可能实现起来比较复杂 33. 如何处理 MySQL 的主从同步延迟？ 首先，MySQL的主从同步是一定存在延迟的。主从同步延迟是指主库更新完成之后，从库还没来得及更新，导致主从数据不一致。这种延迟对一些实时数据需求高的业务场景(比如金融系统)会造成影响。\n【为什么有主从同步延迟】\n从整体上看，有下面两个原因：\nrelay log赶不上binlog: 从库接受binlog的速度跟不上主库写入binlog的速度，从库的redo log就会比主库的binlog滞后 SQL执行赶不上relay log: 从库SQL线程执行relay log的速度比不上I/O线程接受binlog的速度，导致从库滞后relay log 导致上面两个情况发送的原因可能是：\n从库性能不足：CPU、内存、磁盘I/O比主库差一些，同步速度慢 从库读请求多：要分配一部分资源去满足读请求，影响同步的效率 主库提交太多大事务：从库去同步一个大事务需要较长的时间 从库数量过多：主库推送binlog开销大，导致延迟 网络延迟：主库和从库之间的网络延迟比较大，导致同步速度受限制 复制模式：默认采用异步复制模式，主库不等待从库完成复制，肯定有延迟 【避免延迟的方法】\n强行把写入后的读请求交给主库处理 （不推荐）: 把写入后的读请求给主库处理，可以避免主从延迟，但是主库承受的压力也会增大\n用半同步复制：半同步复制可以保证至少有一个从库复制完成了\nSET GLOBAL rpl_semi_sync_master_enabled = 1; SET GLOBAL rpl_semi_sync_slave_enabled = 1; 优化主从结构\n提升从库性能：配好一点的CPU、内存、磁盘I/O 减少从库数量：减少主库的同步开销 拆分读流量：把读请求负载均衡到多个从库上 sleep方案：假设主从库的延迟为1s，可以每次执行一个 select sleep(1)， 保证拿到最新的数据。\n34. MySQL中的长事务可能会导致哪些问题？ 长时间的锁竞争，阻塞资源：长事务持有的锁时间比较长，容易导致其他事务再获取相同锁的时候，发送阻塞，增加系统的等待时间和降低并发性能。业务线程会因为长时间的数据库请求而被阻塞，部分业务的阻塞会影响到其他的业务，导致产生雪崩。最终可能会让服务全面崩盘，导致严重的线上事故。 死锁风险：长事务更容易产生死锁，因为可能存在多个事务在互相等待对方释放锁，导致系统死锁。 主从延迟：长事务容易导致主从延迟，因为长事务需要主库花更长的时间执行，然后通过binlog传给从库。从库读取relay log的时候，重发操作又需要一长段时间，可能导致一大段时间数据是不同步的。 回滚导致时间浪费：如果事务执行了很长一段时间，突然执行出错，需要事务回滚，之前的执行都浪费了，耗费时间。 版本链过长：假如事务A对某条数据执行了10000次修改操作，在没有提交之前，事务B进行select 操作，会需要耗费很长的时间。 【长事务的SQL如何处理】\n拆分长事务SQL: 把单条SQL拆分为多条短事务SQL\n# 假如需要删除2021年的数据(4.8亿条)，共5亿条数据 delete from yes where create_date \u003e \" 2020-12-31\" and create_date \u003c \"2022-01-01\"; # 按照日期进行拆分成多条事务 delete from yes where create_date \u003e \" 2020-12-31\" and create_date \u003c \"2021-02-01\"; .... delete from yes where create_date \u003e \" 2021-11-31\" and create_date \u003c \"2022-01-01\"; 反向操作减轻事务时间：把需要旧表删除的数据转成新增到新的表，然后用新表替换旧表就可以了。\n",
  "wordCount" : "4185",
  "inLanguage": "en",
  "image": "https://swimmingliu.cn/papermod-cover.png","datePublished": "2025-02-19T15:16:42+08:00",
  "dateModified": "2025-09-07T21:16:42+08:00",
  "author":[{
    "@type": "Person",
    "name": "SwimmingLiu"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://swimmingliu.cn/posts/job/mysql-interview-questions/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "SwimmingLiu's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://swimmingliu.cn/images/swimmingliu_icon.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://swimmingliu.cn/" accesskey="h" title="𝓢𝔀𝓲𝓶𝓶𝓲𝓷𝓰𝓛𝓲𝓾&#39;𝓼 𝓑𝓵𝓸𝓰 (Alt + H)">
                <img src="https://swimmingliu.cn/images/swimmingliu_icon.png" alt="" aria-label="logo"
                    height="30">𝓢𝔀𝓲𝓶𝓶𝓲𝓷𝓰𝓛𝓲𝓾&#39;𝓼 𝓑𝓵𝓸𝓰</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://swimmingliu.cn/index.html" title="🏡 Home">
                    <span>🏡 Home</span>
                </a>
            </li>
            <li>
                <a href="https://swimmingliu.cn/search/" title="🔍 Search">
                    <span>🔍 Search</span>
                </a>
            </li>
            <li>
                <a href="https://swimmingliu.cn/posts/" title="🗒️ Posts">
                    <span>🗒️ Posts</span>
                </a>
            </li>
            <li>
                <a href="https://swimmingliu.cn/archives/" title="📃 Archive">
                    <span>📃 Archive</span>
                </a>
            </li>
            <li>
                <a href="https://swimmingliu.cn/tags/" title="📑 Tags">
                    <span>📑 Tags</span>
                </a>
            </li>
            <li>
                <a href="https://bento.me/swimmingliu" title="👨🏻‍🎓 About Me">
                    <span>👨🏻‍🎓 About Me</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
            <li>
                <a href="https://www.emojisearch.app/" title="Emoji">
                    <span>Emoji</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://swimmingliu.cn/">Home</a>&nbsp;»&nbsp;<a href="https://swimmingliu.cn/posts/">📚 Posts</a>&nbsp;»&nbsp;<a href="https://swimmingliu.cn/posts/job/">💻 Job</a></div>
    <h1 class="post-title entry-hint-parent">
      MySQL面试题笔记
    </h1>
    <div class="post-meta"><span title='2025-02-19 15:16:42 +0800 CST'>February 19, 2025</span>&nbsp;·&nbsp;20 min&nbsp;·&nbsp;SwimmingLiu

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#1mysql-%e4%b8%ad%e7%9a%84%e6%95%b0%e6%8d%ae%e6%8e%92%e5%ba%8f%e6%98%af%e6%80%8e%e4%b9%88%e5%ae%9e%e7%8e%b0%e7%9a%84" aria-label="1.MySQL 中的数据排序是怎么实现的？">1.MySQL 中的数据排序是怎么实现的？</a></li>
                <li>
                    <a href="#2-mysql-%e7%9a%84-change-buffer-%e6%98%af%e4%bb%80%e4%b9%88%e5%ae%83%e6%9c%89%e4%bb%80%e4%b9%88%e4%bd%9c%e7%94%a8" aria-label="2. MySQL 的 Change Buffer 是什么？它有什么作用？">2. MySQL 的 Change Buffer 是什么？它有什么作用？</a></li>
                <li>
                    <a href="#3-%e8%af%a6%e7%bb%86%e6%8f%8f%e8%bf%b0%e4%b8%80%e6%9d%a1-sql-%e8%af%ad%e5%8f%a5%e5%9c%a8-mysql-%e4%b8%ad%e7%9a%84%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b" aria-label="3. 详细描述一条 SQL 语句在 MySQL 中的执行过程。">3. 详细描述一条 SQL 语句在 MySQL 中的执行过程。</a></li>
                <li>
                    <a href="#%e8%a1%a5%e5%85%85-3--mysql-%e6%97%a5%e5%bf%97undo-logredo-logbinlog-%e6%9c%89%e4%bb%80%e4%b9%88%e7%94%a8" aria-label="[补充] 3.  MySQL 日志：undo log、redo log、binlog 有什么用？">[补充] 3.  MySQL 日志：undo log、redo log、binlog 有什么用？</a></li>
                <li>
                    <a href="#4-mysql-%e7%9a%84%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e%e6%9c%89%e5%93%aa%e4%ba%9b%e5%ae%83%e4%bb%ac%e4%b9%8b%e9%97%b4%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="4. MySQL 的存储引擎有哪些？它们之间有什么区别？">4. MySQL 的存储引擎有哪些？它们之间有什么区别？</a></li>
                <li>
                    <a href="#5-mysql-%e7%9a%84%e7%b4%a2%e5%bc%95%e7%b1%bb%e5%9e%8b%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="5. MySQL 的索引类型有哪些？">5. MySQL 的索引类型有哪些？</a></li>
                <li>
                    <a href="#6-mysql-innodb-%e5%bc%95%e6%93%8e%e4%b8%ad%e7%9a%84%e8%81%9a%e7%b0%87%e7%b4%a2%e5%bc%95%e5%92%8c%e9%9d%9e%e8%81%9a%e7%b0%87%e7%b4%a2%e5%bc%95%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="6. MySQL InnoDB 引擎中的聚簇索引和非聚簇索引有什么区别？">6. MySQL InnoDB 引擎中的聚簇索引和非聚簇索引有什么区别？</a></li>
                <li>
                    <a href="#7-mysql-%e4%b8%ad%e7%9a%84%e5%9b%9e%e8%a1%a8%e6%98%af%e4%bb%80%e4%b9%88" aria-label="7. MySQL 中的回表是什么？">7. MySQL 中的回表是什么？</a></li>
                <li>
                    <a href="#8-mysql%e7%b4%a2%e5%bc%95%e7%9a%84%e6%9c%80%e5%b7%a6%e5%89%8d%e7%bc%80%e5%8c%b9%e9%85%8d%e5%8e%9f%e5%88%99%e6%98%af%e4%bb%80%e4%b9%88" aria-label="8. MySQL索引的最左前缀匹配原则是什么?">8. MySQL索引的最左前缀匹配原则是什么?</a></li>
                <li>
                    <a href="#9-mysql%e7%9a%84%e8%a6%86%e7%9b%96%e7%b4%a2%e5%bc%95%e6%98%af%e4%bb%80%e4%b9%88" aria-label="9. MySQL的覆盖索引是什么？">9. MySQL的覆盖索引是什么？</a></li>
                <li>
                    <a href="#10-mysql%e7%9a%84%e7%b4%a2%e5%bc%95%e4%b8%8b%e6%8e%a8-icp-%e6%98%af%e4%bb%80%e4%b9%88" aria-label="10. MySQL的索引下推 (ICP) 是什么?">10. MySQL的索引下推 (ICP) 是什么?</a></li>
                <li>
                    <a href="#11-mysql%e5%bb%ba%e7%b4%a2%e5%bc%95%e9%9c%80%e8%a6%81%e6%b3%a8%e6%84%8f%e5%93%aa%e4%ba%9b%e4%ba%8b%e9%a1%b9" aria-label="11. MySQL建索引需要注意哪些事项？">11. MySQL建索引需要注意哪些事项？</a></li>
                <li>
                    <a href="#12-mysql%e4%b8%ad%e4%bd%bf%e7%94%a8%e7%b4%a2%e5%bc%95%e4%b8%80%e5%ae%9a%e6%9c%89%e6%95%88%e5%90%97%e5%a6%82%e4%bd%95%e6%8e%92%e6%9f%a5%e7%b4%a2%e5%bc%95%e6%95%88%e6%9e%9c" aria-label="12. MySQL中使用索引一定有效吗？如何排查索引效果？">12. MySQL中使用索引一定有效吗？如何排查索引效果？</a></li>
                <li>
                    <a href="#13-mysql%e7%9a%84%e7%b4%a2%e5%bc%95%e6%95%b0%e6%98%af%e5%90%a6%e8%b6%8a%e5%a4%9a%e8%b6%8a%e5%a5%bdwhy" aria-label="13. MySQL的索引数是否越多越好？why?">13. MySQL的索引数是否越多越好？why?</a></li>
                <li>
                    <a href="#14-%e4%b8%ba%e4%bb%80%e4%b9%88-mysql-%e9%80%89%e6%8b%a9%e4%bd%bf%e7%94%a8-b-%e6%a0%91%e4%bd%9c%e4%b8%ba%e7%b4%a2%e5%bc%95%e7%bb%93%e6%9e%84" aria-label="14. 为什么 MySQL 选择使用 B&#43; 树作为索引结构？">14. 为什么 MySQL 选择使用 B+ 树作为索引结构？</a></li>
                <li>
                    <a href="#15-mysql-%e4%b8%89%e5%b1%82-b-%e6%a0%91%e8%83%bd%e5%ad%98%e5%a4%9a%e5%b0%91%e6%95%b0%e6%8d%ae" aria-label="15. MySQL 三层 B&#43; 树能存多少数据？">15. MySQL 三层 B+ 树能存多少数据？</a></li>
                <li>
                    <a href="#16-mysql%e5%a6%82%e4%bd%95%e8%bf%9b%e8%a1%8csql%e8%b0%83%e4%bc%98" aria-label="16. MySQL如何进行SQL调优">16. MySQL如何进行SQL调优</a></li>
                <li>
                    <a href="#%e8%a1%a5%e5%85%85-161-mysql%e4%b8%ad%e7%9a%84%e6%85%a2sql%e5%a6%82%e4%bd%95%e6%8e%92%e6%9f%a5-%e5%ae%8c%e6%95%b4%e6%8e%92%e6%9f%a5%e9%93%be%e8%b7%af" aria-label="[补充] 16.1 MySQL中的慢SQL如何排查 （完整排查链路）">[补充] 16.1 MySQL中的慢SQL如何排查 （完整排查链路）</a></li>
                <li>
                    <a href="#17-%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8mysql%e7%9a%84explain%e8%af%ad%e5%8f%a5%e8%bf%9b%e8%a1%8c%e6%9f%a5%e8%af%a2%e5%88%86%e6%9e%90" aria-label="17. 如何使用MySQL的EXPLAIN语句进行查询分析?">17. 如何使用MySQL的EXPLAIN语句进行查询分析?</a></li>
                <li>
                    <a href="#18--%e8%af%b7%e8%af%a6%e7%bb%86%e6%8f%8f%e8%bf%b0-mysql-%e7%9a%84-b-%e6%a0%91%e4%b8%ad%e6%9f%a5%e8%af%a2%e6%95%b0%e6%8d%ae%e7%9a%84%e5%85%a8%e8%bf%87%e7%a8%8b" aria-label="18.  请详细描述 MySQL 的 B&#43; 树中查询数据的全过程">18.  请详细描述 MySQL 的 B+ 树中查询数据的全过程</a></li>
                <li>
                    <a href="#19-mysql-%e4%b8%ad-countcount1-%e5%92%8c-count%e5%ad%97%e6%ae%b5%e5%90%8d-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="19. MySQL 中 count(*)、count(1) 和 count(字段名) 有什么区别？">19. MySQL 中 count(*)、count(1) 和 count(字段名) 有什么区别？</a></li>
                <li>
                    <a href="#20-mysql-%e4%b8%ad-varchar-%e5%92%8c-char-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="20. MySQL 中 varchar 和 char 有什么区别？">20. MySQL 中 varchar 和 char 有什么区别？</a></li>
                <li>
                    <a href="#21-mysql-%e6%98%af%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e4%ba%8b%e5%8a%a1%e7%9a%84" aria-label="21. MySQL 是如何实现事务的？">21. MySQL 是如何实现事务的？</a></li>
                <li>
                    <a href="#22-mysql%e6%9c%89%e5%93%aa%e4%ba%9b%e9%94%81%e7%9a%84%e7%b1%bb%e5%9e%8b" aria-label="22. MySQL有哪些锁的类型?">22. MySQL有哪些锁的类型?</a></li>
                <li>
                    <a href="#23-mysql-%e4%b8%ad%e7%9a%84-mvcc-%e6%98%af%e4%bb%80%e4%b9%88" aria-label="23. MySQL 中的 MVCC 是什么？">23. MySQL 中的 MVCC 是什么？</a></li>
                <li>
                    <a href="#%e8%a1%a5%e5%85%85-231-mysql%e4%ba%8b%e5%8a%a1%e7%9a%84%e5%9b%9b%e5%a4%a7%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86" aria-label="[补充] 23.1 MySQL事务的四大隔离级别实现原理？">[补充] 23.1 MySQL事务的四大隔离级别实现原理？</a></li>
                <li>
                    <a href="#%e8%a1%a5%e5%85%85-232-mysql%e4%ba%8b%e5%8a%a1%e7%9a%84%e5%9b%9b%e5%a4%a7%e7%89%b9%e6%80%a7%e7%9a%84%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86" aria-label="[补充] 23.2 MySQL事务的四大特性的底层原理？">[补充] 23.2 MySQL事务的四大特性的底层原理？</a></li>
                <li>
                    <a href="#24-mysql-%e4%b8%ad%e7%9a%84%e6%97%a5%e5%bf%97%e7%b1%bb%e5%9e%8b%e6%9c%89%e5%93%aa%e4%ba%9bbinlogredo-log-%e5%92%8c-undo-log-%e7%9a%84%e4%bd%9c%e7%94%a8%e5%92%8c%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" aria-label="24. MySQL 中的日志类型有哪些？binlog、redo log 和 undo log 的作用和区别是什么？">24. MySQL 中的日志类型有哪些？binlog、redo log 和 undo log 的作用和区别是什么？</a></li>
                <li>
                    <a href="#25-mysql%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="25. MySQL隔离级别有哪些?">25. MySQL隔离级别有哪些?</a></li>
                <li>
                    <a href="#26-%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e8%84%8f%e8%af%bb%e4%b8%8d%e5%8f%af%e9%87%8d%e5%a4%8d%e8%af%bb%e5%92%8c%e5%b9%bb%e8%af%bb%e5%88%86%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" aria-label="26. 数据库的脏读、不可重复读和幻读分别是什么？">26. 数据库的脏读、不可重复读和幻读分别是什么？</a></li>
                <li>
                    <a href="#27-mysql-%e9%bb%98%e8%ae%a4%e7%9a%84%e4%ba%8b%e5%8a%a1%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88%e4%b8%ba%e4%bb%80%e4%b9%88%e9%80%89%e6%8b%a9%e8%bf%99%e4%b8%aa%e7%ba%a7%e5%88%ab" aria-label="27. MySQL 默认的事务隔离级别是什么？为什么选择这个级别？">27. MySQL 默认的事务隔离级别是什么？为什么选择这个级别？</a></li>
                <li>
                    <a href="#28-mysql-%e4%ba%8b%e5%8a%a1%e7%9a%84%e4%ba%8c%e9%98%b6%e6%ae%b5%e6%8f%90%e4%ba%a4%e6%98%af%e4%bb%80%e4%b9%88-mysql%e9%87%8c%e9%9d%a2%e7%9a%84-redolog-%e5%92%8c-binlog-%e6%80%8e%e4%b9%88%e4%bf%9d%e6%8c%81%e4%b8%80%e8%87%b4" aria-label="28. MySQL 事务的二阶段提交是什么？/ MySQL里面的 Redolog 和 BinLog 怎么保持一致?">28. MySQL 事务的二阶段提交是什么？/ MySQL里面的 Redolog 和 BinLog 怎么保持一致?</a></li>
                <li>
                    <a href="#29-%e4%bb%80%e4%b9%88%e6%98%af-write-ahead-logging-wal-%e6%8a%80%e6%9c%af%e5%ae%83%e7%9a%84%e4%bc%98%e7%82%b9%e6%98%af%e4%bb%80%e4%b9%88mysql-%e4%b8%ad%e6%98%af%e5%90%a6%e7%94%a8%e5%88%b0%e4%ba%86-wal" aria-label="29. 什么是 Write-Ahead Logging (WAL) 技术？它的优点是什么？MySQL 中是否用到了 WAL？">29. 什么是 Write-Ahead Logging (WAL) 技术？它的优点是什么？MySQL 中是否用到了 WAL？</a></li>
                <li>
                    <a href="#30-mysql-%e4%b8%ad%e5%a6%82%e6%9e%9c%e5%8f%91%e7%94%9f%e6%ad%bb%e9%94%81%e5%ba%94%e8%af%a5%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3" aria-label="30. MySQL 中如果发生死锁应该如何解决？">30. MySQL 中如果发生死锁应该如何解决？</a></li>
                <li>
                    <a href="#31-mysql-%e4%b8%ad%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e6%b7%b1%e5%ba%a6%e5%88%86%e9%a1%b5%e7%9a%84%e9%97%ae%e9%a2%98" aria-label="31. MySQL 中如何解决深度分页的问题？">31. MySQL 中如何解决深度分页的问题？</a></li>
                <li>
                    <a href="#32-%e4%bb%80%e4%b9%88%e6%98%af-mysql-%e7%9a%84%e4%b8%bb%e4%bb%8e%e5%90%8c%e6%ad%a5%e6%9c%ba%e5%88%b6%e5%ae%83%e6%98%af%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e7%9a%84" aria-label="32. 什么是 MySQL 的主从同步机制？它是如何实现的？">32. 什么是 MySQL 的主从同步机制？它是如何实现的？</a></li>
                <li>
                    <a href="#33-%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86-mysql-%e7%9a%84%e4%b8%bb%e4%bb%8e%e5%90%8c%e6%ad%a5%e5%bb%b6%e8%bf%9f" aria-label="33. 如何处理 MySQL 的主从同步延迟？">33. 如何处理 MySQL 的主从同步延迟？</a></li>
                <li>
                    <a href="#34-mysql%e4%b8%ad%e7%9a%84%e9%95%bf%e4%ba%8b%e5%8a%a1%e5%8f%af%e8%83%bd%e4%bc%9a%e5%af%bc%e8%87%b4%e5%93%aa%e4%ba%9b%e9%97%ae%e9%a2%98" aria-label="34. MySQL中的长事务可能会导致哪些问题？">34. MySQL中的长事务可能会导致哪些问题？</a>
                </li>
            </ul>
        </div>
    </details>
</div>
  <div class="post-content"><h2 id="1mysql-中的数据排序是怎么实现的">1.MySQL 中的数据排序是怎么实现的？<a hidden class="anchor" aria-hidden="true" href="#1mysql-中的数据排序是怎么实现的">#</a></h2>
<p>1.<strong>排序方法</strong>：索引排序和文件排序 (filesort)</p>
<p>2.<strong>索引排序</strong>：如果<code>order by xxx</code>的字段为索引字段，则利用索引进行排序。效率最高，索引默认有序。</p>
<p>3.<strong>文件排序 (filesort)</strong>：内存排序(单路排序和双路排序)和磁盘排序，具体取决于排序数据的大小。其中，内存排序使用单路排序或双路排序，取决于<code>max_length_for_sort_data</code>(默认为4096个字节)</p>
<p>4.<strong>双路排序</strong>：取<code>row_id</code>(如果有主键，则为主键)和<code>select a,b,c order by xxx</code>的<code>xxx</code>字段放入<code>sort_buffer</code>(排序缓存)中，将排序后的<code>row_id</code>回表查询<code>a,b,c</code></p>
<p>5.<strong>单路排序</strong>: 直接把要查的所有字段放入<code>sort_buffer</code>里，排序后直接得到结果集合</p>
<p>6.<strong>磁盘排序</strong>（归并排序）:将数据分为多份文件，单独对文件进行排序，然后合并成一个有序的大文件</p>
<h2 id="2-mysql-的-change-buffer-是什么它有什么作用">2. MySQL 的 Change Buffer 是什么？它有什么作用？<a hidden class="anchor" aria-hidden="true" href="#2-mysql-的-change-buffer-是什么它有什么作用">#</a></h2>
<p>1.ChangeBuffer定义：Change Buffer是InnoDB缓冲当中的一块缓存区，用于暂存二级索引的修改，避免二级索引页修改产生的随机IO
2.ChangeBuffer注意事项：只能用于二级索引，不能用于其他任何索引，包括主键索引和唯一索引都不行。
3.如果ChangeBuffer挂了，更改操作未执行，是否会出现脏数据？
首先，ChangeBuffer也会保存在磁盘空间里面，redo log会记录Change Buffer当中的修改操作，确保数据一致性。</p>
<p>知识拓展1：一级索引和二级索引区别</p>
<blockquote>
<p><strong>一级索引（聚簇索引）</strong>：数据表的主键索引，数据和索引存储在同一B+树的叶子节点中。每个表只能有一个一级索引。</p>
<p><strong>二级索引（非聚簇索引）</strong>：除主键外的其他索引，叶子节点存储索引列的值和对应的主键值。通过二级索引查询时，需要先通过二级索引获取主键值，再通过主键值查询数据，这个过程称为“回表”。</p></blockquote>
<p>知识拓展2:  MySQL中有哪些常见索引？都有什么区别？</p>
<blockquote>
<p>在MySQL中，索引是提高查询效率的关键工具。常见的索引类型包括主键索引、唯一索引、普通索引、全文索引和空间索引。</p>
<p><strong>1. 主键索引（Primary Key Index）</strong></p>
<ul>
<li><strong>定义</strong>：主键索引是一种特殊的唯一索引，用于唯一标识表中的每一行数据。每个表只能有一个主键索引，且主键列的值不能为空。</li>
<li><strong>特点</strong>：主键索引的叶子节点存储完整的数据行，因此查询效率高。在InnoDB存储引擎中，主键索引是聚簇索引，数据存储与索引结构合并。</li>
</ul>
<p><strong>2. 唯一索引（Unique Index）</strong></p>
<ul>
<li><strong>定义</strong>：唯一索引确保索引列的每个值都是唯一的，但允许有空值。与主键索引类似，不同之处在于唯一索引允许列值为NULL。</li>
<li><strong>特点</strong>：唯一索引的叶子节点存储索引列的值和对应的主键值。在InnoDB中，唯一索引是非聚簇索引，数据存储与索引结构分开。</li>
</ul>
<p><strong>3. 普通索引（Index）</strong></p>
<ul>
<li><strong>定义</strong>：普通索引是最基本的索引类型，没有任何限制。索引列的值可以重复，也可以为NULL。</li>
<li><strong>特点</strong>：普通索引的叶子节点存储索引列的值和对应的主键值。在InnoDB中，普通索引是非聚簇索引，数据存储与索引结构分开。</li>
</ul>
<p><strong>4. 全文索引（Fulltext Index）</strong></p>
<ul>
<li><strong>定义</strong>：全文索引用于对文本数据进行全文搜索，适用于MyISAM存储引擎。它允许对文本字段进行复杂的搜索，如查找包含特定单词的记录。</li>
<li><strong>特点</strong>：全文索引的叶子节点存储文档的词项信息。在MyISAM中，全文索引是非聚簇索引，数据存储与索引结构分开。</li>
</ul>
<p><strong>5. 空间索引（Spatial Index）</strong></p>
<ul>
<li><strong>定义</strong>：空间索引用于对地理空间数据进行索引，支持空间数据类型的快速查询。它适用于存储地理位置、地图等空间数据的表。</li>
<li><strong>特点</strong>：空间索引的叶子节点存储空间数据的索引信息。在MyISAM中，空间索引是非聚簇索引，数据存储与索引结构分开。</li>
</ul>
<p><strong>总结</strong>：</p>
<ul>
<li><strong>主键索引</strong>：用于唯一标识每一行数据，值不能为空。</li>
<li><strong>唯一索引</strong>：确保索引列的值唯一，但允许有空值。</li>
<li><strong>普通索引</strong>：最基本的索引类型，允许重复和空值。</li>
<li><strong>全文索引</strong>：用于对文本数据进行全文搜索，适用于MyISAM存储引擎。</li>
<li><strong>空间索引</strong>：用于对地理空间数据进行索引，支持空间数据类型的快速查询。</li>
</ul></blockquote>
<h2 id="3-详细描述一条-sql-语句在-mysql-中的执行过程">3. 详细描述一条 SQL 语句在 MySQL 中的执行过程。<a hidden class="anchor" aria-hidden="true" href="#3-详细描述一条-sql-语句在-mysql-中的执行过程">#</a></h2>
<ol>
<li>连接器判断用户是否成功建立连接，数据库连接的权限校验</li>
<li>连接器会查询缓存，<code>key</code> 是 SQL 语句，<code>value</code> 是查询结果。如果命中，直接返回查询结果。(MySQL 8.0之后，就移除这个功能了)。</li>
<li>分析器分析SQL语法和词法是否有误</li>
<li>优化器生成SQL的执行计划，确定使用的索引和调整where的执行顺序（包括连表顺序）</li>
<li>执行器判断当前用户是否有权限查询该表，然后执行该SQL语句</li>
</ol>
<p><img alt="MySQL架构图" loading="lazy" src="https://oss.swimmingliu.cn/7457976c-ef5d-11ef-b738-c858c0c1deba"></p>
<p>[参考文献] <a href="https://xiaolincoding.com/mysql/base/how_select.html">执行一条 select 语句，期间发生了什么？</a></p>
<h2 id="补充-3--mysql-日志undo-logredo-logbinlog-有什么用">[补充] 3.  MySQL 日志：undo log、redo log、binlog 有什么用？<a hidden class="anchor" aria-hidden="true" href="#补充-3--mysql-日志undo-logredo-logbinlog-有什么用">#</a></h2>
<blockquote>
<p>undo log（回滚日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和 MVCC。
redo log（重做日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的持久性，主要用于掉电等故障恢复；
binlog （归档日志）：是 Server 层生成的日志，主要用于数据备份和主从复制；</p></blockquote>
<p>直接看参考文献当中的七个问题和其解决方案</p>
<p>[参考文献] <a href="https://xiaolincoding.com/mysql/log/how_update.html">MySQL 日志：undo log、redo log、binlog 有什么用？</a></p>
<h2 id="4-mysql-的存储引擎有哪些它们之间有什么区别">4. MySQL 的存储引擎有哪些？它们之间有什么区别？<a hidden class="anchor" aria-hidden="true" href="#4-mysql-的存储引擎有哪些它们之间有什么区别">#</a></h2>
<p><code>InnoDB</code> : 支持事务、<strong>行锁</strong>、外键; 高并发性能、支持高负载的OLTP应用 (银行交易、电子商务订单、库存管理等);  聚集索引存储，检索效率高</p>
<p><code>MyISAM</code>: <strong>表锁</strong>、<strong>不</strong>支持事务和外键; 适用于读多写少的场景(数据仓库); 较高读性能和j较快的表级锁定</p>
<p><code>MEMORY</code>: 存储在内存中，速度快，重启后数据丢失; 适用于临时数据存储和快速存储</p>
<p><img alt="MySQL常见存储引擎" loading="lazy" src="https://oss.swimmingliu.cn/749c5e36-ef5d-11ef-9041-c858c0c1deba"></p>
<h2 id="5-mysql-的索引类型有哪些">5. MySQL 的索引类型有哪些？<a hidden class="anchor" aria-hidden="true" href="#5-mysql-的索引类型有哪些">#</a></h2>
<table>
  <thead>
      <tr>
          <th>划分方向</th>
          <th>索引类型</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>数据结构</td>
          <td>B+树索引、Hash索引、倒排索引 (全文索引)、R-树索引 (多维空间树)、位图索引(Bitmap)</td>
      </tr>
      <tr>
          <td>物理存储</td>
          <td>聚簇索引、非聚簇索引</td>
      </tr>
      <tr>
          <td>字段特性</td>
          <td>主键索引、唯一索引、普通索引(二级索引、辅助索引)、前缀索引</td>
      </tr>
      <tr>
          <td>字段个数</td>
          <td>单列索引、联合索引</td>
      </tr>
  </tbody>
</table>
<p><img alt="MySQL索引类型" loading="lazy" src="https://oss.swimmingliu.cn/74d567c0-ef5d-11ef-8176-c858c0c1deba"></p>
<h2 id="6-mysql-innodb-引擎中的聚簇索引和非聚簇索引有什么区别">6. MySQL InnoDB 引擎中的聚簇索引和非聚簇索引有什么区别？<a hidden class="anchor" aria-hidden="true" href="#6-mysql-innodb-引擎中的聚簇索引和非聚簇索引有什么区别">#</a></h2>
<blockquote>
<p><strong>聚簇索引</strong>：就像是图书馆里按照书籍主题顺序摆放的书架。在这个书架（也就是聚簇索引）上，每本书（也就是数据库中的行数据）都是按照某个主题（通常是主键）来排列的。所以，当你想要找某一主题的书时，只要知道主题名（主键值），就能很快在书架上找到它，而且相邻主题的书也是挨在一起的，找起来很方便。但是，这种方式的缺点是，如果你想要改变某本书的主题（更新主键），可能就需要移动整本书到新的位置，甚至可能需要重新整理整个书架（数据页），这样就比较麻烦了。</p>
<p><strong>非聚簇索引</strong>：则更像是图书馆里的一个索引卡片箱。在这个卡片箱里，每张卡片（也就是非聚簇索引的节点）上都写着书籍的主题（索引列的值）和书籍在书架上的位置（主键值或ROWID）。当你想要找一本书时，可以先在卡片箱里找到对应的卡片，然后根据卡片上的位置信息去书架上找书。这种方式的好处是灵活，你可以为不同的书籍主题制作多张卡片，方便从不同的角度查找书籍。但是，坏处是每次找书都需要两步：先在卡片箱里找卡片，再去书架上找书，这样可能会比直接在书架上找书要慢一些。</p>
<p>总的来说，聚簇索引和非聚簇索引的主要区别在于它们如何存储数据和索引，以及它们如何影响数据的查询和更新操作。聚簇索引将数据直接存储在索引上，查询效率高，但更新操作可能较复杂；而非聚簇索引则通过索引指向数据，提供了更多的灵活性，但查询时可能需要额外的步骤。在选择使用哪种索引时，需要根据具体的应用场景和查询需求来决定。</p></blockquote>
<ul>
<li>
<p><strong>聚簇索引 (Clustered Index)</strong>：它的叶子节点存储了 <strong>完整的用户数据行</strong>。可以理解为“数据就是索引，索引就是数据”。</p>
</li>
<li>
<p><strong>非聚簇索引 (Non-Clustered Index)</strong>，也叫二级索引(Secondary Index)：它的叶子节点存储的是 <strong>索引列的值</strong> 以及对应数据行的 <strong>主键值</strong>。</p>
</li>
</ul>
<table>
  <thead>
      <tr>
          <th>特性</th>
          <th>聚簇索引 (Clustered Index)</th>
          <th>非聚簇索引 (Non-Clustered Index / Secondary Index)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>数量</strong></td>
          <td>每张表只能有一个</td>
          <td>每张表可以有多个</td>
      </tr>
      <tr>
          <td><strong>叶子节点存储</strong></td>
          <td>完整的行数据</td>
          <td>索引列 + 主键值</td>
      </tr>
      <tr>
          <td><strong>数据存储方式</strong></td>
          <td>数据本身按索引顺序物理存储</td>
          <td>索引和数据分离存储</td>
      </tr>
      <tr>
          <td><strong>查询效率</strong></td>
          <td>基于主键的查询和范围查询速度极快</td>
          <td>依赖“回表”，可能需要两次B+树查询，速度相对较慢（除非触发覆盖索引）</td>
      </tr>
      <tr>
          <td><strong>插入/更新性能</strong></td>
          <td>插入速度依赖于主键的有序性，可能导致“页分裂”，维护成本较高</td>
          <td>维护成本相对较低，只需要维护自身的B+树结构</td>
      </tr>
      <tr>
          <td><strong>优点</strong></td>
          <td>1. 主键查询快。<br>2. 范围查询性能好（数据物理连续）。</td>
          <td>1. 结构更轻量。<br>2. 避免了频繁移动数据行。</td>
      </tr>
      <tr>
          <td><strong>缺点</strong></td>
          <td>1. 插入无序主键（如UUID）性能差。<br>2. 更新主键的代价极高。<br>3. 二级索引查询需要回表。</td>
          <td>1. 查询可能需要回表，产生额外I/O。<br>2. 不适合进行大范围的范围查询。</td>
      </tr>
  </tbody>
</table>
<pre class="mermaid">graph LR
    subgraph "非聚簇索引 (name)"
        A[B+树根节点] --> B{非叶子节点};
        B --> C[叶子节点<br>name='Tom', id=18];
    end

    subgraph "聚簇索引 (id/主键)"
        D[B+树根节点] --> E{非叶子节点};
        E --> F[叶子节点<br>id=18, name='Tom', age=25, ...];
    end

    C -- "1. 查name索引拿到主键id=18" --> G((回表过程));
    G -- "2. 用主键id=18查聚簇索引" --> F;
    F -- "3. 获取整行数据,返回age=25" --> H((查询结果));

    style C fill:#f9f,stroke:#333,stroke-width:2px
    style F fill:#ccf,stroke:#333,stroke-width:2px
</pre>

<h2 id="7-mysql-中的回表是什么">7. MySQL 中的回表是什么？<a hidden class="anchor" aria-hidden="true" href="#7-mysql-中的回表是什么">#</a></h2>
<ol>
<li>
<p>回表：指使用非聚簇索引（二级索引）查询时，由于索引中只存储了索引列的值和主键值，当需要获取其他列的数据时，必须通过主键再次访问聚簇索引（主键索引）来获取完整行数据的过程。</p>
<pre class="mermaid">graph LR
    subgraph "客户端查询"
        A[SELECT age FROM user WHERE name = 'Tom']
    end

    subgraph "二级索引(name索引)"
        B["B+树根节点<br/>(name索引)"]
        C["非叶子节点"]
        D["叶子节点<br/>name='Tom', id=18"]
    end

    subgraph "聚簇索引(主键索引)"
        E["B+树根节点<br/>(主键索引)"]
        F["非叶子节点"]
        G["叶子节点<br/>id=18, name='Tom', age=25, address='北京'"]
    end

    subgraph "回表过程"
        H["步骤1: 查找name索引"]
        I["步骤2: 获取主键id=18"]
        J["步骤3: 用主键查聚簇索引"]
        K["步骤4: 返回完整行数据"]
    end

    A --> B
    B --> C
    C --> D
    D --> H
    H --> I
    I --> J
    J --> E
    E --> F
    F --> G
    G --> K
    K --> L["返回: age=25"]

    style D fill:#ffb3ba
    style G fill:#bae1ff
    style H fill:#ffffba
    style I fill:#ffffba
    style J fill:#ffffba
    style K fill:#ffffba
</pre>

</li>
<li>
<p>为什么需要回表：使用非聚簇索引的二级索引查询时，只能查到索引列的值和其主键值，无法获取其他数据</p>
</li>
<li>
<p>回表的缺点：回表会带来随机I/O, 频繁回表会导致效率非常低。所以不推荐使用 <code>select *</code></p>
</li>
<li>
<p>回表的其他场景：当查询的部分列没有包含在索引中时，即便使用了索引，也需要会去获取缺失的列数据，称为覆盖索引缺失。</p>
</li>
<li>
<p>覆盖索引缺失发送场景：<code>select</code> 语句当中包含了非索引列; 索引的类型为 <code>Hash</code> 和 <code>full-text</code> 索引 （不存储列的值），不支持覆盖索引。</p>
</li>
<li>
<p>如何减少回表：开启索引下推、使用覆盖索引、延迟关联</p>
<ul>
<li>
<p>覆盖索引：只查询索引中包含的字段 （完全避免回表操作）</p>
</li>
<li>
<p>索引下推：在索引层将数据尽可能多的过滤掉，避免将数据查出来之后再过滤（减少回表的数据量）</p>
</li>
<li>
<p>延迟关联：手动先获取所有的二级索引的主键，然后一次性通过主键批量化获取数据 （减少回表次数）</p>
</li>
</ul>
<table>
  <thead>
      <tr>
          <th style="text-align: left">优化策略</th>
          <th style="text-align: left">适用场景</th>
          <th style="text-align: left">优点</th>
          <th style="text-align: left">缺点</th>
          <th style="text-align: left">实现难度</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">覆盖索引</td>
          <td style="text-align: left">查询字段固定且较少</td>
          <td style="text-align: left">完全避免回表，性能最佳</td>
          <td style="text-align: left">索引存储空间增大，维护成本高</td>
          <td style="text-align: left">简单</td>
      </tr>
      <tr>
          <td style="text-align: left">索引下推</td>
          <td style="text-align: left">复合条件查询</td>
          <td style="text-align: left">自动优化，减少回表数量</td>
          <td style="text-align: left">需要MySQL 5.6+支持</td>
          <td style="text-align: left">无需额外实现</td>
      </tr>
      <tr>
          <td style="text-align: left">延迟关联</td>
          <td style="text-align: left">大数据量分页查询</td>
          <td style="text-align: left">显著减少回表次数</td>
          <td style="text-align: left">查询逻辑复杂，需要两次查询</td>
          <td style="text-align: left">中等</td>
      </tr>
      <tr>
          <td style="text-align: left">选择合适字段</td>
          <td style="text-align: left">所有查询场景</td>
          <td style="text-align: left">减少不必要的数据传输</td>
          <td style="text-align: left">需要明确业务需求</td>
          <td style="text-align: left">简单</td>
      </tr>
  </tbody>
</table>
<pre class="mermaid">graph TD
    A["避免回表的策略"] --> B["覆盖索引"]
    A --> C["索引下推"]
    A --> D["延迟关联"]


    B --> B1["创建包含所需列的复合索引"]
    B --> B2["只查询索引中包含的字段"]
    B --> B3["完全避免回表"]

    C --> C1["MySQL 5.6+ 默认开启"]
    C --> C2["在索引层面过滤数据"]
    C --> C3["减少回表的数据量"]

    D --> D1["先通过索引获取主键"]
    D --> D2["再用主键批量获取数据"]
    D --> D3["减少回表次数"]

    style B fill:#e1f5fe
    style C fill:#f3e5f5
    style D fill:#e8f5e8
</pre>

</li>
</ol>
<h2 id="8-mysql索引的最左前缀匹配原则是什么">8. MySQL索引的最左前缀匹配原则是什么?<a hidden class="anchor" aria-hidden="true" href="#8-mysql索引的最左前缀匹配原则是什么">#</a></h2>
<p><img alt="MySQL索引最左前后缀匹配原则" loading="lazy" src="https://oss.swimmingliu.cn/74f6527e-ef5d-11ef-8fbf-c858c0c1deba"></p>
<ol>
<li>最左前缀匹配原则的定义：使用联合索引的时候，查询的条件必须从索引的最左侧开始匹配。如果联合索引包含多个列，查询条件必须包含第一个列，然后是第二个列，以此类推。</li>
<li>最左前缀匹配原则的原理：联合索引在B+树中的排列方式遵循从左到右的原则，例如联合索引(a, b, c)，在查询时，首先按照a的值进行排序，如果a的值相同，再查b的值，以此类推。</li>
<li>常见场景：<code>=</code> 、<code>&gt;=</code> 、<code>&lt;=</code> 、 <code>BETWEEN</code> 、<code>like (xx%)</code> 都包含等值的情况，可以定位到某个数，然后进行范围扫描，不会出现停止匹配的现象。但是 <code>&gt;</code> 和 <code>&lt;</code> 则不行。</li>
<li>部分不符合最左前缀匹配原则也能使用索引的原因：MySQL8当中引入了 Skip Can Range Access Method, 将缺失的左边的值查出来，如果左边缺失的列数据量少，则拼凑左边的索引，让SQL符合最左前缀匹配原则。</li>
</ol>
<h2 id="9-mysql的覆盖索引是什么">9. MySQL的覆盖索引是什么？<a hidden class="anchor" aria-hidden="true" href="#9-mysql的覆盖索引是什么">#</a></h2>
<ol>
<li>覆盖索引定义：查询的所有字段都是二级索引，从而使查询可以直接访问二级索引二不需要访问实习的表数据(主键索引)。</li>
<li>覆盖索引优点：减少I/O操作 ; 提高查询速度 (索引比表数据更加紧凑); 减少内存占用 (读取的索引页面而不是表数据页面)</li>
</ol>
<table>
  <thead>
      <tr>
          <th style="text-align: left">对比维度</th>
          <th style="text-align: left">覆盖索引</th>
          <th style="text-align: left">非覆盖索引</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">数据获取方式</td>
          <td style="text-align: left">直接从二级索引获取全部所需数据</td>
          <td style="text-align: left">需要通过主键回表到聚簇索引获取数据</td>
      </tr>
      <tr>
          <td style="text-align: left">I/O操作次数</td>
          <td style="text-align: left">1次(仅访问二级索引)</td>
          <td style="text-align: left">2次(访问二级索引+聚簇索引)</td>
      </tr>
      <tr>
          <td style="text-align: left">查询性能</td>
          <td style="text-align: left">高(减少磁盘I/O)</td>
          <td style="text-align: left">相对较低(额外的回表开销)</td>
      </tr>
      <tr>
          <td style="text-align: left">内存占用</td>
          <td style="text-align: left">低(索引页面更紧凑)</td>
          <td style="text-align: left">高(需要加载完整数据页)</td>
      </tr>
      <tr>
          <td style="text-align: left">适用场景</td>
          <td style="text-align: left">select字段都在索引中</td>
          <td style="text-align: left">select字段超出索引范围</td>
      </tr>
  </tbody>
</table>
<pre class="mermaid">graph LR
    A[客户端发起查询] --> B{分析查询语句}
    B --> C[解析索引使用情况]
    C --> D{是否为覆盖索引?}
    
    D -->|是| E[直接在二级索引中获取数据]
    E --> F[返回查询结果]
    
    D -->|否| G[在二级索引中查找主键ID]
    G --> H[使用主键ID回表查询]
    H --> I[在聚簇索引中查找完整行数据]
    I --> J[返回查询结果]
    
    F --> K[查询完成]
    J --> K
    
    style E fill:#90EE90
    style F fill:#90EE90
    style H fill:#FFB6C1
    style I fill:#FFB6C1
</pre>

<h2 id="10-mysql的索引下推-icp-是什么">10. MySQL的索引下推 (ICP) 是什么?<a hidden class="anchor" aria-hidden="true" href="#10-mysql的索引下推-icp-是什么">#</a></h2>
<ol>
<li>
<p>索引下推(ICP)定义: 减少回表查询，提高查询效率的行为。允许MySQL使用索引查找数据的时候，将部分查询条件下推到存储引擎层进行过滤，从而减少需要从表中读取的数据行，减少I/O。</p>
</li>
<li>
<p>应用场景：比如当前表建了一个联合索引(a, b, c)，使用<code>where</code>条件的时候，由于b用得是 <code>like '%xxx%'</code> 需要回表查询 (<code>like 'xx%'</code> 不需要)。即先查询 <code>a = '1' </code>的数据， 然后回表查询，最后进行<code>where</code>条件的过滤。如果使用索引下推之后 (MySQL 5.6)，在查完<code>a = '1'</code>的数据之后，可以先由存储引擎层进行<code>where</code>条件过滤，然后再回表查询， 减少回表查询的次数。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-SQL" data-lang="SQL"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">people</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">WHERE</span><span class="w"> </span><span class="n">a</span><span class="o">=</span><span class="s1">&#39;1&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">AND</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k">LIKE</span><span class="w"> </span><span class="s1">&#39;%123%&#39;</span><span class="w">
</span></span></span></code></pre></div><blockquote>
<p>如联合索引index_name_age，假设数据库中有数据（张三，18）、（张三，28）、（张三，48）、（张三，8)</p>
<p>【没有索引下推】查询name=&lsquo;张三&rsquo;和age&gt;30的数据时，会先匹配有四条数据name=&lsquo;张三&rsquo;匹配成功，回表四次查询出带有name=&lsquo;张三&rsquo;的四条数据，然后再根据age&gt;30对这四条数据进行范围查找</p>
<p>【使用索引下推】查询name=&lsquo;张三&rsquo;和age&gt;30的数据时，会先匹配有四条数据name=&lsquo;张三&rsquo;匹配成功，然后age&gt;30的数据，过滤完成后，再用主键索引去进行一次回表操作</p></blockquote>
</li>
</ol>
<pre class="mermaid">graph TB
    subgraph "无索引下推 (MySQL 5.6之前)"
        A1[存储引擎层] --> A2[根据索引条件查找记录]
        A2 --> A3[返回所有符合索引条件的主键]
        A3 --> A4[Server层]
        A4 --> A5[逐条回表获取完整记录]
        A5 --> A6[在Server层应用WHERE条件过滤]
        A6 --> A7[返回最终结果]
    end
    
    subgraph "有索引下推 (MySQL 5.6+)"
        B1[存储引擎层] --> B2[根据索引条件查找记录]
        B2 --> B3[在存储引擎层直接应用WHERE条件]
        B3 --> B4{记录是否满足<br/>下推条件?}
        B4 -->|是| B5[添加主键到结果集]
        B4 -->|否| B6[丢弃该记录]
        B6 --> B3
        B5 --> B7[返回过滤后的主键列表]
        B7 --> B8[Server层]
        B8 --> B9[回表获取完整记录]
        B9 --> B10[返回最终结果]
    end
    
    style B3 fill:#90EE90
    style B4 fill:#90EE90
    style A5 fill:#FFB6C1
    style A6 fill:#FFB6C1
</pre>

<h2 id="11-mysql建索引需要注意哪些事项">11. MySQL建索引需要注意哪些事项？<a hidden class="anchor" aria-hidden="true" href="#11-mysql建索引需要注意哪些事项">#</a></h2>
<p><strong>【索引适合场景】</strong></p>
<ol>
<li>频繁使用<code>where</code> 、<code>order by</code> 、<code>group by</code>、<code>distinct</code> 的字段 (加快操作速度)</li>
<li>关联字段 (如果没有索引，连接的过程中，每个只都会进行一次全表扫描)</li>
</ol>
<p><strong>【不适合场景】</strong></p>
<ol>
<li>字段频繁更新 (更新除了修改数据外，还需要维护索引信息 =&gt; 调整B+树会降低性能)</li>
<li>字段值重复率高（区分度低，建立索引更加消耗资源）</li>
<li>参与列计算的字段 (索引会失效)</li>
<li>长字段 (<code>text</code>、 <code>longtext</code>) ：长字段占据的内存大，提升性能不明显。</li>
</ol>
<p>【注】<strong>索引不是越多越好</strong>，因为每次修改都需要维护索引数据，消耗资源</p>
<h2 id="12-mysql中使用索引一定有效吗如何排查索引效果">12. MySQL中使用索引一定有效吗？如何排查索引效果？<a hidden class="anchor" aria-hidden="true" href="#12-mysql中使用索引一定有效吗如何排查索引效果">#</a></h2>
<p>【索引失效的情况】</p>
<ul>
<li>联合索引不符合最左匹配原则</li>
<li>对索引列使用了运算(<code>where id + 3 = 8</code>)、函数 (<code>lower()</code>、<code>count()</code>)、<code>like '%xx%' </code> 等操作</li>
<li>对索引列和非索引列使用 <code>or</code> 操作 (<code>where name = &quot;swimmingliu&quot; or age = 34</code>)</li>
<li>索引列类型不匹配导致的强制转换 (<code>where name = 1</code> ==&gt; <code>where CAST(name AS signed int) = 1</code>)</li>
</ul>
<pre class="mermaid">graph TD
    A[MySQL索引失效场景] --> B[查询条件问题]
    A --> C[索引结构问题]
    A --> D[数据类型问题]
    A --> E[优化器选择问题]
    
    B --> B1[最左前缀原则违反]
    B --> B2[函数和运算操作]
    B --> B3[通配符问题]
    B --> B4[范围查询问题]
    B --> B5[OR操作符问题]
    
    C --> C2[索引覆盖失效]
    
    D --> D1[数据类型不匹配]
    D --> D2[隐式类型转换]
    
    E --> E1[数据分布不均匀]
    E --> E2[表数据量过小]
    E --> E3[查询成本评估]
</pre>

<p>【如何查看失效】</p>
<p>利用<code>explain</code>命令 (前面最好加上<code>analyse table xxx</code>)</p>
<p><code>EXPLAIN</code> 的 <code>type</code> 表示查询的访问类型，影响查询的效率。常见的值：</p>
<ol>
<li><strong>ref</strong>: 使用索引，查找匹配某个单一列的值（比如通过外键查找）。比 <code>range</code> 更高效。</li>
<li><strong>range</strong>: 使用索引扫描某个范围内的值，适用于 <code>BETWEEN</code>、<code>&gt; &lt;</code> 等条件。</li>
<li><strong>index</strong>: 全索引扫描，扫描整个索引结构，不读表数据，通常效率比全表扫描好。</li>
<li><strong>all</strong>: 全表扫描，没有使用索引</li>
</ol>
<p>总结：<code>ref</code> &gt; <code>range</code> &gt; <code>index</code> &gt; <code>all</code>。</p>
<h2 id="13-mysql的索引数是否越多越好why">13. MySQL的索引数是否越多越好？why?<a hidden class="anchor" aria-hidden="true" href="#13-mysql的索引数是否越多越好why">#</a></h2>
<p>索引不是越多越好，因为对索引字段进行更新操作，需要调整B+树的结构，会导致数据库增加开销。</p>
<p>【注】阿里巴巴规范上表示索引一般不超过16个</p>
<p>**【时间开销】**进行增删改操作的时候，索引也必须更新。索引越多，需要修改的地方就越多，时间开销大。B+树可能会出现页分裂、合并等操作，时间开销更大。</p>
<p><strong>【空间开销】</strong> 建立二级索引，都需要新建一个B+树，每个数据页面都是16KB。如果数据大，索引又多，占用的空间不小。</p>
<h2 id="14-为什么-mysql-选择使用-b-树作为索引结构">14. 为什么 MySQL 选择使用 B+ 树作为索引结构？<a hidden class="anchor" aria-hidden="true" href="#14-为什么-mysql-选择使用-b-树作为索引结构">#</a></h2>
<p><strong>【B+树结构】</strong></p>
<pre class="mermaid">graph TD
    subgraph "B+树整体结构"
        Root["根节点<br/>索引页<br/>[20, 50, 80]"]
        
        subgraph "第二层-非叶子节点"
            Node1["非叶子节点1<br/>[5, 10, 15]"]
            Node2["非叶子节点2<br/>[25, 35, 45]"]
            Node3["非叶子节点3<br/>[55, 65, 75]"]
            Node4["非叶子节点4<br/>[85, 90, 95]"]
        end
        
        subgraph "第三层-叶子节点(数据页)"
            Leaf1["叶子节点1<br/>key: 1,3,5<br/>data: 行记录1,3,5"]
            Leaf2["叶子节点2<br/>key: 8,10,12<br/>data: 行记录8,10,12"]
            Leaf3["叶子节点3<br/>key: 15,18,20<br/>data: 行记录15,18,20"]
            Leaf4["叶子节点4<br/>key: 22,25,28<br/>data: 行记录22,25,28"]
            Leaf5["叶子节点5<br/>key: 32,35,38<br/>data: 行记录32,35,38"]
            Leaf6["叶子节点6<br/>key: 42,45,48<br/>data: 行记录42,45,48"]
            Leaf7["叶子节点7<br/>key: 52,55,58<br/>data: 行记录52,55,58"]
            Leaf8["叶子节点8<br/>key: 62,65,68<br/>data: 行记录62,65,68"]
            Leaf9["叶子节点9<br/>key: 72,75,78<br/>data: 行记录72,75,78"]
            Leaf10["叶子节点10<br/>key: 82,85,88<br/>data: 行记录82,85,88"]
            Leaf11["叶子节点11<br/>key: 90,92,95<br/>data: 行记录90,92,95"]
            Leaf12["叶子节点12<br/>key: 97,98,99<br/>data: 行记录97,98,99"]
        end
        
        Root --> Node1
        Root --> Node2
        Root --> Node3
        Root --> Node4
        
        Node1 --> Leaf1
        Node1 --> Leaf2
        Node1 --> Leaf3
        Node2 --> Leaf4
        Node2 --> Leaf5
        Node2 --> Leaf6
        Node3 --> Leaf7
        Node3 --> Leaf8
        Node3 --> Leaf9
        Node4 --> Leaf10
        Node4 --> Leaf11
        Node4 --> Leaf12
        
        Leaf1 -.-> Leaf2
        Leaf2 -.-> Leaf3
        Leaf3 -.-> Leaf4
        Leaf4 -.-> Leaf5
        Leaf5 -.-> Leaf6
        Leaf6 -.-> Leaf7
        Leaf7 -.-> Leaf8
        Leaf8 -.-> Leaf9
        Leaf9 -.-> Leaf10
        Leaf10 -.-> Leaf11
        Leaf11 -.-> Leaf12
    end
</pre>

<p><strong>【B+树的优势】</strong></p>
<ul>
<li><strong>高效的查找性能</strong>：B+树是一种自平衡树，每个叶子结点到根节点的路径长度相同。增删改查的事件复杂度都是O(logn)，且具有一定的冗余节点，删除节点的时候，树的结构变化较小。</li>
<li><strong>I/O次数相对较少</strong>：首先，B+树不会像红黑树一样，随着数据的增多树变得越来越高，它是多叉树。计算机访问数据时，往往具有局部性原理。当读取一个节点时，B树和B+树会将多个相关的数据加载到内存中，后续直接从内存反问，减少了磁盘的I/O。另外，相较于B树来说， B+树所有的数据都存放在叶子节点，而不像B树会在非叶子节点存储数据。B+树的非叶子节点仅存储索引值/主键和页面指针。</li>
<li><strong>对范围查询友好</strong>：B+树的叶子节点之间通过链表链接。当使用<code>between</code>语句时，会从根节点找到满足条件的起始记录。然后从起始记录，沿着叶子结点的链表进行顺序遍历。</li>
</ul>
<p>【<strong>B+树存在的部分缺点</strong>】</p>
<p>当插入和删除节点，会触发分裂和合并操作，保持树的平衡，有一定的开销。</p>
<p>【<strong>跳表</strong>】</p>
<p>跳表其实就是一个多级链表，为了让链表更高效的查询。在不同的部分插入高级索引，让其能够缩小查找范围。有一种二分的思想在里面。其中，Redis的有序集合(sorted set)底层的结构就是跳表结构。</p>
<p><img alt="img" loading="lazy" src="https://oss.swimmingliu.cn/7538abf4-ef5d-11ef-8932-c858c0c1deba"></p>
<p><strong>【为什么MySQL不用跳表而用B+树】</strong></p>
<ul>
<li><strong>跳表的I/O效率低</strong>：B+树通常只有3~4层，可以存储海量的数据。B+树的节点大小设计适配磁盘页的大小，磁盘页能够顺序存储大量数据。一次磁盘I/O操作就能读取节点的数据，减少I/O。跳表是多级索引的结构，虽然可以加速查找，但是其查找的过程当中会涉及到多次随机的I/O。</li>
<li><strong>范围查询</strong>： B+树的叶子节点是有序链表，在采用<code>between</code>时，能够找从叶子结点按照链表顺序遍历即可。跳表虽然支持范围查询，但是实现起来很复杂， 而且其多层的索引结构，范围查询时不能像B+树那样直接高效。</li>
<li><strong>跳表维护成本高</strong>：B+树在增删改的时候，有高效的算法平衡树结构，确保性能稳定。而跳表在新增和删除操作的时候，涉及多层链表的调整，开销较大，容易出现性能波动。</li>
<li><strong>跳表内存占用大</strong>：B+树的节点紧凑，非叶子节点只存储索引项和页面指针。而跳表除了每个节点存储数据以外，还需要额外的开销存储多层索引。相同数据量下，跳表的开销比B+树大得多。</li>
</ul>
<p><strong>【B+树索引的SQL执行过程】</strong></p>
<pre class="mermaid">sequenceDiagram
    participant Client as SQL客户端
    participant Parser as SQL解析器
    participant Optimizer as 查询优化器
    participant Engine as 存储引擎
    participant Buffer as 缓冲池
    participant Disk as 磁盘

    Client->>Parser: SELECT * FROM users WHERE id = 45
    Parser->>Optimizer: 解析后的查询树
    Optimizer->>Engine: 选择索引访问路径
    
    Note over Engine: 开始B+树索引查找
    
    Engine->>Buffer: 检查根节点页面是否在内存
    alt 根节点不在内存
        Buffer->>Disk: 读取根节点页面
        Disk-->>Buffer: 返回根节点数据
    end
    Buffer-->>Engine: 根节点: [20, 50, 80]
    
    Note over Engine: 45 >= 20 && 45 < 50, 选择第二个指针
    
    Engine->>Buffer: 检查中间节点页面是否在内存
    alt 中间节点不在内存
        Buffer->>Disk: 读取中间节点页面
        Disk-->>Buffer: 返回中间节点数据
    end
    Buffer-->>Engine: 中间节点: [25, 35, 45]
    
    Note over Engine: 45 >= 45, 选择第三个指针
    
    Engine->>Buffer: 检查叶子节点页面是否在内存
    alt 叶子节点不在内存
        Buffer->>Disk: 读取叶子节点页面
        Disk-->>Buffer: 返回叶子节点数据
    end
    Buffer-->>Engine: 叶子节点: [42, 45, 48] + 对应行数据
    
    Note over Engine: 在叶子节点中找到key=45对应的完整行记录
    
    Engine-->>Optimizer: 返回查询结果
    Optimizer-->>Parser: 格式化结果
    Parser-->>Client: 返回查询结果集
</pre>

<h2 id="15-mysql-三层-b-树能存多少数据">15. MySQL 三层 B+ 树能存多少数据？<a hidden class="anchor" aria-hidden="true" href="#15-mysql-三层-b-树能存多少数据">#</a></h2>
<table>
  <thead>
      <tr>
          <th>算法名称</th>
          <th>数据页大小</th>
          <th>叶子节点存储的数据记录大小 (假设)</th>
          <th>节点的索引值(主键大小)</th>
          <th>节点的页面指针大小</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>B+树</td>
          <td>16KB</td>
          <td>1KB</td>
          <td>8B （<code>bigint</code>）</td>
          <td>6B</td>
      </tr>
  </tbody>
</table>
<p>【三层B+树存储数据计算】</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nv">nodesCount</span> <span class="o">=</span> <span class="m">16</span> * <span class="m">1024</span> / <span class="o">(</span><span class="m">6</span> + 8<span class="o">)</span> <span class="o">=</span> <span class="m">1170</span> // 每个节点可以存多少个子节点
</span></span><span class="line"><span class="cl"><span class="nv">recordCount</span> <span class="o">=</span> 16KB / <span class="nv">1KB</span> <span class="o">=</span> <span class="m">16</span> // 每个节点可以存多少条数据记录
</span></span><span class="line"><span class="cl"><span class="nv">dataCount</span> <span class="o">=</span> nodesCount * nodesCount * <span class="nv">recordCount</span> <span class="o">=</span> <span class="m">1170</span> * <span class="m">1170</span> * <span class="nv">16</span> <span class="o">=</span> 21,902,400 
</span></span><span class="line"><span class="cl">所以如果一条数据为1KB大小，B+树大约能存2000w条数据
</span></span></code></pre></div><p>【拓展】</p>
<p>MySQL的InnoDB引擎中，B+树m每个节点的数据页大小可以通过调整<code>innodb_page_size</code>来修改 (一般为 4KB / 8KB / 16KB)</p>
<h2 id="16-mysql如何进行sql调优">16. MySQL如何进行SQL调优<a hidden class="anchor" aria-hidden="true" href="#16-mysql如何进行sql调优">#</a></h2>
<p>分为预防和解决慢查询两个角度阐述。总结起来就三点，命中索引、减少回表、减少I/O.</p>
<p><strong>【预防】</strong></p>
<ul>
<li>合理设计索引，减少回表次数，减少I/O</li>
<li>避免 <code>select *</code> 操作。因为正常情况下，部分字段是没有二次索引的，它会用主键id或者<code>rowid</code> 进行回表查询，会增加系统的I/O。</li>
<li>避免让索引失效，比如对索引字段进行计算、聚合函数、非同类型比较 (强制转换)和范围查询 (<code>&gt;</code>、<code>&lt;</code>、<code>like %xxx%</code>)。还有联合索引不匹配最左前缀原则</li>
<li>避免对非索引字段，使用<code>group by</code>、<code>order by</code>、<code>dinstinct</code>等函数</li>
<li>连表查询的是否需要保持不同字段的字符集一致，不然也会导致全表扫描。比如A表用<code>utf-8</code>，B表用<code>latin1</code>，查询的是否需要进行字符集转换，需要额外的计算，不能使用索引。</li>
</ul>
<p><strong>【解决慢查询】</strong></p>
<ul>
<li>开启慢SQL日志记录功能，使用<code>set global slow_query_log = &quot;ON&quot;</code>， 默认是关闭的。设置一个查询延迟的阈值，把超过规定时间的SQL查询找出来。</li>
<li>利用<code>explain</code>关键字分析慢SQL的原因，比如看看是否有索引失效、<code>select *</code>等情况</li>
</ul>
<pre class="mermaid">graph LR
    subgraph "MySQL性能调优方法体系"
        A["SQL层面优化"] --> A1["索引优化"]
        A --> A2["SQL语句优化"]
        A --> A3["表结构优化"]
        
        A1 --> A11["创建合适索引"]
        A1 --> A12["避免索引失效"]
        A1 --> A13["覆盖索引"]
        A1 --> A14["索引下推ICP"]
        
        A2 --> A21["避免SELECT *"]
        A2 --> A22["优化JOIN查询"]
        A2 --> A23["合理使用分页"]
        A2 --> A24["批量操作"]
        
        A3 --> A31["字段类型选择"]
        A3 --> A32["范式反范式权衡"]
        A3 --> A33["垂直分表"]
        
        B["架构层面优化"] --> B1["读写分离"]
        B --> B2["分库分表"]
        B --> B3["缓存机制"]
        B --> B4["数据冷热分离"]
        
        B1 --> B11["主从复制"]
        B1 --> B12["负载均衡"]
        B2 --> B21["水平分片"]
        B2 --> B22["垂直分片"]
        B3 --> B31["Redis缓存"]
        B3 --> B32["查询缓存"]
        
        C["系统层面优化"] --> C1["硬件配置"]
        C --> C2["参数调优"]
        C --> C3["连接池配置"]
        
        C1 --> C11["SSD硬盘"]
        C1 --> C12["增加内存"]
        C2 --> C21["innodb_buffer_pool_size"]
        C2 --> C22["max_connections"]
        C3 --> C31["连接池大小"]
        C3 --> C32["超时设置"]
        
        D["监控诊断"] --> D1["慢查询日志"]
        D --> D2["EXPLAIN分析"]
        D --> D3["Performance Schema"]
        D --> D4["监控工具"]
    end
</pre>

<h2 id="补充-161-mysql中的慢sql如何排查-完整排查链路">[补充] 16.1 MySQL中的慢SQL如何排查 （完整排查链路）<a hidden class="anchor" aria-hidden="true" href="#补充-161-mysql中的慢sql如何排查-完整排查链路">#</a></h2>
<p><strong>【慢SQL完成排查流程】</strong></p>
<pre class="mermaid">flowchart LR
    A["发现慢SQL"] --> B{"慢SQL来源"}
    
    B --> B1["慢查询日志"]
    B --> B2["监控告警"]
    B --> B3["应用响应慢"]
    
    B1 --> C["开启慢查询日志<br>long_query_time=1"]
    B2 --> C
    B3 --> C
    
    C --> D["定位具体SQL语句"]
    D --> E["使用EXPLAIN分析执行计划"]
    
    E --> F{"执行计划分析"}
    F --> F1["type: ALL/index<br>(全表扫描)"]
    F --> F2["key: NULL<br>(未使用索引)"]
    F --> F3["rows: 很大<br>(扫描行数多)"]
    F --> F4["Extra: Using filesort<br>Using temporary"]
    
    F1 --> G["索引优化"]
    F2 --> G
    F3 --> G
    F4 --> G
    
    G --> H{"优化策略选择"}
    
    H --> H1["创建索引"]
    H --> H2["SQL重写"]
    H --> H3["表结构调整"]
    H --> H4["分库分表"]
    
    H1 --> I1["单列索引<br>复合索引<br>覆盖索引"]
    H2 --> I2["JOIN优化<br>子查询优化<br>分页优化"]
    H3 --> I3["字段类型优化<br>冗余字段<br>垂直分表"]
    H4 --> I4["水平分片<br>垂直分片<br>读写分离"]
    
    I1 --> J["执行优化方案"]
    I2 --> J
    I3 --> J
    I4 --> J
    
    J --> K["再次EXPLAIN验证"]
    K --> L{"性能是否满足要求"}
    
    L --> L1["是"] 
    L --> L2["否"]
    
    L1 --> M["持续监控"]
    L2 --> N["继续深度优化"]
    
    N --> N1["查看Profile"]
    N --> N2["分析锁等待"]
    N --> N3["优化参数配置"]
    
    N1 --> H
    N2 --> H  
    N3 --> H
    
    M --> O["优化完成"]
</pre>

<h2 id="17-如何使用mysql的explain语句进行查询分析">17. 如何使用MySQL的EXPLAIN语句进行查询分析?<a hidden class="anchor" aria-hidden="true" href="#17-如何使用mysql的explain语句进行查询分析">#</a></h2>
<p><strong>【EXPLAIN查询结果解释】</strong></p>
<table>
  <thead>
      <tr>
          <th>名称</th>
          <th>id</th>
          <th>select_type</th>
          <th>type</th>
          <th>key</th>
          <th>rows</th>
          <th>Extra</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>中文名称</td>
          <td>查询的执行顺序</td>
          <td>查询的类型</td>
          <td>访问类型</td>
          <td>关键索引</td>
          <td>扫描行数</td>
          <td>额外信息</td>
      </tr>
      <tr>
          <td>说明</td>
          <td>值越大优先级越高</td>
          <td><code>SIMPLE</code>简单查询、<code>PRIMARY</code>主查询、<code>SUBQUERY</code> 子查询</td>
          <td>const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</td>
          <td>实际用到的索引</td>
          <td>值越小越好</td>
          <td><code>Using index</code> 表示覆盖索引、<code>Using where</code> 表示where条件过滤、<code>Using temporary</code> 表示临时表、<code>Using filesort</code> 表示需要额外的排序步骤</td>
      </tr>
  </tbody>
</table>
<p><strong>【type说明】</strong></p>
<ul>
<li>
<p>system: 表明查询的表只有一行 (系统表)</p>
</li>
<li>
<p>const : 表明查询的表最多只有一行匹配结果。通常是查询条件为主键或唯一索引， 并且是常量比较。</p>
</li>
<li>
<p>eq_ref: 表明对于每个来自钱一张表的行，MySQL只访问一次该表，通常发生在链接查询中使用主键或唯一索引的情况下。</p>
</li>
<li>
<p>ref：MySQL 使用非唯一索引查询。查询的条件是非唯一的</p>
</li>
<li>
<p>range: MySQL 会扫描表的一部分，不是全部行。通常出现在索引的范围查询中 (比如<code>&gt;=</code>、<code>&lt;=</code>、<code>BETWEEN</code>)</p>
</li>
<li>
<p>index: 表示MySQL扫描索引中的所有行，但不是扫描表的所有行。</p>
</li>
<li>
<p>all：表示需要扫描表的所有行，全表扫描。一般出现在没有索引的查询条件中。</p>
</li>
</ul>
<h2 id="18--请详细描述-mysql-的-b-树中查询数据的全过程">18.  请详细描述 MySQL 的 B+ 树中查询数据的全过程<a hidden class="anchor" aria-hidden="true" href="#18--请详细描述-mysql-的-b-树中查询数据的全过程">#</a></h2>
<p><strong>【B+树查询过程】</strong></p>
<p>可以类比成去电影院 (<code>4号厅</code> ) 找位置  的过程</p>
<ol>
<li>买票进门，从根节点(<code>Page 20</code>)出发，主键值为<code>4</code>, 范围在<code>[1,5)</code>中间，需要到 <code>Page 2</code> 非叶子节点查询</li>
<li>进入 <code>Page 2</code> 非叶子节点，主键值大于<code>3</code>，需要到<code>Page 5</code> 的叶子节点查询</li>
<li>进入<code>Page 5</code> 的叶子节点，通过<code>Page Directory</code> 内的槽查找记录，使用二分法快速定位查询记录在那个槽。</li>
<li>定位到槽之后遍历所有的记录，找到主键为 <code>4</code> 的记录</li>
</ol>
<p><img alt="MySQL的B+树查询过程" loading="lazy" src="https://oss.swimmingliu.cn/757c7186-f4b5-11ef-85e9-c858c0c1deba"></p>
<p><strong>【Page Directory 页目录查找过程】</strong></p>
<p>假如页目录当中有5个槽，现在需要查找主键值为<code>3</code>的记录。查找过程如下：</p>
<ol>
<li>二分查找定位到槽2</li>
<li>槽2的最大记录是4，记录二分查找定位到槽1</li>
<li>槽1的最大记录是2，因为<code>3 &gt; 2</code>， 直接向前遍历查询到主键值为 <code>3</code> 的记录</li>
</ol>
<p><img alt="MySQL的B+树的PageDirectory槽查找过程" loading="lazy" src="https://oss.swimmingliu.cn/765b3dfb-f4b5-11ef-bafa-c858c0c1deba"></p>
<p><strong>【B+树数据页的结构】</strong></p>
<p><code>InnoDB</code> 当中B+树的每个节点以数据页(Page)为单位存储，每页默认大小为16KB。</p>
<ul>
<li><strong>文件头</strong>： 记录叶子节点的上下页 (因为叶子节点是双向链表连接起来的)</li>
<li><strong>最大和最小记录</strong>：表示页面当中最小的记录和最大的记录 （虚拟的记录） 在真实行记录的两侧</li>
<li><strong>页目录</strong>: 数据页被分为若干个组，每个组对应一个槽 (Slot)。页目录内记录这些槽的位置，实现基于当前数据也的二分查找的快速定位。</li>
</ul>
<p><img alt="B+树数据页结构" loading="lazy" src="https://oss.swimmingliu.cn/76b69e7c-f4b5-11ef-9cea-c858c0c1deba"></p>
<p><strong>【B+树的优势】</strong></p>
<p>参见问题<a href="https://swimmingliu.cn/posts/job/mysql-interview-questions/#14-%e4%b8%ba%e4%bb%80%e4%b9%88-mysql-%e9%80%89%e6%8b%a9%e4%bd%bf%e7%94%a8-b-%e6%a0%91%e4%bd%9c%e4%b8%ba%e7%b4%a2%e5%bc%95%e7%bb%93%e6%9e%84">14. 为什么 MySQL 选择使用 B+ 树作为索引结构？</a></p>
<h2 id="19-mysql-中-countcount1-和-count字段名-有什么区别">19. MySQL 中 count(*)、count(1) 和 count(字段名) 有什么区别？<a hidden class="anchor" aria-hidden="true" href="#19-mysql-中-countcount1-和-count字段名-有什么区别">#</a></h2>
<p><strong>【效率层面】</strong> <code>count(*) ≈ count(1) &gt; count(唯一索引) &gt; count(主键) &gt; count(其他字段)</code></p>
<p><strong>【具体区别】</strong></p>
<table>
  <thead>
      <tr>
          <th>类型</th>
          <th>统计内容</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>count(*)</code></td>
          <td>表中所有记录，包括<code>NULL</code>值</td>
          <td>直接统计表的记录数，不依赖字段内容。MySQL特定优化，开销最低</td>
      </tr>
      <tr>
          <td><code>count(1)</code></td>
          <td>表中所有记录，包括<code>NULL</code>值</td>
          <td>参数<code>1</code>被视为常量，不依赖字段内容。未优化，性能略低于<code>count(*)</code></td>
      </tr>
      <tr>
          <td><code>count(唯一索引)</code></td>
          <td>唯一索引字段中的所有非 <code>NULL</code> 的记录</td>
          <td>遍历非聚簇索引统计字段行数，因为没有<code>NULL</code> 值，所以结果和<code>count(*)</code>差不多</td>
      </tr>
      <tr>
          <td><code>count(主键)</code></td>
          <td>主键字段中的所有非 <code>NULL</code> 的记录</td>
          <td>遍历聚簇索引统计主键字段行数，因为没有<code>NULL</code> 值，所以结果和<code>count(*)</code>差不多。但是，有回表操作，会产生额外的I/O。</td>
      </tr>
      <tr>
          <td><code> count(其他字段)</code></td>
          <td>其他字段中的所有非 <code>NULL</code> 的记录</td>
          <td>读取字段值，判断是否未<code>NULL</code>。如果记录较大，性能较差。</td>
      </tr>
  </tbody>
</table>
<h2 id="20-mysql-中-varchar-和-char-有什么区别">20. MySQL 中 varchar 和 char 有什么区别？<a hidden class="anchor" aria-hidden="true" href="#20-mysql-中-varchar-和-char-有什么区别">#</a></h2>
<p><strong>【主要区别】</strong></p>
<table>
  <thead>
      <tr>
          <th>特点</th>
          <th><code>char</code></th>
          <th><code>varchar</code></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>长度</strong></td>
          <td>固定长度，不足的用空格补齐 (<code>InnoDB</code>会自动忽略补齐的空格)</td>
          <td>非固定长度</td>
      </tr>
      <tr>
          <td><strong>存储空间</strong></td>
          <td>始终占用固定长度空间</td>
          <td>随着长度的变化而变化，还有<code>1~2</code>字节的额外空间，用于说明长度信息</td>
      </tr>
      <tr>
          <td><strong>性能影响</strong></td>
          <td>如果长度忽大忽小，可能浪费</td>
          <td>比较节省空间</td>
      </tr>
      <tr>
          <td><strong>使用场景</strong></td>
          <td>存储长度固定且较短的字符串</td>
          <td>存储变化或稍微较长的字符串</td>
      </tr>
  </tbody>
</table>
<p><strong>【注意事项】</strong></p>
<ol>
<li><code>varchar</code> 长度不要太大：因为MySQL在利用<code>order by</code>排序的过程当中，会用到 <code>sort_buff</code>。如果<code>varchar</code>所设定的长度过大，就会使用<strong>双路排序</strong>。而双路排序在对排序字段排序之后，只能拿到主键值和索引列的值。需要使用主键值再进行回表查询操作，会增加系统的I/O，降低系统性能。</li>
<li><code>varchar(n)</code> 当中的<code>n</code> 表示的是字符数，而不是字节数。通常最大行长度是 <code>65535</code> 字节，如果允许未<code>null</code>， 需要额外一个字节标注是否未<code>null</code>。 而<code>varchar</code> 需要<code>1~2</code>个字节来标注字段的长度。所以，支持的最大长度为<code>65535-2 = 65533</code> 字节。一般情况下，<code>UTF-8</code>字符集占用<code>3个字节</code>。所以，最大字符数<code>n</code> 为 <code>65533 / 3 = 21844</code> 个字符</li>
</ol>
<h2 id="21-mysql-是如何实现事务的">21. MySQL 是如何实现事务的？<a hidden class="anchor" aria-hidden="true" href="#21-mysql-是如何实现事务的">#</a></h2>
<p><strong>【事务四个特性 - AIDC】</strong></p>
<ul>
<li><strong>原子性</strong>：事务要么全部执行成功，要么全部执行失败</li>
<li><strong>隔离性</strong>：并发的事务之间相互是不干扰的，可见性由隔离级别进行控制。MySQL的默认隔离级别是RR，可重复读</li>
<li><strong>持久性</strong>：事务一旦提交，确保修改的数据会被永久保存</li>
<li><strong>一致性</strong>：事务执行前后，数据库要保持一直的状态，所有的业务规则、约束和触发器的规则必须满足。</li>
</ul>
<p>【<strong>如何实现事务</strong>】</p>
<p>实现事务其实就是要确保满足事务的四个特性，如何满足呢？</p>
<ul>
<li>
<p><strong>原子性</strong>：通过<code>Uodo Log</code> 实现，从事务开始的时候，<code>Undo Log</code> 里面会存储事务的反向操作。就是保存数据的历史版本把，用于事务的回滚，让事务执行失败之后可以恢复到之前的样子。</p>
</li>
<li>
<p><strong>隔离性</strong>: 通过锁和<code>MVCC</code> 多版本并发控制来实现的，主要是控制不同隔离级别下事务间的方法，确保事务之间不相互干扰。</p>
</li>
<li>
<p><strong>持久性</strong>：通过<code>Redo Log</code>来实现的，<code>Redo Log</code>会记录事务对数据库的所有修改操作。当MySQL发送宕机或崩溃的时候，可以根据<code>Redo Log</code> 里面的记录来恢复数据。满足事务的持久性。</p>
</li>
<li>
<p><strong>一致性</strong>： 其实事务的一致性就是AID实现的，也就是说事务是通过原子性、隔离性、持久性来满足一致性的。</p>
</li>
</ul>
<h2 id="22-mysql有哪些锁的类型">22. MySQL有哪些锁的类型?<a hidden class="anchor" aria-hidden="true" href="#22-mysql有哪些锁的类型">#</a></h2>
<p><strong>【按粒度分类】</strong></p>
<ol>
<li><strong>全局锁</strong>: 对整个数据库进行加锁，处于只读的状态，一般用于数据库逻辑备份。这个时候所有的数据操作(增删改)和表结构操作(<code>ALTER</code> 和 <code>DROP</code>)都会被阻塞。</li>
<li><strong>表级锁</strong>: 锁的是整张表。实现比较简单，资源消耗低。</li>
<li><strong>行级锁</strong>：锁的是某一行。粒度最小，支持高并发。但是加锁的开销大，可能导致死锁。</li>
</ol>
<p><strong>【按功能分类】</strong></p>
<ol>
<li><strong>共享锁 (<code>S</code> 锁, share Lock)</strong>: 读锁，顾名思义是共享的，所以可以共享锁之间可以兼容，一般用于事务读取数据的时候</li>
<li><strong>排他锁 (<code>X</code> 锁, exclusive lock)</strong>：写锁，顾名思义是拒绝别人的，所以不允许多个事务同时获取，排他锁之间不兼容。一般用于事务修改记录的时候。</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 添加共享锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="k">LOCK</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="k">SHARE</span><span class="w"> </span><span class="k">MODE</span><span class="p">;</span><span class="w">	
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- 共享锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="k">FOR</span><span class="w"> </span><span class="k">SHARE</span><span class="w"> 		</span><span class="o">#</span><span class="w"> </span><span class="n">MySQL</span><span class="w"> </span><span class="mi">8</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="err">版本</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- 排他锁
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="p">....</span><span class="w"> </span><span class="k">FOR</span><span class="w"> </span><span class="k">UPDATE</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p><strong>【全局锁】</strong></p>
<p>直接锁住整个数据库，处于只读模式。业务只能读取数据，不能更新数据。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="n">FLUSH</span><span class="w"> </span><span class="n">TABLES</span><span class="w"> </span><span class="k">WITH</span><span class="w"> </span><span class="k">READ</span><span class="w"> </span><span class="k">LOCK</span><span class="w">
</span></span></span></code></pre></div><p><strong>【表级锁】</strong></p>
<ol>
<li>
<p><strong>表锁</strong></p>
<ul>
<li>表级共享锁：阻止其他会话对表的<strong>写操作</strong>，当前会话只能读该表，不能访问其他表</li>
<li>表级排他锁：阻止其他会话对标进行任何操作（读和写），当前会话只能读该表，不能访问其他表</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="o">#</span><span class="w"> </span><span class="err">添加表级共享锁</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">lock</span><span class="w"> </span><span class="n">tables</span><span class="w"> </span><span class="k">user</span><span class="w"> </span><span class="k">read</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="o">#</span><span class="w"> </span><span class="err">添加表级别排它锁</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">lock</span><span class="w"> </span><span class="n">tables</span><span class="w"> </span><span class="k">user</span><span class="w"> </span><span class="k">write</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p><strong>元数据锁</strong>：事务执行<code>SELECT</code> 的时候，其他线程的DDL操作(<code>ALTER</code>、<code>DROP</code>)操作会被阻塞，直到事务提交</p>
</li>
<li>
<p><strong>意向锁</strong></p>
<ul>
<li>意向共享锁 (<code>IS</code>)：表明有意向对该表某些记录添加共享锁 (<code>S</code> 锁)</li>
<li>意向排他锁 (<code>IX</code>)：表明有意向对该表某些记录添加排他锁 (<code>X</code> 锁)</li>
</ul>
<p>意向锁之间相互兼容，不会和行级别的共享锁和排他锁发生冲突。但是，意向排他锁和共享锁、排他锁之间是冲突的。</p>
<table>
  <thead>
      <tr>
          <th>锁名称</th>
          <th>S</th>
          <th>X</th>
          <th>IS</th>
          <th>IX</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>S</strong></td>
          <td>✅</td>
          <td>❌</td>
          <td>✅</td>
          <td>❌</td>
      </tr>
      <tr>
          <td><strong>X</strong></td>
          <td>❌</td>
          <td>❌</td>
          <td>❌</td>
          <td>❌</td>
      </tr>
      <tr>
          <td><strong>IS</strong></td>
          <td>✅</td>
          <td>❌</td>
          <td>✅</td>
          <td>✅</td>
      </tr>
      <tr>
          <td><strong>IX</strong></td>
          <td>❌</td>
          <td>❌</td>
          <td>✅</td>
          <td>✅</td>
      </tr>
  </tbody>
</table>
</li>
<li>
<p><strong>自增锁</strong></p>
<p>用于主键自增的一种锁。事务向有自增列的表插入数据是会先获取自增锁，拿不到锁就被阻塞。但是可以通过修改<code>innodb_autoinc_lock_mode</code>自增锁模式进行调整，自增锁的具体实现方式：</p>
<table>
  <thead>
      <tr>
          <th>自增锁模式</th>
          <th>介绍</th>
          <th>说明</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>0</strong></td>
          <td>传统模式</td>
          <td>采用<code>AUTO-INC</code> 锁，语句执行结束释放</td>
      </tr>
      <tr>
          <td><strong>1</strong></td>
          <td>连续模式</td>
          <td>对普通<code>insert</code>，自增锁申请后马上释放。对于批量插入，等语句执行结束之后释放</td>
      </tr>
      <tr>
          <td><strong>2</strong></td>
          <td>交错模式</td>
          <td>申请自增主键后马上释放，无需等待语句执行完</td>
      </tr>
  </tbody>
</table>
</li>
</ol>
<p><strong>【行级锁】</strong></p>
<ol>
<li>
<p><strong>记录锁</strong></p>
<ul>
<li>事务对某条记录加<code>S</code>锁，其他记录也可以加，但是不能加<code>X</code>锁</li>
<li>事务对某条记录加<code>X</code>锁，其他事务既不能加<code>S</code>锁也不能加<code>X</code>锁</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="n">BEGINE</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="o">#</span><span class="w"> </span><span class="err">针对主键</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="err">为</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="err">的这条记录添加</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="err">型的记录锁；其他事务就无法对这条记录进修改</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="k">user</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k">FOR</span><span class="w"> </span><span class="k">UPDATE</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p><strong>间隙锁</strong></p>
<p>防止在可重复读的隔离级别下，出现幻读问题。</p>
<p>比如，事务A开始读取数据, 发现是3条数据。然后，事务B加了一条数据进去。事务A在读去数据,发现是4条数据, 前后数据总数不一致就是幻读。</p>
</li>
<li>
<p><strong>临键锁</strong>：记录锁 + 间隙锁的组合，既可以锁住记录，也可以防止幻读</p>
</li>
<li>
<p><strong>插入意向锁</strong></p>
<p>意向锁用于快速判断是否可以对某张表加表锁，而无需判断表中具体行的锁定情况。</p>
<p>插入意向锁的作用：</p>
<ul>
<li><strong>标记插入意向图</strong>：事务告诉<code>InnoDB</code>，它计划在某个间隙范围内插入新数据。</li>
<li><strong>允许多个事务并发插入不同位置</strong>：也就是说如果插入的范围不同，插入意向锁之间互不从突。</li>
</ul>
<p>【注意】</p>
<ul>
<li>一个事务有间隙锁时，另外一个事务不能在相同范围内加插入意向锁</li>
<li>一个事务有插入意向锁是，另外一个事务不能在相同范围内假如间隙锁</li>
</ul>
</li>
</ol>
<h2 id="23-mysql-中的-mvcc-是什么">23. MySQL 中的 MVCC 是什么？<a hidden class="anchor" aria-hidden="true" href="#23-mysql-中的-mvcc-是什么">#</a></h2>
<p><strong>【当前读和快照读】</strong></p>
<ul>
<li>当前读：<code>select ... lock in share mode</code>、<code>select ... for update</code>、<code>insert/delete/upate</code> 有锁，会阻塞其他事务。当前读不会生成ReadView， 只会加上临键锁<code>next-key lock</code> (记录锁+间隙锁)</li>
<li>快照读：直接 <code>select</code>，普通的查询操作，不加任何锁，不会阻塞其他事务。会生成ReadView，不会有幻行</li>
</ul>
<p><img alt="MVCC当前读和快照读" loading="lazy" src="https://oss.swimmingliu.cn/76d0b02d-f4b5-11ef-9134-c858c0c1deba"></p>
<p><strong>【当前读和快照读事务执行流程区别】</strong></p>
<pre class="mermaid">sequenceDiagram
    participant T1 as 事务1
    participant T2 as 事务2
    participant DB as 数据库
    participant MVCC as MVCC版本链
    
    Note over T1, MVCC: 场景1：快照读
    T1->>DB: BEGIN
    T1->>MVCC: SELECT * FROM users WHERE id=1 (快照读)
    MVCC-->>T1: 返回快照版本数据: name='Alice'
    
    T2->>DB: BEGIN
    T2->>DB: UPDATE users SET name='Bob' WHERE id=1
    T2->>DB: COMMIT
    
    T1->>MVCC: SELECT * FROM users WHERE id=1 (快照读)
    MVCC-->>T1: 仍返回快照版本: name='Alice'
    T1->>DB: COMMIT
    
    Note over T1, MVCC: 场景2：当前读
    T1->>DB: BEGIN
    T1->>DB: SELECT * FROM users WHERE id=1 FOR UPDATE (当前读)
    DB-->>T1: 获取排他锁，返回最新数据: name='Bob'
    
    T2->>DB: BEGIN
    T2->>DB: SELECT * FROM users WHERE id=1 FOR UPDATE (当前读)
    Note over T2, DB: 等待T1释放锁
    
    T1->>DB: UPDATE users SET name='Charlie' WHERE id=1
    T1->>DB: COMMIT
    
    DB-->>T2: 获取锁成功，返回最新数据: name='Charlie'
    T2->>DB: COMMIT
</pre>

<p><strong>【隔离级别】</strong></p>
<p>不同的隔离级别分别解决了脏读、不可重复读、幻读的问题。</p>
<table>
  <thead>
      <tr>
          <th>隔离性</th>
          <th>读未提交 RU</th>
          <th>读已提交 RC</th>
          <th>可重复读 RR</th>
          <th>串行读</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>脏读</td>
          <td>❌</td>
          <td>✅</td>
          <td>✅</td>
          <td>✅</td>
      </tr>
      <tr>
          <td>不可重复读</td>
          <td>❌</td>
          <td>❌</td>
          <td>✅</td>
          <td>✅</td>
      </tr>
      <tr>
          <td>幻读</td>
          <td>❌</td>
          <td>❌</td>
          <td>❌</td>
          <td>✅</td>
      </tr>
  </tbody>
</table>
<p>【注意】只有读已提交 <code>RC</code> 和可重复读 <code>RR</code> 才会用到快照读</p>
<ul>
<li>可重复读 <code>RR</code>，快照会在事务开始时生成，对数据进行更改才修改快照</li>
<li>读已提交 <code>RC</code> ，每次读取都会重新生成快照，总是读取行的最新版本，所以不可重复读</li>
</ul>
<p><img alt="MVCC隔离级别" loading="lazy" src="https://oss.swimmingliu.cn/773afa2c-f4b5-11ef-88f9-c858c0c1deba"></p>
<p><strong>【MVCC】</strong></p>
<p>MVCC多版本控制并发主要是用来解决 <strong>读-写并发</strong> 所引起的问题的</p>
<ol>
<li><strong>隐藏字段</strong>：
<ul>
<li><code>db_row_id</code>: 如果没有创建主键，就用这个字段来创建聚簇索引</li>
<li><code>db_trx_id</code>：对该记录左最新一次修改的事务的ID</li>
<li><code>db_roll_ptr</code>: 回滚指针，指向当前行记录的上一个版本，也就是指向undo log当中上一个版本的快照地址</li>
</ul>
</li>
</ol>
<p><img alt="MVCC隐藏字段" loading="lazy" src="https://oss.swimmingliu.cn/7755e134-f4b5-11ef-9a76-c858c0c1deba"></p>
<ol start="2">
<li>
<p><strong>Read View</strong>: 隐藏字段和 <code>undo log</code>版本决定的是返回的数据，但是具体返回哪个版本，由<code>read view</code> 和版本链返回规则可见性算法控制</p>
<ul>
<li><code>trx_ids</code> :  表示生成readview是,当前系统中活跃的读写事务的事务ID列表</li>
<li><code>low_limit_id</code>：应该分配给下一个事务的id值 (最大事务id + 1)</li>
<li><code>up_limit_id</code>: 未提交的事务中最小的事务id (最小事务id)</li>
<li><code>creator_trx_id</code>: 创建该readview的事务id</li>
</ul>
<p><img alt="MVCC版本链访问规则" loading="lazy" src="https://oss.swimmingliu.cn/7776ce79-f4b5-11ef-b31c-c858c0c1deba"></p>
<p>什么情况是可以看见的?  <code>trx_id == creator_trx_id</code> (当前事务修改的)、<code>trx_id &lt; up_limit_id</code> (事务已提交)，<code>up_limit_id &lt; trx_id &lt; low_limit_id</code> (如果<code>trx_id</code> 不在 <code>trx_ids</code> 里面，说明不是这条数据不是存活的事务掌控的，数据已经提交了) 都是可见的。 <code>trx_id &gt; low_limit_id</code> 是不可以访问的</p>
<p>如果发现当前的记录是不可见的，那么就需要找undo log日志的历史快照了，如果找不到，则返回空。</p>
<p><img alt="MVCC的undolog找数据" loading="lazy" src="https://oss.swimmingliu.cn/779467a4-f4b5-11ef-9b0c-c858c0c1deba"></p>
<p><strong>【不同隔离版本ReadView的产生时机】</strong></p>
<ul>
<li>读已提交 <code>RC</code>，每次<code>select</code> 都会获取一次Read View</li>
<li>读未提交 <code>RR</code>， 只有第一次<code>select</code>才会获取Read View</li>
</ul>
<p><strong>【二级索引在索引覆盖通过的时候可以用MVCC吗？】</strong></p>
<p>已知如果查询字段包含了所有的二级索引，那么就会走索引覆盖，而不会回表用主键或<code>row_id</code>去读主键索引的页记录。但是，版本链的头节点在主键索引当中 ( 版本链包含<code>row_id</code> ), 通过二级索引的记录没法儿直接找到版本链。这种情况如何用MVCC？</p>
<p>二级索引中，用一个额外的<code>page_max_trx_id</code> 来记录修改过该页的最大事务id</p>
<ol>
<li>如果查询到的<code>readview</code> 的最小未提交的事务id &gt; <code>page_max_trx_id</code>， 说明在创建该readview时，最后一次更新二级索引的事务已经提交了，也就是说对当前查询是可见的，如果二级索引的记录没有被删除，就直接走索引覆盖。</li>
<li>如果最小未提交的事务id &lt;= <code>page_max_trx_id</code>， 意味着数据可能被修改了。不能直接查询，需要回表，用聚簇索引进行查询。聚簇索引中，叶子结点行记录包含了版本链，可以用MVCC。</li>
</ol>
<p>【可重复读<code>RR</code>隔离级别是否可以解决幻读】</p>
<p><code>RR</code>隔离机制不能完全解决幻读的现象，虽然它用了间隙锁，在一定程度上可以解决幻度。</p>
<p>但是，如果存在下面这种情况就不行。</p>
<ol>
<li>事务A进行快照读, 然后事务B插入了一条记录并提交。此时，事务A是可以<code>update</code> 这条语句的，这样就出现了幻读。</li>
<li>当事务中<strong>先执行快照读，再执行当前读</strong>时，可能因读取最新数据而触发幻读</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 事务A（RR隔离级别）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">BEGIN</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">users</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span><span class="w"> </span><span class="c1">-- 快照读，返回空结果
</span></span></span><span class="line"><span class="cl"><span class="c1">-- 事务B插入 age=25 的记录并提交
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">users</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="k">FOR</span><span class="w"> </span><span class="k">UPDATE</span><span class="p">;</span><span class="w"> </span><span class="c1">-- 当前读，返回事务B插入的记录
</span></span></span></code></pre></div></li>
</ol>
<hr>
<p>下面是快速图解版</p>
<p><strong>【MVCC 结构】</strong></p>
<pre class="mermaid">graph TB
    subgraph "数据表"
        T[账户表] --> R1["记录1: 余额=100万"]
        R1 --> H1["db_trx_id: 事务ID"]
        R1 --> H2["db_roll_ptr: 回滚指针"]
        R1 --> H3["db_row_id: 行ID"]
    end
    
    subgraph "Undo Log版本链"
        U1["[版本1]<br/>余额 = 100万<br/>trx_id = 1<br/>roll_ptr → U2"]
        U2["[版本2]<br/>余额 = 80万<br/>trx_id = 2<br/>roll_ptr → U3"]
        U3["[版本3]<br/>余额 = 50万<br/>trx_id = 3<br/>roll_ptr → NULL"]
        U1 --> U2
        U2 --> U3
    end
    subgraph "Read View 结构"
        RV["Read View"]
        RV --> TV["trx_ids: [活跃事务ID列表]"]
        RV --> LT["low_limit_id: 下一个事务ID"]
        RV --> UT["up_limit_id: 最小活跃事务ID"]
        RV --> CT["creator_trx_id: 创建者事务ID"]
    end
    
    subgraph "MVCC判断流程"
        J1["判断 trx_id == creator_trx_id?"]
        J2["判断 trx_id < up_limit_id?"]
        J3["判断 trx_id >= low_limit_id?"]
        J4["判断 trx_id 在 trx_ids 中?"]
        
        J1 -->|是| V1["可见"]
        J1 -->|否| J2
        J2 -->|是| V2["可见"]
        J2 -->|否| J3
        J3 -->|是| NV1["不可见"]
        J3 -->|否| J4
        J4 -->|在| NV2["不可见"]
        J4 -->|不在| V3["可见"]
    end
    
    H2 -.->|指向| U1
    RV -.->|查找版本链| U1
</pre>

<p>【<strong>MVCC - 执行过程】</strong></p>
<pre class="mermaid">sequenceDiagram
    participant T as 事务线程
    participant RV as Read View
    participant UL as Undo Log版本链
    participant R as 记录版本
    
    Note over T: 事务开始读取操作
    T->>RV: 创建/获取Read View
    RV-->>T: 返回Read View<br/>(trx_ids, up_limit_id, low_limit_id, creator_trx_id)
    
    T->>UL: 获取当前记录版本
    UL-->>T: 返回最新版本记录
    
    loop 遍历版本链直到找到可见版本
        T->>R: 获取当前版本的trx_id
        R-->>T: 返回版本的trx_id
        
        Note over T,RV: 开始可见性判断
        
        T->>RV: 判断 trx_id == creator_trx_id?
        alt trx_id 等于 creator_trx_id
            RV-->>T: 可见(自己修改的记录)
            Note over T: 返回当前版本数据
        else 不等于 creator_trx_id
            T->>RV: 判断 trx_id < up_limit_id (最小未提交的事务id)? 
            alt trx_id < up_limit_id
                RV-->>T: 可见(已提交的旧事务)
                Note over T: 返回当前版本数据
            else trx_id >= up_limit_id
                T->>RV: 判断 trx_id >= low_limit_id (下一个待分配的事务id)?
                alt trx_id >= low_limit_id
                    RV-->>T: 不可见(未来事务)
                    T->>UL: 通过roll_ptr获取上一版本
                    UL-->>T: 返回上一版本记录
                else trx_id < low_limit_id
                    T->>RV: 判断 trx_id 是否在 trx_ids 中?
                    alt trx_id 在 trx_ids 中
                        RV-->>T: 不可见(活跃未提交事务)
                        T->>UL: 通过roll_ptr获取上一版本
                        UL-->>T: 返回上一版本记录
                    else trx_id 不在 trx_ids 中
                        RV-->>T: 可见(已提交事务)
                        Note over T: 返回当前版本数据
                    end
                end
            end
        end
    end
    
    Note over T: 找到可见版本或到达版本链末尾
</pre>

<h2 id="补充-231-mysql事务的四大隔离级别实现原理">[补充] 23.1 MySQL事务的四大隔离级别实现原理？<a hidden class="anchor" aria-hidden="true" href="#补充-231-mysql事务的四大隔离级别实现原理">#</a></h2>
<ul>
<li><strong>读未提交</strong>：可以读到未提交的数据，所以直接读最新的数据即可</li>
<li><strong>读已提交</strong>和<strong>可重复读</strong>：是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。
<ul>
<li><strong>读已提交</strong>：<strong>每个语句执行前</strong>， 都会重新生成一个 <strong>Read View</strong> 。可以确保只读到已经提交过的事务，如果没提交在Read View里面是看不到的。</li>
<li><strong>可重复读</strong>：<strong>启动事务时</strong>，生成一个 Read View，整个事务期间都在用这个 <strong>Read View</strong> 。所以，可以确保读取到的都是同一个事务内修改过的数据。即便事务执行过程中有其他已经事务提交，也看不到其他事务修改过的数据记录。</li>
</ul>
</li>
<li><strong>串行化</strong>：通过加读写锁的方式来避免并行访问</li>
</ul>
<p>【案例分析】</p>
<blockquote>
<p>假设有一张账户余额表，里面有一条账户余额为 100 万的记录。然后有两个并发的事务，事务 A 只负责查询余额，事务 B 则会将我的余额改成 200 万，下面是按照时间顺序执行两个事务的行为：</p>
<p><img alt="事务并发案例" loading="lazy" src="https://oss.swimmingliu.cn/44c8997a-88d2-11f0-87e7-caaeffceb345"></p></blockquote>
<p>【分析】</p>
<ul>
<li>可重复读：下面事务并发的执行过程，利用MVCC的快照读解决了不可重复读的问题。（因为在事务开始的时候，就生成了一个ReadView。确保读取到的数据一定是当前事务和之前已提交事务的数据记录，后面的记录都读取不到）</li>
<li>读已提交：如果是读已提交，每次执行都会生成一个ReadView。当事务A第二次读区的时候，就可以读区到事务B提交的数据了。</li>
</ul>
<pre class="mermaid">sequenceDiagram
    participant DB as 数据库记录
    participant UA as 事务A的Undo Log
    participant UB as 事务B的Undo Log
    participant TA as 事务A(trx_id=100)
    participant TB as 事务B(trx_id=101)
    
    Note over DB: 初始状态: 余额=100万, trx_id=99
    
    Note over TA: 1. 事务A启动
    TA->>TA: 生成Read View A<br/>up_limit_id=100<br/>low_limit_id=102<br/>trx_ids=[100]<br/>creator_trx_id=100
    
    Note over TA: 2. 事务A首次读取
    TA->>DB: SELECT 余额
    DB-->>TA: 返回100万<br/>(trx_id=99 < up_limit_id=100, 可见)
    
    Note over TB: 3. 事务B启动
    TB->>TB: 生成Read View B<br/>up_limit_id=100<br/>low_limit_id=102<br/>trx_ids=[100,101]<br/>creator_trx_id=101
    
    Note over TB: 4. 事务B首次读取
    TB->>DB: SELECT 余额
    DB-->>TB: 返回100万<br/>(trx_id=99 < up_limit_id=100, 可见)
    
    Note over TB: 5. 事务B更新数据
    TB->>UB: 创建Undo Log记录<br/>old_value=100万, trx_id=99
    TB->>DB: UPDATE 余额=200万, trx_id=101
    Note over DB: 当前记录: 余额=200万, trx_id=101<br/>roll_ptr→Undo Log(100万, trx_id=99)
    
    Note over TA: 6. 事务A第二次读取(V1)
    TA->>DB: SELECT 余额
    Note over TA,DB: 使用事务A的Read View判断可见性
    Note over TA: trx_id=101 在 trx_ids=[100] 中? 不在<br/>trx_id=101 >= low_limit_id=102? 否<br/>但 trx_id=101 > up_limit_id=100
    TA->>UB: 通过roll_ptr访问Undo Log
    UB-->>TA: 返回100万<br/>(trx_id=99 < up_limit_id=100, 可见)
    
    Note over TB: 7. 事务B提交
    TB->>DB: COMMIT
    Note over DB: 事务B提交，记录持久化
    
    Note over TA: 8. 事务A第三次读取(V2)
    TA->>DB: SELECT 余额
    Note over TA: 仍使用原来的Read View A<br/>(RR级别下Read View不变)
    TA->>UB: 通过roll_ptr访问Undo Log
    UB-->>TA: 返回100万<br/>(可重复读保证)
    
    Note over TA: 9. 事务A提交
    TA->>DB: COMMIT
    
    Note over DB: 10. 最终读取(V3)
    Note over DB: 新事务读取会看到200万<br/>(事务B的修改已提交)
</pre>

<h2 id="补充-232-mysql事务的四大特性的底层原理">[补充] 23.2 MySQL事务的四大特性的底层原理？<a hidden class="anchor" aria-hidden="true" href="#补充-232-mysql事务的四大特性的底层原理">#</a></h2>
<p><strong>【事务的四大特性定义】</strong></p>
<ul>
<li>
<p>原子性（Atomicity）：事务中的所有操作要么全部成功执行并提交，要么全部失败并回滚，不存在部分执行的情况。就像转账操作，扣款和加款必须同时成功或同时失败。</p>
</li>
<li>
<p>隔离性（Isolation）：并发执行的多个事务之间相互隔离，一个事务的执行不应该被其他事务干扰。通过不同的隔离级别来控制并发访问。</p>
</li>
<li>
<p>持久性（Durability）：事务一旦提交，其对数据库的修改就是永久性的，即使系统崩溃也不会丢失。</p>
<p><strong>【为什么需要持久化？】</strong></p>
<pre class="mermaid">graph LR
    A[用户发起转账请求<br/>转账1000元] --> B[MySQL处理事务]
    B --> C[在内存中修改数据<br/>账户A: 5000→4000<br/>账户B: 3000→4000]
    C --> D[返回成功响应给用户<br/>用户认为转账完成]
    D --> E{系统是否崩溃?}

    E -- 正常运行 --> F[数据最终写入磁盘<br/>数据安全保存]
    E -- 突然断电/崩溃 --> G[内存数据丢失<br/>修改全部消失]

    G --> H[严重后果]
    H --> I[用户金钱损失<br/>账户A已扣款<br/>账户B未到账]
    H --> J[银行信誉受损<br/>监管合规问题]
    H --> K[数据不一致<br/>总金额不守恒]

    F --> L[数据一致性保证<br/>业务正常运行]

    style A fill:#e1f5fe
    style G fill:#ffebee
    style H fill:#ffcdd2
    style I fill:#ffcdd2
    style J fill:#ffcdd2
    style K fill:#ffcdd2
    style L fill:#e8f5e8
</pre>

</li>
<li>
<p>一致性（Consistency）：事务执行前后，数据库必须处于一致性状态。所有数据完整性约束都得到满足，不会出现数据不一致的情况。</p>
</li>
</ul>
<p><strong>【四大特性的关系】</strong></p>
<pre class="mermaid">graph TB
    subgraph "MySQL事务ACID特性"
        A["原子性 Atomicity<br/>事务要么全部成功<br/>要么全部失败"]
        I["隔离性 Isolation<br/>并发事务之间<br/>相互独立"]
        D["持久性 Durability<br/>事务提交后<br/>永久保存"]
        C["一致性 Consistency<br/>数据库状态<br/>保持一致"]
    end
    
    A --> C
    I --> C  
    D --> C
    
    style A fill:#e1f5fe
    style I fill:#f3e5f5
    style D fill:#e8f5e8
    style C fill:#fff3e0
</pre>

<p><strong>【四大特性实现原理】</strong></p>
<ol>
<li>
<p><strong>原子性</strong>：原子性主要通过 <code>Undo Log</code> （回滚日志）来实现，<code>Undo Log</code> 的生命周期有三个阶段。</p>
<ul>
<li>
<p><strong>操作记录阶段</strong>：当事务对数据进行修改时，MySQL会先将原始数据记录到 <code>Undo Log</code> 中，然后再执行实际的修改操作。如果是修改操作，<code>Undo Log</code> 存的是数据、<code>trx_id</code>、<code>row_id</code>、<code>rollback_pt</code> (MVCC 记录)。如果是新增操作，会记录一条对应的删除操作，用于后续回滚。</p>
</li>
<li>
<p><strong>回滚处理阶段</strong>：如果事务需要回滚（主动ROLLBACK或系统异常），MySQL会读取 <code>Undo Log</code> 中记录的原始数据，并使用这些数据将数据库恢复到事务开始前的状态。</p>
</li>
<li>
<p><strong>提交处理阶段</strong>：如果事务成功提交，<code>Undo Log</code> 中的数据会被标记为可清理状态，等待后台进程回收。</p>
</li>
</ul>
<pre class="mermaid">sequenceDiagram
    participant Client as 客户端
    participant Server as MySQL服务器
    participant UndoLog as Undo Log
    participant Buffer as 缓冲池
    participant Storage as 存储引擎

    Client->>Server: BEGIN TRANSACTION
    Server->>UndoLog: 创建事务ID和Undo Log空间

    Client->>Server: UPDATE users SET balance=1000 WHERE id=1
    Server->>UndoLog: 记录原始数据<br/>(id=1, balance=500)
    Server->>Buffer: 修改缓冲池数据<br/>(id=1, balance=1000)

    Client->>Server: INSERT INTO orders VALUES(1, 'item1')
    Server->>UndoLog: 记录插入操作的反向删除记录<br/>(DELETE FROM orders WHERE id=1)
    Server->>Buffer: 在缓冲池中插入新记录

    alt 事务提交成功
        Client->>Server: COMMIT
        Server->>Storage: 将缓冲池数据刷新到磁盘
        Server->>UndoLog: 标记Undo Log为可清理状态
        Server-->>Client: 事务提交成功
    else 事务回滚
        Client->>Server: ROLLBACK (或系统异常)
        Server->>UndoLog: 读取Undo Log中的历史数据
        Server->>Buffer: 使用Undo Log恢复原始数据<br/>(id=1, balance=500)
        Server->>Buffer: 删除已插入的订单记录
        Server-->>Client: 事务回滚完成
    end
</pre>

</li>
<li>
<p><strong>持久性</strong>：主要通过 <strong><code>Redo log</code> 、双阶段提交、双写缓存区</strong>来确保事务的持久性</p>
<ul>
<li>
<p><strong>Redo Log机制</strong>：MySQL使用WAL（Write-Ahead Logging）策略，先写日志再写数据。即使系统崩溃，也能通过重放Redo Log恢复数据。</p>
</li>
<li>
<p><strong>两阶段提交</strong>：协调Redo Log和Binary Log的写入顺序，确保事务的一致性和持久性。</p>
</li>
<li>
<p><strong>双写缓冲区</strong>：防止页面写入过程中的部分写问题，确保数据页的完整性。</p>
</li>
</ul>
<p><strong>【持久化机制流程图】</strong></p>
<pre class="mermaid">graph LR
		 subgraph "崩溃恢复机制"
		 				direction LR
            Y[系统重启] --> Z[读取Redo Log]
            Z --> AA[从检查点开始重放]
            AA --> BB[恢复未刷盘的修改]
            BB --> CC[数据完整性验证]
     end

    subgraph "二阶段提交"
    		direction LR
        DD[Phase 1: Prepare] --> EE[写入Prepare状态]
        EE --> FF[刷新Redo Log]
        FF --> GG[写入Binary Log]
        GG --> HH[Phase 2: Commit]
        HH --> II[写入Commit状态]
        II --> JJ[事务完成]
    end

    subgraph "用户层"
        A[客户端应用] --> B[事务提交请求]
    end

    subgraph "MySQL服务器层"
        B --> C[SQL解析器]
        C --> D[事务管理器]
        D --> E[存储引擎接口]
    end

    subgraph "InnoDB存储引擎"
        E --> F[缓冲池 Buffer Pool]

        subgraph "内存结构"
            F --> G[数据页缓存]
            F --> H[索引页缓存]
            F --> I[Undo页缓存]

            J[Log Buffer] --> K[Redo Log Records]
        end

        subgraph "磁盘持久化机制"
            L[Redo Log Files] --> M[ib_logfile0]
            L --> N[ib_logfile1]

            O[数据文件] --> P[表空间 .ibd]
            O --> Q[系统表空间 ibdata]

            R[双写缓冲区] --> S[Double Write Buffer<br/>连续的磁盘区域]
        end

        subgraph "WAL写入流程"
            G --> T{数据页修改}
            T --> U[1. 记录到Redo Log Buffer]
            U --> V[2. 写入Redo Log Files<br/>fsync强制刷盘]
            V --> W[3. 标记页面为脏页]
            W --> X[4. 后台异步刷脏页]
        end
    end

    K --> U
    V --> L
    X --> R
    R --> O

    style F fill:#e3f2fd
    style L fill:#fff3e0
    style R fill:#f3e5f5
    style DD fill:#e8f5e8
</pre>

<p><strong>【持久化机制-执行过程详细时序图】</strong></p>
<pre class="mermaid">sequenceDiagram
    participant Client as 客户端
    participant Server as MySQL服务器
    participant Buffer as 缓冲池
    participant RedoLog as Redo Log
    participant BinLog as Binary Log
    participant Disk as 磁盘存储
    participant DoubleWrite as 双写缓冲区

    Client->>Server: BEGIN TRANSACTION

    Client->>Server: UPDATE users SET balance=1000 WHERE id=1

    Note over Server: 开始两阶段提交过程

    Server->>Buffer: 在缓冲池中修改数据页<br/>(balance=1000)

    Server->>RedoLog: 写入Redo Log记录<br/>(LSN=1001, 页面修改详情)
    RedoLog->>RedoLog: 将日志写入Log Buffer

    Client->>Server: COMMIT

    Note over Server: 第一阶段：准备提交

    Server->>RedoLog: 写入Prepare状态的Redo Log<br/>(XID=12345, state=PREPARE)
    RedoLog->>Disk: 强制刷新Redo Log到磁盘<br/>(fsync调用)

    Server->>BinLog: 写入Binary Log记录<br/>(XID=12345, SQL语句)
    BinLog->>Disk: 强制刷新Binary Log到磁盘<br/>(fsync调用)

    Note over Server: 第二阶段：最终提交

    Server->>RedoLog: 写入Commit状态的Redo Log<br/>(XID=12345, state=COMMIT)
    RedoLog->>Disk: 刷新Commit记录到磁盘

    Server-->>Client: 返回提交成功响应

    Note over Server: 后台异步刷脏页过程

    par 脏页刷新
        Server->>DoubleWrite: 将脏页先写入双写缓冲区
        DoubleWrite->>Disk: 刷新双写缓冲区到磁盘
        DoubleWrite-->>Server: 双写完成确认
        Server->>Disk: 将脏页写入实际数据文件位置
    and 检查点处理
        Server->>RedoLog: 推进检查点LSN
        Server->>RedoLog: 清理已刷新脏页对应的Redo Log
    end

    Note over Server: 崩溃恢复场景
    alt 系统崩溃后重启
        Server->>RedoLog: 从检查点开始读取Redo Log
        Server->>Buffer: 根据Redo Log重放未刷盘的修改
        Server->>Disk: 重新应用所有已提交事务的修改
        Note over Server: 持久性得到保证，数据不会丢失
    end
</pre>

</li>
<li>
<p><strong>隔离性</strong>: 主要通过<strong>锁</strong>和<strong>MVCC</strong>两大机制来保证并发事务之间，事务能够相互独立。</p>
<pre class="mermaid">sequenceDiagram
    participant T1 as 事务1<br/>(Transaction ID: 100)
    participant T2 as 事务2<br/>(Transaction ID: 101)
    participant LockManager as 锁管理器
    participant MVCC as MVCC引擎
    participant UndoLog as Undo Log
    participant DataPage as 数据页

    Note over T1, T2: 假设两个并发事务同时操作用户余额

    T1->>LockManager: BEGIN TRANSACTION
    LockManager->>T1: 分配事务ID: 100

    T2->>LockManager: BEGIN TRANSACTION  
    LockManager->>T2: 分配事务ID: 101

    T1->>LockManager: 请求修改用户ID=1的数据<br/>UPDATE users SET balance=1000 WHERE id=1
    LockManager->>T1: 获得行级写锁(X锁)
    T1->>UndoLog: 记录原始数据(balance=500)
    T1->>DataPage: 修改数据页<br/>(balance=1000, trx_id=100)

    T2->>MVCC: 读取用户ID=1的数据<br/>SELECT balance FROM users WHERE id=1
    MVCC->>UndoLog: 检查当前活跃事务列表<br/>发现事务100未提交
    MVCC->>UndoLog: 通过Undo Log找到事务100之前的版本
    MVCC->>T2: 返回快照读结果(balance=500)<br/>基于ReadView机制

    T2->>LockManager: 尝试修改同一数据<br/>UPDATE users SET balance=800 WHERE id=1
    LockManager->>T2: 等待锁释放<br/>(阻塞状态)

    alt 事务1提交
        T1->>LockManager: COMMIT
        T1->>DataPage: 将修改写入磁盘
        LockManager->>T2: 释放行级写锁<br/>唤醒等待的事务2
        T2->>LockManager: 获得行级写锁
        T2->>DataPage: 修改数据页<br/>(balance=800, trx_id=101)
        T2->>LockManager: COMMIT
    else 事务1回滚
        T1->>LockManager: ROLLBACK
        T1->>UndoLog: 恢复原始数据(balance=500)
        LockManager->>T2: 释放行级写锁
        T2->>LockManager: 获得行级写锁
        T2->>DataPage: 基于原始值修改<br/>(balance=800, trx_id=101)
    end
</pre>

</li>
</ol>
<h2 id="24-mysql-中的日志类型有哪些binlogredo-log-和-undo-log-的作用和区别是什么">24. MySQL 中的日志类型有哪些？binlog、redo log 和 undo log 的作用和区别是什么？<a hidden class="anchor" aria-hidden="true" href="#24-mysql-中的日志类型有哪些binlogredo-log-和-undo-log-的作用和区别是什么">#</a></h2>
<ol>
<li><strong>binlog 二进制日志</strong>: binlog是MySQL的二进制文件，用于记录所有的增删改操作 (包括表结构和数据的操作)。binlog是在事务提交后生成的，可以用于恢复数据库和备份数据库。(一般MySQL都有主库+从库两个数据库，防止单台故障，binlog就是为了同步主库和从库的)</li>
<li><strong>redo log 重做日志</strong>: redo log使用来恢复数据的，保证数据的一致性和持久性。当MySQL发生修改是，redolog会将这些操作记录下来，并写入磁盘。当数据库宕机时，可以通过重放redo log恢复数据</li>
<li><strong>undo log 回滚日志</strong>: undo log是用于回滚操作的。当MySQL开始事务的时候，undo log会记录这些操作的反向操作。当需要回滚的时候，通过执行相反的操作，就可以回滚事务。</li>
</ol>
<p><strong>【区别】</strong></p>
<table>
  <thead>
      <tr>
          <th>日志名称</th>
          <th>作用层级</th>
          <th>作用</th>
          <th>内容</th>
          <th>写入方式</th>
          <th>写入时间点</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>binlog</strong></td>
          <td>Server层</td>
          <td>记录所有操作，支持<strong>备份恢复和主从复制</strong></td>
          <td>记录<strong>逻辑操作</strong> (SQL语句 / 行的变化)</td>
          <td><strong>追加写入</strong>，写满之后创建新文件，再写</td>
          <td>事务提交完成后，写入一次</td>
      </tr>
      <tr>
          <td><strong>redo log</strong></td>
          <td>InnoDB存储引擎层</td>
          <td>保证数据的一致性和持久性，用于<strong>故障恢复(断电宕机)</strong></td>
          <td>记录<strong>物理修改</strong> (数据页的修改)</td>
          <td><strong>循环写入</strong>，固定大小，写完之后从头开始写</td>
          <td>事务进行中，不断写入</td>
      </tr>
      <tr>
          <td><strong>undo log</strong></td>
          <td>InnoDB存储引擎层</td>
          <td>保证<strong>事务的原子性</strong>，用于回滚数据</td>
          <td>记录事务修改钱的数据，用于<strong>回滚和MVCC</strong></td>
          <td>随事务变化生成，形成<strong>版本链</strong></td>
          <td>事务进行中，不断写入</td>
      </tr>
  </tbody>
</table>
<p><strong>【undo log 结构图】</strong>
<img alt="undolog结构图" loading="lazy" src="https://oss.swimmingliu.cn/77c6cfcb-f4b5-11ef-bfdf-c858c0c1deba"></p>
<p><strong>【Redo Log + Undo log 结构图】</strong></p>
<p><img alt="RedoLog结构图" loading="lazy" src="https://oss.swimmingliu.cn/77df6328-f4b5-11ef-a7dc-c858c0c1deba"></p>
<h2 id="25-mysql隔离级别有哪些">25. MySQL隔离级别有哪些?<a hidden class="anchor" aria-hidden="true" href="#25-mysql隔离级别有哪些">#</a></h2>
<p>MySQL的隔离级别包括四类: 读未提交 <code>RU</code>、读已提交 <code>RC</code>、可重复读 <code>RR</code>、串行化</p>
<ul>
<li><strong>读未提交 <code>RU</code> :</strong> 顾名思义，如果有两个事务，事务A会在执行过程中读取,事务B还没有提交的修改数据。会出现脏读的情况， 就是读取了其他事务还没提交的数据。</li>
<li><strong>读已提交 <code>RC</code>:</strong> 顾名思义，如果有两个事务，事务A会在执行过程中，读取事务B提交之后的数据，若未提交不会读取。但是会出现不可重复读的现象，过程如下。
<ol>
<li>事务A第一次<code>select name where id = 1</code>读取的数据为 <code>小邓</code></li>
<li>事务B <code>update user set name = '小刘'</code> 并提交</li>
<li>事务A再次<code>select name where id = 1</code>读取的数据为 <code>小刘</code> ，结果发生了变化 (你**的究竟是谁)</li>
</ol>
</li>
<li><strong>可重复读 <code>RR</code>:</strong> 为了解决不可重复读的现象，<code>RR</code> 隔离级别下，事务A会只用第一次 <code>select</code> (快照读)的时候，生成<code>read view</code>。如果事务B修改同一行的数据并提交。事务A第二次<code>select</code> (快照读)的时候，会用第一次的查询结果。但是，它会出现幻读的现象，过程如下。
<ul>
<li>事务A第一次<code>select count(*)</code> 读取的数据为 <code>10</code>， 采用的快照读</li>
<li>事务B <code>insert xxx</code> 新增了一条数据并提交</li>
<li>事务A第二次用<code>select count(*) for update</code>，采用当前读。读出来的数据为<code>11</code>条</li>
</ul>
</li>
<li><strong>串行化：</strong> 可以理解成把<code>RR</code>隔离级别下，所有的快照读都替换成当前读。当前读的状态下，其他事务不能修改正在读取的数据，实现了读的一致性，避免了幻读。 但是并发性能很低。</li>
</ul>
<p><strong>【不同隔离级别的特性】</strong></p>
<table>
  <thead>
      <tr>
          <th>特性</th>
          <th>读未提交 RU</th>
          <th>读已提交 RC</th>
          <th>可重复读 RR</th>
          <th>串行读</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>脏读</td>
          <td>❌</td>
          <td>✅</td>
          <td>✅</td>
          <td>✅</td>
      </tr>
      <tr>
          <td>不可重复读</td>
          <td>❌</td>
          <td>❌</td>
          <td>✅</td>
          <td>✅</td>
      </tr>
      <tr>
          <td>幻读</td>
          <td>❌</td>
          <td>❌</td>
          <td>❌</td>
          <td>✅</td>
      </tr>
      <tr>
          <td>并发量</td>
          <td>高</td>
          <td>较高</td>
          <td>较低</td>
          <td>低</td>
      </tr>
  </tbody>
</table>
<p><strong>【<code>RR</code> 隔离级别幻读的解决方案】</strong></p>
<p>只采用下面的某一种方式进行读，就不会出现幻读</p>
<ol>
<li>快照读 (MVCC机制)：利用MVCC多版本控制，不会出现幻读。</li>
<li>当前读 (加锁查询)：通过临键锁<code>Next-key Lock</code> (记录锁 + 间隙锁)，避免其他事务修改数据，防止幻读。其实就是串行化隔离级别。</li>
</ol>
<h2 id="26-数据库的脏读不可重复读和幻读分别是什么">26. 数据库的脏读、不可重复读和幻读分别是什么？<a hidden class="anchor" aria-hidden="true" href="#26-数据库的脏读不可重复读和幻读分别是什么">#</a></h2>
<table>
  <thead>
      <tr>
          <th>名称</th>
          <th>定义</th>
          <th>定义(整活版)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>脏读</td>
          <td>事务A读取到了事务B还没提交的数据</td>
          <td>骗子啊!!!</td>
      </tr>
      <tr>
          <td>不可重复读</td>
          <td>事务A第一次读取的数据和后面读取到的数据不一致</td>
          <td>谁**动我东西了?</td>
      </tr>
      <tr>
          <td>幻读</td>
          <td>事务A第一次读取的数据总数和第二次读取的数据总数不一样</td>
          <td>闹鬼了，进去前3个人，出来了4个人</td>
      </tr>
  </tbody>
</table>
<p>整活版解释参见ID为 <code>小明</code> 的天才选手</p>
<h2 id="27-mysql-默认的事务隔离级别是什么为什么选择这个级别">27. MySQL 默认的事务隔离级别是什么？为什么选择这个级别？<a hidden class="anchor" aria-hidden="true" href="#27-mysql-默认的事务隔离级别是什么为什么选择这个级别">#</a></h2>
<p>MySQL默认的事务隔离级别是可重复读 <code>RR</code> 。</p>
<p><strong>【为什么选 <code>RR</code> 隔离级别】</strong></p>
<p>因为MySQL当中一般是有主库 + 从库两个数据库，为了避免一个库突然g了，数据库就全g了。主库和从库之间是采用binlog进行备份的，如果binlog是statement格式，在<code>RU</code>和<code>RC</code>的隔离级别下，主库和从库就会出现数据不一致的问题。</p>
<p><img alt="MySQL主从数据库同步" loading="lazy" src="https://oss.swimmingliu.cn/7819b534-f4b5-11ef-878a-c858c0c1deba"></p>
<p><strong>【binlog 格式】</strong></p>
<table>
  <thead>
      <tr>
          <th>格式名称</th>
          <th>内容</th>
          <th>优点</th>
          <th>缺点</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>statement</strong></td>
          <td>记录执行的SQL语句，发送到从库执行</td>
          <td>日志量少，传输率高，简单操作</td>
          <td><code>limit</code> 这种依赖环境的函数，可能出现数据不一致情况</td>
      </tr>
      <tr>
          <td><strong>row</strong></td>
          <td>记录每行数据变化，发送到从库应用</td>
          <td>准确复制数据，避免主从不一致的情况</td>
          <td>日志量大，占用带宽和空间</td>
      </tr>
      <tr>
          <td><strong>mixed</strong></td>
          <td>结合语句和行复制，自动切换</td>
          <td>日志量一般，主从一致性较高</td>
          <td>自动切换操作复杂</td>
      </tr>
  </tbody>
</table>
<p><strong>【<code>RU</code> 和 <code>RC</code> 导致主从不一致】</strong></p>
<table>
  <thead>
      <tr>
          <th>session1</th>
          <th>session2</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>事务A开始</td>
          <td></td>
      </tr>
      <tr>
          <td><code>delete from user where age &lt; 10</code></td>
          <td>事务B开始</td>
      </tr>
      <tr>
          <td></td>
          <td><code>insert into user value(5,...)</code></td>
      </tr>
      <tr>
          <td></td>
          <td>事务B提交</td>
      </tr>
      <tr>
          <td>事务A提交</td>
          <td></td>
      </tr>
  </tbody>
</table>
<p>此时，binlog里面记录的如下，执行顺序显然和原始的不一样，从库里面<code>age = 5</code> 这条数据肯定没了</p>
<ol>
<li><code>insert into user value(10,...)</code></li>
<li><code>delete from user where age &lt; 10</code></li>
</ol>
<p><strong>【为什么 <code>RR</code> 不会出现主从数据不一致】</strong></p>
<p>因为 <code>RR</code> 隔离级别不仅会对更新的数据行添加行级的记录锁， 还会添加间隙锁和临键锁。如果有这两个锁的话，在事务B执行<code>insert</code>的时候，会被阻塞的。</p>
<p><strong>【为什么大厂一般用 <code>RC</code> 】</strong></p>
<p>先来对比一下<code>RC</code> 和 <code>RR</code> 隔离级别的区别</p>
<table>
  <thead>
      <tr>
          <th>特性</th>
          <th><code>RC</code></th>
          <th><code>RR</code></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>binlog格式</strong></td>
          <td>只能用<code>row</code>, 用<code>mixed</code>也会自动切换未<code>row</code></td>
          <td><code>statement</code>、<code>row</code>、<code>mixed</code></td>
      </tr>
      <tr>
          <td><strong>锁机制</strong></td>
          <td>只有行级的记录锁</td>
          <td>记录锁、间隙锁、临键锁</td>
      </tr>
      <tr>
          <td><strong>读机制</strong></td>
          <td>当前读：每次都生成新的快照，读取行的最新版本</td>
          <td>同时支持当前读和快照读，默认<code>select</code>是快照读</td>
      </tr>
      <tr>
          <td><strong>并发性</strong></td>
          <td>并发性高</td>
          <td>并发性低：因为有间隙锁、临键锁，会导致锁竞争加剧，降低系统的并发性能。</td>
      </tr>
  </tbody>
</table>
<p>用<code>RC</code>的原因有两个:</p>
<ol>
<li>提高并发：因为相较于<code>RR</code>，<code>RC</code> 的并发率更高</li>
<li>减少死锁：因为<code>RR</code> 当中的间隙锁和临键锁会使得锁的粒度变大，死锁的几率会变大。</li>
</ol>
<p><strong>【 <code>RC</code> 如何解决不可重复读问题】</strong></p>
<p>如果只是单纯的不可重复读，其实还好，只要后面修改数据不基于这个值。所以，在修改核心表的时候，增加乐观锁的标记。更新的时候带上乐观锁进行版本判断之后，再更新。</p>
<h2 id="28-mysql-事务的二阶段提交是什么-mysql里面的-redolog-和-binlog-怎么保持一致">28. MySQL 事务的二阶段提交是什么？/ MySQL里面的 <code>Redolog</code> 和 <code>BinLog</code> 怎么保持一致?<a hidden class="anchor" aria-hidden="true" href="#28-mysql-事务的二阶段提交是什么-mysql里面的-redolog-和-binlog-怎么保持一致">#</a></h2>
<p>首先，事务的二阶段提交就是为了让MySQL中的 <code>binlog</code> 和 <code>redo log</code> 保持一致。</p>
<p><strong>【为什么需要两阶段提交】</strong></p>
<p>如果没有两阶段提交，可能会导致<code>binlog</code>和<code>redo log</code>不一致，可以参考下面两种情况</p>
<ul>
<li>
<p>**情况一：**先写完 <code>redo log</code>，再写<code>binlog</code>：如果写完<code>redo log</code>后，MySQL突然宕机了，<code>binlog</code>还没写入数据。此时，MySQL重启后，根据 <code>redo log</code> 恢复事务的修改，但是<code>binlog</code>没有本次事务提交的数据。所以通过<code>binlog</code>恢复的时候，这次事务的修改就丢了。</p>
</li>
<li>
<p>**情况二：**先写完<code>binlog</code>，再写<code>redo log</code>：如果写完<code>binlog</code>之后，突然MySQL宕机了，<code>redo log</code>还没写入数据。重启后因为<code>redo log</code>里面没有记录，所以没法儿恢复事务的修改。但是<code>binlog</code>记录了本次事务提交的数据，后续用<code>binlog</code>恢复数据的时候，就导致和原库不一样了。(<code>binlog</code>是用来给从库复制的)</p>
</li>
</ul>
<p>为了避免上面的两种情况发生，就把单个事务的提交拆分为2个阶段：<strong>准备阶段(prepare)</strong> + <strong>提交阶段(commit)</strong></p>
<p><strong>【事务的二阶段提交过程】</strong></p>
<ol>
<li><strong><code>prepare</code> 准备阶段</strong>: <code>InnoDB</code> 将内部事务id <code>XID</code> 写入<code>redo log</code>，并将其标记为 <code>prepare</code> 状态。然后将<code>redo log</code> 持久化到磁盘或者写入<code>redo log buffer</code>，具体取决于 <code>innodb_flush_log_at_trx_commit</code> 参数</li>
<li><strong><code>commit</code> 提交阶段</strong>：将内部事务id <code>XID</code>写入到<code>binlog</code>，调用<code>write()</code>函数写入到文件系统的<code>Page Cache</code>。当<code>binlog</code>写入磁盘成功就认为事务就是执行完成了，就算<code>redo log </code>还是<code>prepare</code>状态也没事儿。</li>
</ol>
<p>如何解决的上面提到的两种情况呢？</p>
<ul>
<li><strong>情况一：</strong> 写完 <code>redo log</code> 之后，还处于<code>prepare</code>状态，还没写入<code>binlog</code>， 突然宕机了。
<ol>
<li>MySQL重启后，会顺序扫描<code>redo log</code>文件，如果还处于<code>prepare</code>状态，就查看<code>redo log</code>当中的内部事务ID<code>XID</code>在<code>binlog</code>中是否存在</li>
<li>如果<code>binlog</code>不存在内部事务id<code>XID</code>，表明<code>redolog</code>已经刷盘(写入磁盘了)，但是<code>binlog</code>还没有刷盘，直接回滚事务，就当这条事务执行失败</li>
</ol>
</li>
<li><strong>情况二：</strong> 写完<code>bin log</code>之后，还处于<code>prepare</code>状态，还没<code>commit</code>， 突然宕机了。
<ol>
<li>MySQL重启后，会顺序扫描<code>redo log</code>文件，如果还处于<code>prepare</code>状态，就查看<code>redo log</code>当中的内部事务ID<code>XID</code>在<code>binlog</code>中是否存在。 (一般都是先扫描<code>redolog</code>，再看<code>binlog</code>)</li>
<li>如果<code>binlog</code>里面有当前内部事务id<code>XID</code>，说明<code>redolog</code>和<code>binlog</code>都刷盘了，直接提交事务就好了。</li>
</ol>
</li>
</ul>
<p><img alt="MySQL二阶段提交时序图" loading="lazy" src="https://oss.swimmingliu.cn/7898fa5b-f4b5-11ef-a066-c858c0c1deba"></p>
<p><strong>【两阶段提交有没有什么问题】</strong></p>
<p>两阶段提交确实会导致磁盘I/O次数增高和锁的竞争变得激烈</p>
<ol>
<li><strong>磁盘I/O的次数增高</strong>: 每次事务提交都会进行两次写入磁盘 <code>fsync</code>，一次<code>redolog</code>刷盘，一次<code>binlog</code>刷盘</li>
<li><strong>锁竞争激烈</strong>：为了保证单事务的两个日志内容一致，所以需要在提交流程上，添加锁保证两阶段的原子性。确保日志里面的顺序，不受多事务提交的影响。</li>
</ol>
<p><strong>【优化二阶段提交：组提交】</strong></p>
<p>为了减少二阶段提交的I/O次数和锁的竞争，MySQL新增了组提交机制，可以让多个事务提交时合并多个<code>binlog</code>，只进行一次刷盘操作。组提交版本的二阶段提交只有<code>commit</code>提交部分有些变化：</p>
<ol>
<li><strong>flush阶段</strong>：多个事务按照顺序将<code>binlog</code>从Cache写入到文件 (不刷盘)， 为了支撑<code>redo log</code>组提交</li>
<li><strong>sync同步阶段</strong>：对<code>binlog</code>进行写入磁盘<code>fsync</code>操作，多个事务的<code>binlog</code>一并写入磁盘，为了支撑<code>binlog</code>的组提交</li>
<li><strong>commit阶段:</strong> 所有事务按照顺序进行commit提交操作</li>
</ol>
<p>每个阶段都有队列维护，锁针对队列进行保护，减小锁的范围的同时，提高效率。</p>
<p><strong>【binlog刷盘时间】</strong></p>
<ol>
<li>事务执行过程中，线写日志到<code>binlog cache</code> (Server层的cache)</li>
<li>事务提交的时候，从<code>binlog cache</code> 写入到 <code>binlog</code>文件。单个事务的binlog不能拆开，只能一次性写入。</li>
</ol>
<p>​    MySQL分配了一片内存用于缓冲<code>binlog </code>，就是<code>binlog cache</code>。可以用<code>binlog_cache_size</code>修改它的大小。</p>
<p><img alt="所有Log的结构" loading="lazy" src="https://oss.swimmingliu.cn/78b5fb08-f4b5-11ef-bc79-c858c0c1deba"></p>
<h2 id="29-什么是-write-ahead-logging-wal-技术它的优点是什么mysql-中是否用到了-wal">29. 什么是 Write-Ahead Logging (WAL) 技术？它的优点是什么？MySQL 中是否用到了 WAL？<a hidden class="anchor" aria-hidden="true" href="#29-什么是-write-ahead-logging-wal-技术它的优点是什么mysql-中是否用到了-wal">#</a></h2>
<p><code>WAL</code> 是用来确保在修改真正的数据之前，先将修改记录写入日志的技术。为了当系统宕机的时候，通过日志也可以恢复数据，MySQL的<code>redo log</code>就是依靠的 <code>WAL</code>技术。它的核心就是, <strong>先写日志，再写数据</strong></p>
<p>MySQL事务从开启到提交的过程，大致如下：</p>
<p>开启事务 -&gt; 查询数据到内存 -&gt; 记录<code>undo log</code> -&gt; 记录<code>redo log</code>(prepare阶段) -&gt; 更新内存 -&gt; 记录<code>binlog</code> -&gt; 记录<code>redo log</code> (commit之后)</p>
<pre class="mermaid">graph LR
    subgraph "传统写入方式（无WAL）的问题"
        A1[用户提交事务] --> B1[直接修改数据文件]
        B1 --> C1{数据文件写入完成?}
        C1 -- 写入中断电 --> D1[数据文件损坏<br/>原始数据丢失<br/>新数据不完整]
        C1 -- 写入成功 --> E1[数据安全]
        D1 --> F1[❌ 数据无法恢复]
    end
    
    subgraph "WAL策略的优势"
        A2[用户提交事务] --> B2[1. 先写Redo Log<br/>记录：在页面X的偏移Y<br/>将值从A改为B]
        B2 --> C2[2. 强制刷新Redo Log到磁盘<br/>fsync系统调用]
        C2 --> D2[3. 返回用户事务成功]
        D2 --> E2[4. 后台异步刷新数据页]
        
        subgraph "崩溃恢复场景"
            F2[系统崩溃重启] --> G2[读取Redo Log]
            G2 --> H2[重放所有已提交事务的修改]
            H2 --> I2[✅ 数据完整恢复]
        end
        
        E2 --> J2{系统崩溃?}
        J2 -- 正常运行 --> K2[数据最终写入数据文件]
        J2 -- 崩溃 --> F2
    end
    
    subgraph "WAL性能优势"
        L1[顺序写入Redo Log<br/>高性能] --> M1[随机写入数据文件<br/>可异步执行]
        N1[小尺寸日志记录<br/>快速I/O] --> O1[大尺寸数据页面<br/>批量写入]
    end
    
    style D1 fill:#ffcdd2
    style F1 fill:#ffcdd2
    style I2 fill:#e8f5e8
    style L1 fill:#e3f2fd
    style N1 fill:#e3f2fd
</pre>

<h2 id="30-mysql-中如果发生死锁应该如何解决">30. MySQL 中如果发生死锁应该如何解决？<a hidden class="anchor" aria-hidden="true" href="#30-mysql-中如果发生死锁应该如何解决">#</a></h2>
<p><strong>【如何处理MySQL死锁】</strong></p>
<ol>
<li>
<p><strong>设置MySQL死锁自动检测机制</strong></p>
<p>MySQL自带死锁检测机制<code>innodb_deadlock_detect</code>，开启即可。如果检查到死锁的发生，数据库会自动回滚一个持有资源较少的事务，然后另一个事务就可以执行了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 查看主动死锁检测是否开启
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">show</span><span class="w"> </span><span class="k">variable</span><span class="w"> </span><span class="k">like</span><span class="w"> </span><span class="s1">&#39;%innodb_deadlock_detect%&#39;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- 开启主动死锁检测 (默认为ON)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">set</span><span class="w"> </span><span class="k">global</span><span class="w"> </span><span class="n">innodb_deadlock_detect</span><span class="o">=</span><span class="s1">&#39;ON&#39;</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p><strong>设置锁等待超时参数</strong></p>
<p>可以设置获取锁的等待时间(默认为<code>50</code>s)，如果超过了这个时间，就会主动释放锁，让事务回滚</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 事务等待锁的超时时间 (默认为50s)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">show</span><span class="w"> </span><span class="k">variable</span><span class="w"> </span><span class="k">like</span><span class="w"> </span><span class="s1">&#39;%innodb_lock_wait_timeout%&#39;</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p><strong>KILL死锁事务</strong></p>
<p>如果MySQL已经上线了，且没有设置那些检测，可以直接把死锁的事务kill掉。kill之前，需要查看一下执行的事务和表信息，用<code>show engine innodb status</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 查看死锁日志
</span></span></span><span class="line"><span class="cl"><span class="c1">-- 查看正在执行的事务, 和相关的表信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SHOW</span><span class="w"> </span><span class="n">ENGINE</span><span class="w"> </span><span class="n">INNODB</span><span class="w"> </span><span class="n">STATUS</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">-- 通过线程ID, 手动KILL死锁事务
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">kill</span><span class="w"> </span><span class="err">线程</span><span class="n">ID</span><span class="w">
</span></span></span></code></pre></div></li>
</ol>
<p><strong>【如何避免死锁的发生】</strong></p>
<ol>
<li><strong>避免大事务</strong>: 大事务占用的时间比较长，容易导致死锁发生。可以把大事务拆解成多个小事务，就可以降低死锁的发生概率。</li>
<li><strong>更改数据库的隔离级别</strong>：MySQL的默认隔离级别是<code>RR</code>，它包含间隙锁和临键锁。如果改成<code>RC</code>，可以减少死锁的概率。</li>
<li><strong>合理加索引，减少加锁范围</strong>：命中索引会对该行加上行锁，没有命中则会对整张表加上表锁。表锁的冲突概率比较大，容易导致死锁。</li>
</ol>
<h2 id="31-mysql-中如何解决深度分页的问题">31. MySQL 中如何解决深度分页的问题？<a hidden class="anchor" aria-hidden="true" href="#31-mysql-中如何解决深度分页的问题">#</a></h2>
<ol>
<li>
<p><strong>深度分页问题定义</strong>：深度分页是指当用户需要查询很久以前的数据，比如早年某个范围的订单。 SQL语句当中的 <code>limit</code> 偏移量变得非常大，MySQL性能直线下降的现象。</p>
</li>
<li>
<p><strong>为什么会性能下降:</strong> 因为MySQL会选择全表扫描，而不用索引扫描，导致效率低下。当 <code>limit</code> 偏移量偏大的时候，查询流程如下：</p>
<ol>
<li>扫描偏移量之前的1000000行，丢弃不符合条件的结果</li>
<li>每一次查询都需要用 <code>age</code> 列查到的主键值去回表，效率很低。(MySQL优化器就选择了，全表扫描 + 文件排序)</li>
<li>返回符合条件的最终记录</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="k">user</span><span class="w">  </span><span class="k">where</span><span class="w"> </span><span class="n">sex</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;女&#39;</span><span class="w"> </span><span class="k">order</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">age</span><span class="w">  </span><span class="k">limit</span><span class="w"> </span><span class="mi">1000000</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="w"> 
</span></span></span></code></pre></div></li>
</ol>
<p><strong>【如何解决深度分析带来的性能问题】</strong></p>
<ol>
<li>
<p><strong>记录上一次的最大ID，修改为范围查询</strong> (如果能够保证 <code>id</code> 连续递增)</p>
<p>查询的过程中，会走主键索引，加快查询速度。但是高并发的情况下，可能出现数据重复或者遗漏的情况。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="o">#</span><span class="w"> </span><span class="err">可以通过记录上次查询结果的最后一条记录进行下一页的查询</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="k">user</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1000000</span><span class="w"> </span><span class="k">LIMIT</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p><strong>子查询</strong></p>
<p>通过子查询来获取 <code>id</code> 的起始值，把 limit 2000000 的条件转移到子查询。 查询过程如下：</p>
<ol>
<li>子查询语句利用id的主键索引快速找到这条记录，然后定位到 <code>1000001</code> 这条记录的主键</li>
<li>主查询语句将子查询返回的起始 <code>ID</code> 作为过滤条件，然后使用查询条件过滤掉前面的数据</li>
</ol>
<p>可以减少全表扫描，提高性能。但是，子查询会生成临时表，复杂场景会导致性能下降。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="k">user</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">SELECT</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="k">user</span><span class="w"> </span><span class="k">order</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="k">limit</span><span class="w"> </span><span class="mi">1000000</span><span class="p">,</span><span class="mi">1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">)</span><span class="w"> </span><span class="k">LIMIT</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p><strong>延迟关联</strong></p>
<p>和子查询类似，将<code>limit</code> 操作转移到主键索引上，让其减少回表次数来优化查询 (只查询<code>id</code>不用回表)。然后将子查询中的结果合并到主查询当中，避免创建临时表。整体性能比子查询好。查询过程如下:</p>
<ol>
<li>子查询语句利用 <code>id</code> 的主键索引来快速找到符合条件的前10条记录的<code>id</code></li>
<li>通过<code>inner join</code> 内连接将<code>id</code> 和 主表进行关联，获取完整记录</li>
</ol>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="w"> </span><span class="k">select</span><span class="w"> </span><span class="k">user</span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="k">user</span><span class="w"> </span><span class="n">t1</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="k">inner</span><span class="w"> </span><span class="k">join</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="p">(</span><span class="k">SELECT</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="k">user</span><span class="w"> </span><span class="k">order</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="k">limit</span><span class="w"> </span><span class="mi">1000000</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">)</span><span class="w"> </span><span class="n">t2</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">t1</span><span class="p">.</span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t2</span><span class="p">.</span><span class="n">id</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p><strong>覆盖索引</strong>：</p>
<p>覆盖索引包含所有需要查询的字段(都是索引的，可以避免回表操作</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="c1">-- 覆盖索引查询
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="k">SELECT</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="k">user</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="k">limit</span><span class="w"> </span><span class="mi">1000000</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="w">
</span></span></span></code></pre></div></li>
</ol>
<table>
  <thead>
      <tr>
          <th>优化方法</th>
          <th>适用场景</th>
          <th>优点</th>
          <th>缺点</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>范围查询</strong></td>
          <td>主键或索引字段，连续性高</td>
          <td>简单高效，减少扫面范围</td>
          <td>不适用于非主键字段; 如果有高并发，可能会出现数据重复或者遗漏的情况。</td>
      </tr>
      <tr>
          <td><strong>子查询</strong></td>
          <td>偏移量大，索引列存在</td>
          <td>利用索引快速定位，减少全表扫描</td>
          <td>需要创建临时表，增加开销，复杂场景性能下降</td>
      </tr>
      <tr>
          <td><strong>延迟关联</strong></td>
          <td>主键索引存在，查询字段多</td>
          <td>减少回表次数</td>
          <td>查询逻辑复杂</td>
      </tr>
      <tr>
          <td><strong>覆盖索引</strong></td>
          <td>需要查询字段都包含在索引里面</td>
          <td>无需回表查询，查询效率高</td>
          <td>只能用于简单字段查询，查询的字段有优先</td>
      </tr>
  </tbody>
</table>
<p><strong>【如果出现表分页怎么办】</strong></p>
<p>假如出现表分页，比如现在有表1和表2。表1中按<code>score</code>字段排序为<code>100,90,80</code>，表2中按<code>score</code>字段排序为<code>95,85,75</code>。然后适用<code>select score from student_info limit 1, 2 </code> 查询出来的是 <code>90</code> (表1) 和 <code>85</code> (表2)的合并结果。</p>
<p><strong>解决方案</strong>：将分页条件改写为<code>limit 0, 3</code>，取出所有前两页数据，再结合排序条件计算出正确的数据。如果遇到表分页的情况，必须从<code>offset = 0</code>的地方开始查询，避免漏掉数据。</p>
<p><img alt="表分页深度分页问题" loading="lazy" src="https://oss.swimmingliu.cn/31655ccd-f63f-11ef-8e1d-c858c0c1deba"></p>
<h2 id="32-什么是-mysql-的主从同步机制它是如何实现的">32. 什么是 MySQL 的主从同步机制？它是如何实现的？<a hidden class="anchor" aria-hidden="true" href="#32-什么是-mysql-的主从同步机制它是如何实现的">#</a></h2>
<ol>
<li><strong>主从同步机制</strong>: 将主数据库上的数据同步到多个从数据库中的技术</li>
<li><strong>为什么会有主从同步?</strong>: 因为如果MySQL只有一个数据库，当数据库文件损坏了，所有的数据都没了。为了防止这种单台故障，就有了主从数据库。主从数据库之间为了保持数据一致，就有了主从同步。</li>
</ol>
<p><strong>【主从同步的流程】</strong></p>
<ol>
<li><strong>从服务器创建线程</strong>: 从服务器开启主从复制之后，创建I/O线程和SQL线程</li>
<li><strong>从服器和住服务器建立连接</strong>：从服务器的I/O线程和主服务器建立连接，主服务器的<code>binlog dump</code> 线程和从服务器进行交互</li>
<li><strong>从服务器告知同步位置</strong>：从服务器的I/O线程会告知住服务器的 <code>dump</code> 线程从哪里开始接受 <code>binlog</code>。</li>
<li>**主服务器更新<code>binlog</code>：**主服务器把所有的更新记录从<code>Page Cache</code> 写入<code>binlog</code> 文件 (有三种格式：<code>statement</code>、<code>row</code>、<code>mixed</code>)</li>
<li><strong><code>dump</code>线程控制<code>binlog</code>传输：</strong> 主服务器的<code>dump</code>线程检测到<code>binlog</code>变化，从指定位置读取。从服务器的I/O线程开始拉取<code>binlog</code> 文件，采用拉取模式有利于从库管理同步进度和处理延迟</li>
<li><strong>中继存储到<code>relay log</code>：</strong> 从服务器的I/O线程将接收到的来自<code>binlog</code>中的内容，存储到<code>relay log</code></li>
<li><strong>重放<code>relay log</code>，写入数据</strong>：从服务器的SQL线程读取<code>relay log</code> 内容，解析成具体操作之后写入到对应的表中</li>
</ol>
<p><img alt="MySQL主从数据库同步流程图" loading="lazy" src="https://oss.swimmingliu.cn/318f7c22-f63f-11ef-b818-c858c0c1deba"></p>
<p><strong>【主从同步的三种方式】</strong></p>
<table>
  <thead>
      <tr>
          <th>同步模式</th>
          <th>说明</th>
          <th>优点</th>
          <th>缺点</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>异步复制(默认)</strong></td>
          <td>主库执行完事务马上给客户端返回，从库异步进行复制操作。</td>
          <td>性能高</td>
          <td>数据一致性低</td>
      </tr>
      <tr>
          <td><strong>同步复制</strong></td>
          <td>主库执行完事务等待从库复制完的信息，然后再给客户端返回</td>
          <td>数据一致性高</td>
          <td>性能较差，延迟大</td>
      </tr>
      <tr>
          <td><strong>半同步复制</strong></td>
          <td>主库执行完事务等待指定个数的从库复制完信息，然后给客户端返回</td>
          <td>数据一致性和性能都居中</td>
          <td>仍有丢失数据的可能</td>
      </tr>
  </tbody>
</table>
<p>下面图片就是半同步复制/同步复制的过程，半同步复制可以设置检查从库的个数</p>
<p><img alt="MySQL事务执行过程" loading="lazy" src="https://oss.swimmingliu.cn/31a78c8c-f63f-11ef-9fa0-c858c0c1deba"></p>
<p><strong>【从数据库的并行复制】</strong></p>
<p>从数据库默认是按照顺序逐条执行<code>binlog</code>的日志指令(也就是重放<code>relay log</code>)，但是串行执行可能导致从库的复制数据赶不上主库，所以就出现了下面的几种并行复制模式</p>
<table>
  <thead>
      <tr>
          <th><strong>并行复制模式</strong></th>
          <th>特点</th>
          <th>优缺点</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>MySQL 5.6 库级别并行</strong></td>
          <td>将不同数据库<code>db1</code>和<code>db2</code>的事务同时分开执行</td>
          <td>事务都在同一个库时，失效</td>
      </tr>
      <tr>
          <td><strong>MySQL 5.7 组提交事务</strong></td>
          <td>将组提交的事务当作独立的事务，多线程并行执行</td>
          <td>如果事务的<code>last_commited</code>相同，则说明再同一个组提交的，即便不冲突，也不能并发执行</td>
      </tr>
      <tr>
          <td><strong>MySQL 5.7 逻辑时钟</strong></td>
          <td>给<code>prepare</code>阶段的不存在锁冲突的事务打上时间标记<code>sequece_number</code>，后面直接提交</td>
          <td><code>sequence_number</code>就是<code>last_commited</code>，假如这个值相同，不冲突，也不能并发</td>
      </tr>
      <tr>
          <td><strong>MySQL 8.0 WriteSet</strong></td>
          <td>WriteSet可以通过哈希算法对主键生成标识，来判断事务之间是否冲突，不冲突就可以并行复制</td>
          <td>可能实现起来比较复杂</td>
      </tr>
  </tbody>
</table>
<h2 id="33-如何处理-mysql-的主从同步延迟">33. 如何处理 MySQL 的主从同步延迟？<a hidden class="anchor" aria-hidden="true" href="#33-如何处理-mysql-的主从同步延迟">#</a></h2>
<p>首先，MySQL的主从同步是一定存在延迟的。主从同步延迟是指主库更新完成之后，从库还没来得及更新，导致主从数据不一致。这种延迟对一些实时数据需求高的业务场景(比如金融系统)会造成影响。</p>
<p><strong>【为什么有主从同步延迟】</strong></p>
<p>从整体上看，有下面两个原因：</p>
<ol>
<li><strong><code>relay log</code>赶不上<code>binlog</code></strong>: 从库接受<code>binlog</code>的速度跟不上主库写入<code>binlog</code>的速度，从库的<code>redo log</code>就会比主库的<code>binlog</code>滞后</li>
<li><strong>SQL执行赶不上<code>relay log</code></strong>: 从库SQL线程执行<code>relay log</code>的速度比不上I/O线程接受<code>binlog</code>的速度，导致从库滞后<code>relay log</code></li>
</ol>
<p>导致上面两个情况发送的原因可能是：</p>
<ol>
<li><strong>从库性能不足</strong>：CPU、内存、磁盘I/O比主库差一些，同步速度慢</li>
<li><strong>从库读请求多</strong>：要分配一部分资源去满足读请求，影响同步的效率</li>
<li><strong>主库提交太多大事务</strong>：从库去同步一个大事务需要较长的时间</li>
<li><strong>从库数量过多</strong>：主库推送<code>binlog</code>开销大，导致延迟</li>
<li><strong>网络延迟</strong>：主库和从库之间的网络延迟比较大，导致同步速度受限制</li>
<li><strong>复制模式</strong>：默认采用异步复制模式，主库不等待从库完成复制，肯定有延迟</li>
</ol>
<p><strong>【避免延迟的方法】</strong></p>
<ol>
<li>
<p><strong>强行把写入后的读请求交给主库处理 （不推荐）</strong>: 把写入后的读请求给主库处理，可以避免主从延迟，但是主库承受的压力也会增大</p>
</li>
<li>
<p><strong>用半同步复制</strong>：半同步复制可以保证至少有一个从库复制完成了</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">SET</span><span class="w"> </span><span class="k">GLOBAL</span><span class="w"> </span><span class="n">rpl_semi_sync_master_enabled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">SET</span><span class="w"> </span><span class="k">GLOBAL</span><span class="w"> </span><span class="n">rpl_semi_sync_slave_enabled</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p><strong>优化主从结构</strong></p>
<ul>
<li>提升从库性能：配好一点的CPU、内存、磁盘I/O</li>
<li>减少从库数量：减少主库的同步开销</li>
<li>拆分读流量：把读请求负载均衡到多个从库上</li>
</ul>
</li>
<li>
<p><strong><code>sleep</code>方案</strong>：假设主从库的延迟为<code>1s</code>，可以每次执行一个 <code>select sleep(1)</code>， 保证拿到最新的数据。</p>
</li>
</ol>
<h2 id="34-mysql中的长事务可能会导致哪些问题">34. MySQL中的长事务可能会导致哪些问题？<a hidden class="anchor" aria-hidden="true" href="#34-mysql中的长事务可能会导致哪些问题">#</a></h2>
<ol>
<li><strong>长时间的锁竞争，阻塞资源</strong>：长事务持有的锁时间比较长，容易导致其他事务再获取相同锁的时候，发送阻塞，增加系统的等待时间和降低并发性能。业务线程会因为长时间的数据库请求而被阻塞，部分业务的阻塞会影响到其他的业务，导致产生雪崩。最终可能会让服务全面崩盘，导致严重的线上事故。</li>
<li><strong>死锁风险</strong>：长事务更容易产生死锁，因为可能存在多个事务在互相等待对方释放锁，导致系统死锁。</li>
<li><strong>主从延迟</strong>：长事务容易导致主从延迟，因为长事务需要主库花更长的时间执行，然后通过<code>binlog</code>传给从库。从库读取<code>relay log</code>的时候，重发操作又需要一长段时间，可能导致一大段时间数据是不同步的。</li>
<li><strong>回滚导致时间浪费</strong>：如果事务执行了很长一段时间，突然执行出错，需要事务回滚，之前的执行都浪费了，耗费时间。</li>
<li><strong>版本链过长</strong>：假如事务A对某条数据执行了<code>10000</code>次修改操作，在没有提交之前，事务B进行<code>select</code> 操作，会需要耗费很长的时间。</li>
</ol>
<p><strong>【长事务的SQL如何处理】</strong></p>
<ol>
<li>
<p><strong>拆分长事务SQL</strong>: 把单条SQL拆分为多条短事务SQL</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="o">#</span><span class="w"> </span><span class="err">假如需要删除</span><span class="mi">2021</span><span class="err">年的数据</span><span class="p">(</span><span class="mi">4</span><span class="p">.</span><span class="mi">8</span><span class="err">亿条</span><span class="p">)</span><span class="err">，共</span><span class="mi">5</span><span class="err">亿条数据</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">delete</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">yes</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">create_date</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="s2">&#34; 2020-12-31&#34;</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">create_date</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="s2">&#34;2022-01-01&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="o">#</span><span class="w"> </span><span class="err">按照日期进行拆分成多条事务</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">delete</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">yes</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">create_date</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="s2">&#34; 2020-12-31&#34;</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">create_date</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="s2">&#34;2021-02-01&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">....</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">delete</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">yes</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">create_date</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="s2">&#34; 2021-11-31&#34;</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="n">create_date</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="s2">&#34;2022-01-01&#34;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div></li>
<li>
<p><strong>反向操作减轻事务时间</strong>：把需要旧表删除的数据转成新增到新的表，然后用新表替换旧表就可以了。</p>
</li>
</ol>


  </div>



  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://swimmingliu.cn/tags/java/">Java</a></li>
      <li><a href="https://swimmingliu.cn/tags/mysql/">MySQL</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://swimmingliu.cn/posts/job/java-basic-interview-questions/">
    <span class="title">« Prev</span>
    <br>
    <span>Java基础题面试笔记</span>
  </a>
  <a class="next" href="https://swimmingliu.cn/posts/job/java-interview-questions-notes/">
    <span class="title">Next »</span>
    <br>
    <span>Java面试题-随手记</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2023-2025 <a href="https://swimmingliu.cn/">SwimmingLiu&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
    <span>
        <a href="https://beian.miit.gov.cn/">浙ICP备2024056260号</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>


  <script type="module">
    import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
    mermaid.initialize({ startOnLoad: true });
  </script>

