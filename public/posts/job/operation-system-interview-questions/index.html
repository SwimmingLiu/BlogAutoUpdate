<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>操作系统面试题笔记 | SwimmingLiu&#39;s Blog</title>
<meta name="keywords" content="Java, OS">
<meta name="description" content="1. 说说你知道的几种 I/O 模型
【常见的五大I/O模型】
常见的五大I/O模式分别为: 同步阻塞I/O (Blocking I/O) BIO、非阻塞I/O (Non-blocking I/O) NIO、I/O多路复用、信号量驱动I/O、异步I/O AIO
我们假如要烧水喝，看不同模型是怎么烧的水喝

  
      
          I/O 模型
          特性
          烧水案例
      
  
  
      
          同步阻塞I/O BIO
          数据从网卡到内核，再从内核到用户空间，都是阻塞操作。
          自己动手烧水，一直盯着，等水烧开了，倒在杯子里喝。
      
      
          非阻塞I/O NIO
          数据从网卡到内核不阻塞，read不到数据直接返回，但是从内核到用户空间会阻塞 (用户轮询read)
          自己动手烧水，隔两分钟看一下，水烧开没有。等水烧开了，倒在杯子里喝。
      
      
          I/O多路复用
          只有一个线程查看多个连接是否有数据准备就绪 (看从网卡能不能read到数据到内核)
          找专门烧水的领居帮忙，他把水烧好了之后，会喊你来拿。但是你要自己倒在杯子里喝。
      
      
          信号驱动I/O
          数据从网卡到内核之后会自动通知用户程序，然后让他read读取数据
          去烧水房烧水，全自动的，有个通知灯。水烧完了之后会按你家的门铃，但是有客人来了，也会按门铃
      
      
          异步I/O AIO
          全程不阻塞，拷贝到用户空间之后直接回调。
          和多路复用类似，但是烧完水之后不用自己倒水，他帮你倒好了，还吹凉了，你过来喝就行。
      
  


【为什么会产生各种I/O】
下图是两个不同主机上，应用程序传递数据的过程，借助该过程来理解 I/O 是如何产生的

DMA（直接内存访问）是一种不经过CPU直接在网络适配器（网卡）和主机内存之间进行数据传输的机制，用于提升数据传输效率。

【同步阻塞 I/O BIO】
同步阻塞I/O BIO 的工作机制：应用程序被阻塞，直到数据复制到应用进程的缓冲区才返回。阻塞并意味着整个操作系统都被阻塞。其他程序还可以执行，不消耗CPU事件。同步阻塞 I/O BIO 中，应用程序发起 read 调用来读取数据之后，一直被阻塞，直到内核把数据copy到用户空间。该方案适合客户端连接数量不高的情况。下图的read 和 recvfrom 函数是一个意思。

【非阻塞式  I/O NIO】
非阻塞式  I/O NIO 的工作机制：应用程序执行read 系统调用之后，内核返回一个错误码。应用程序可以继续执行，但是需要不断的轮询 read 来获取 I/O是否完成，这种方式称之为 轮询 polling 。等到数据准备就绪，从内核空间copy到用户空间的时候，进程才被阻塞，直到内核copy完成。该方案比较低效，会不停的消耗CPU资源。">
<meta name="author" content="SwimmingLiu">
<link rel="canonical" href="https://swimmingliu.cn/posts/job/operation-system-interview-questions/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.6ecbb0040febd20e47edd88a662c19f1ea945bf7427774b86594271d18f88faf.css" integrity="sha256-bsuwBA/r0g5H7diKZiwZ8eqUW/dCd3S4ZZQnHRj4j68=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<link rel="apple-touch-icon" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<link rel="mask-icon" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://swimmingliu.cn/posts/job/operation-system-interview-questions/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ],
            
            throwOnError: false
        });
    });
</script>


+
+<meta property="og:url" content="https://swimmingliu.cn/posts/job/operation-system-interview-questions/">
  <meta property="og:site_name" content="SwimmingLiu&#39;s Blog">
  <meta property="og:title" content="操作系统面试题笔记">
  <meta property="og:description" content="1. 说说你知道的几种 I/O 模型 【常见的五大I/O模型】
常见的五大I/O模式分别为: 同步阻塞I/O (Blocking I/O) BIO、非阻塞I/O (Non-blocking I/O) NIO、I/O多路复用、信号量驱动I/O、异步I/O AIO
我们假如要烧水喝，看不同模型是怎么烧的水喝
I/O 模型 特性 烧水案例 同步阻塞I/O BIO 数据从网卡到内核，再从内核到用户空间，都是阻塞操作。 自己动手烧水，一直盯着，等水烧开了，倒在杯子里喝。 非阻塞I/O NIO 数据从网卡到内核不阻塞，read不到数据直接返回，但是从内核到用户空间会阻塞 (用户轮询read) 自己动手烧水，隔两分钟看一下，水烧开没有。等水烧开了，倒在杯子里喝。 I/O多路复用 只有一个线程查看多个连接是否有数据准备就绪 (看从网卡能不能read到数据到内核) 找专门烧水的领居帮忙，他把水烧好了之后，会喊你来拿。但是你要自己倒在杯子里喝。 信号驱动I/O 数据从网卡到内核之后会自动通知用户程序，然后让他read读取数据 去烧水房烧水，全自动的，有个通知灯。水烧完了之后会按你家的门铃，但是有客人来了，也会按门铃 异步I/O AIO 全程不阻塞，拷贝到用户空间之后直接回调。 和多路复用类似，但是烧完水之后不用自己倒水，他帮你倒好了，还吹凉了，你过来喝就行。 【为什么会产生各种I/O】
下图是两个不同主机上，应用程序传递数据的过程，借助该过程来理解 I/O 是如何产生的
DMA（直接内存访问）是一种不经过CPU直接在网络适配器（网卡）和主机内存之间进行数据传输的机制，用于提升数据传输效率。
【同步阻塞 I/O BIO】
同步阻塞I/O BIO 的工作机制：应用程序被阻塞，直到数据复制到应用进程的缓冲区才返回。阻塞并意味着整个操作系统都被阻塞。其他程序还可以执行，不消耗CPU事件。同步阻塞 I/O BIO 中，应用程序发起 read 调用来读取数据之后，一直被阻塞，直到内核把数据copy到用户空间。该方案适合客户端连接数量不高的情况。下图的read 和 recvfrom 函数是一个意思。
【非阻塞式 I/O NIO】
非阻塞式 I/O NIO 的工作机制：应用程序执行read 系统调用之后，内核返回一个错误码。应用程序可以继续执行，但是需要不断的轮询 read 来获取 I/O是否完成，这种方式称之为 轮询 polling 。等到数据准备就绪，从内核空间copy到用户空间的时候，进程才被阻塞，直到内核copy完成。该方案比较低效，会不停的消耗CPU资源。">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-03-01T09:49:44+08:00">
    <meta property="article:modified_time" content="2025-03-01T09:49:44+08:00">
    <meta property="article:tag" content="Java">
    <meta property="article:tag" content="OS">
      <meta property="og:image" content="https://swimmingliu.cn/papermod-cover.png">

+<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://swimmingliu.cn/papermod-cover.png">
<meta name="twitter:title" content="操作系统面试题笔记">
<meta name="twitter:description" content="1. 说说你知道的几种 I/O 模型
【常见的五大I/O模型】
常见的五大I/O模式分别为: 同步阻塞I/O (Blocking I/O) BIO、非阻塞I/O (Non-blocking I/O) NIO、I/O多路复用、信号量驱动I/O、异步I/O AIO
我们假如要烧水喝，看不同模型是怎么烧的水喝

  
      
          I/O 模型
          特性
          烧水案例
      
  
  
      
          同步阻塞I/O BIO
          数据从网卡到内核，再从内核到用户空间，都是阻塞操作。
          自己动手烧水，一直盯着，等水烧开了，倒在杯子里喝。
      
      
          非阻塞I/O NIO
          数据从网卡到内核不阻塞，read不到数据直接返回，但是从内核到用户空间会阻塞 (用户轮询read)
          自己动手烧水，隔两分钟看一下，水烧开没有。等水烧开了，倒在杯子里喝。
      
      
          I/O多路复用
          只有一个线程查看多个连接是否有数据准备就绪 (看从网卡能不能read到数据到内核)
          找专门烧水的领居帮忙，他把水烧好了之后，会喊你来拿。但是你要自己倒在杯子里喝。
      
      
          信号驱动I/O
          数据从网卡到内核之后会自动通知用户程序，然后让他read读取数据
          去烧水房烧水，全自动的，有个通知灯。水烧完了之后会按你家的门铃，但是有客人来了，也会按门铃
      
      
          异步I/O AIO
          全程不阻塞，拷贝到用户空间之后直接回调。
          和多路复用类似，但是烧完水之后不用自己倒水，他帮你倒好了，还吹凉了，你过来喝就行。
      
  


【为什么会产生各种I/O】
下图是两个不同主机上，应用程序传递数据的过程，借助该过程来理解 I/O 是如何产生的

DMA（直接内存访问）是一种不经过CPU直接在网络适配器（网卡）和主机内存之间进行数据传输的机制，用于提升数据传输效率。

【同步阻塞 I/O BIO】
同步阻塞I/O BIO 的工作机制：应用程序被阻塞，直到数据复制到应用进程的缓冲区才返回。阻塞并意味着整个操作系统都被阻塞。其他程序还可以执行，不消耗CPU事件。同步阻塞 I/O BIO 中，应用程序发起 read 调用来读取数据之后，一直被阻塞，直到内核把数据copy到用户空间。该方案适合客户端连接数量不高的情况。下图的read 和 recvfrom 函数是一个意思。

【非阻塞式  I/O NIO】
非阻塞式  I/O NIO 的工作机制：应用程序执行read 系统调用之后，内核返回一个错误码。应用程序可以继续执行，但是需要不断的轮询 read 来获取 I/O是否完成，这种方式称之为 轮询 polling 。等到数据准备就绪，从内核空间copy到用户空间的时候，进程才被阻塞，直到内核copy完成。该方案比较低效，会不停的消耗CPU资源。">

+

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "📚 Posts",
      "item": "https://swimmingliu.cn/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "💻 Job",
      "item": "https://swimmingliu.cn/posts/job/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "操作系统面试题笔记",
      "item": "https://swimmingliu.cn/posts/job/operation-system-interview-questions/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "操作系统面试题笔记",
  "name": "操作系统面试题笔记",
  "description": "1. 说说你知道的几种 I/O 模型 【常见的五大I/O模型】\n常见的五大I/O模式分别为: 同步阻塞I/O (Blocking I/O) BIO、非阻塞I/O (Non-blocking I/O) NIO、I/O多路复用、信号量驱动I/O、异步I/O AIO\n我们假如要烧水喝，看不同模型是怎么烧的水喝\nI/O 模型 特性 烧水案例 同步阻塞I/O BIO 数据从网卡到内核，再从内核到用户空间，都是阻塞操作。 自己动手烧水，一直盯着，等水烧开了，倒在杯子里喝。 非阻塞I/O NIO 数据从网卡到内核不阻塞，read不到数据直接返回，但是从内核到用户空间会阻塞 (用户轮询read) 自己动手烧水，隔两分钟看一下，水烧开没有。等水烧开了，倒在杯子里喝。 I/O多路复用 只有一个线程查看多个连接是否有数据准备就绪 (看从网卡能不能read到数据到内核) 找专门烧水的领居帮忙，他把水烧好了之后，会喊你来拿。但是你要自己倒在杯子里喝。 信号驱动I/O 数据从网卡到内核之后会自动通知用户程序，然后让他read读取数据 去烧水房烧水，全自动的，有个通知灯。水烧完了之后会按你家的门铃，但是有客人来了，也会按门铃 异步I/O AIO 全程不阻塞，拷贝到用户空间之后直接回调。 和多路复用类似，但是烧完水之后不用自己倒水，他帮你倒好了，还吹凉了，你过来喝就行。 【为什么会产生各种I/O】\n下图是两个不同主机上，应用程序传递数据的过程，借助该过程来理解 I/O 是如何产生的\nDMA（直接内存访问）是一种不经过CPU直接在网络适配器（网卡）和主机内存之间进行数据传输的机制，用于提升数据传输效率。\n【同步阻塞 I/O BIO】\n同步阻塞I/O BIO 的工作机制：应用程序被阻塞，直到数据复制到应用进程的缓冲区才返回。阻塞并意味着整个操作系统都被阻塞。其他程序还可以执行，不消耗CPU事件。同步阻塞 I/O BIO 中，应用程序发起 read 调用来读取数据之后，一直被阻塞，直到内核把数据copy到用户空间。该方案适合客户端连接数量不高的情况。下图的read 和 recvfrom 函数是一个意思。\n【非阻塞式 I/O NIO】\n非阻塞式 I/O NIO 的工作机制：应用程序执行read 系统调用之后，内核返回一个错误码。应用程序可以继续执行，但是需要不断的轮询 read 来获取 I/O是否完成，这种方式称之为 轮询 polling 。等到数据准备就绪，从内核空间copy到用户空间的时候，进程才被阻塞，直到内核copy完成。该方案比较低效，会不停的消耗CPU资源。\n",
  "keywords": [
    "Java", "OS"
  ],
  "articleBody": "1. 说说你知道的几种 I/O 模型 【常见的五大I/O模型】\n常见的五大I/O模式分别为: 同步阻塞I/O (Blocking I/O) BIO、非阻塞I/O (Non-blocking I/O) NIO、I/O多路复用、信号量驱动I/O、异步I/O AIO\n我们假如要烧水喝，看不同模型是怎么烧的水喝\nI/O 模型 特性 烧水案例 同步阻塞I/O BIO 数据从网卡到内核，再从内核到用户空间，都是阻塞操作。 自己动手烧水，一直盯着，等水烧开了，倒在杯子里喝。 非阻塞I/O NIO 数据从网卡到内核不阻塞，read不到数据直接返回，但是从内核到用户空间会阻塞 (用户轮询read) 自己动手烧水，隔两分钟看一下，水烧开没有。等水烧开了，倒在杯子里喝。 I/O多路复用 只有一个线程查看多个连接是否有数据准备就绪 (看从网卡能不能read到数据到内核) 找专门烧水的领居帮忙，他把水烧好了之后，会喊你来拿。但是你要自己倒在杯子里喝。 信号驱动I/O 数据从网卡到内核之后会自动通知用户程序，然后让他read读取数据 去烧水房烧水，全自动的，有个通知灯。水烧完了之后会按你家的门铃，但是有客人来了，也会按门铃 异步I/O AIO 全程不阻塞，拷贝到用户空间之后直接回调。 和多路复用类似，但是烧完水之后不用自己倒水，他帮你倒好了，还吹凉了，你过来喝就行。 【为什么会产生各种I/O】\n下图是两个不同主机上，应用程序传递数据的过程，借助该过程来理解 I/O 是如何产生的\nDMA（直接内存访问）是一种不经过CPU直接在网络适配器（网卡）和主机内存之间进行数据传输的机制，用于提升数据传输效率。\n【同步阻塞 I/O BIO】\n同步阻塞I/O BIO 的工作机制：应用程序被阻塞，直到数据复制到应用进程的缓冲区才返回。阻塞并意味着整个操作系统都被阻塞。其他程序还可以执行，不消耗CPU事件。同步阻塞 I/O BIO 中，应用程序发起 read 调用来读取数据之后，一直被阻塞，直到内核把数据copy到用户空间。该方案适合客户端连接数量不高的情况。下图的read 和 recvfrom 函数是一个意思。\n【非阻塞式 I/O NIO】\n非阻塞式 I/O NIO 的工作机制：应用程序执行read 系统调用之后，内核返回一个错误码。应用程序可以继续执行，但是需要不断的轮询 read 来获取 I/O是否完成，这种方式称之为 轮询 polling 。等到数据准备就绪，从内核空间copy到用户空间的时候，进程才被阻塞，直到内核copy完成。该方案比较低效，会不停的消耗CPU资源。\n【I/O 多路复用】\nI/O 多路复用是一种支持面向缓存的，基于通道I/O的操作方法，它是基于同步非阻塞I/O设计的。适合高负载、高并发应用。I/O 复用是通过 select 或者 poll 机制，让单个进程能够同时处理多个套接字的读写事件。当任一套接字可读的时候，被阻塞的进程会被唤醒并继续执行。和多进程或者多线程方案相比， I/O 复用避免了创建和切换 进程/线程带来的额外开销。在没有I/O复用的情况下，每次建立一个新的 Socket 连接 都需要单独启动一个线程来处理。\n【注意】I/O 多路复用相较于同步非阻塞I/O NIO 少了轮询调用 read 的操作 (轮询polling)， 减少了CPU资源的消耗。复用同一个线程，处理多个socket 中的事件，防止创建过多线程导致的上下文切换的开销。\nI/O 复用的具体工作流程：\n线程首先发起 select 调用，询问内核数据是否准备就绪 等待内核把数据准备好，用户线程再发起read 调用 数据从内核空间copy到用户空间，该过程应用程序还是阻塞的 【信号驱动 I/O】\n使用 sigaction 系统调用，内核立即返回。应用程序继续执行，内核等待数据准备就绪之后，发送 SIGIO 信号。应用程序受到信号之后，开始 read 系统调用，数据从内核空间复制到用户空间，该过程应用程序阻塞。 和 I/O 多路复用比较相似。\n【异步 I/O AIO】\n异步 I/O AIO 是基于事件和回调机制实现的，应用程序 read 系统调用之后，直接返回，完全不阻塞。当后台处理完之后，操作系统通知相应的线程进行后续的操作。\n【五大 I/O 模型比较】\n2. Select、Poll、Epoll 之间有什么区别？ 特性 select poll epoll 触发机制 水平触发 水平触发 边缘触发 文件描述符存储方式 位图 动态数组 红黑书 + 就绪链表 性能 随着文件描述符量增加，性能下降 ( O(N) ) 随着文件描述符量增加，性能下降( O(N) ) 监听列表为 O(1) ，调用事件回调 o(k) 【水平触发和边缘触发的区别】\n边缘触发：事件发生的时候只通知一次，需要用户立即处理，如果没有处理，后续不会再通知 水平触发：事件发生的时候会反复通知，直到处理完成 3. 线程和进程有什么区别？ 进程 (Process)：进程是运行中的程序实例，拥有独立的内存空间和系统资源。比如打开的微信/抖音/微博，都是一个单独的进程。\n线程 (Thread)：线程也叫轻量级的进程，比进程轻量。一般来说，一个进程里面有多个线程同时执行，并且共享进程的资源。在 Linux 当中，线程可以共享内存空间、文件句柄、网络连接等。\n协程：用户态轻量级线程，由程序控制切换，无需内核参与。协程切换只需要保存和恢复上下文，开销比线程小得多，适合处理高并发任务（比如异步I/O）\n【注意】 多线程不是越多越好，因为线程越多就会增加切换成本，可能导致系统负载过高。而且需要同步机制避免数据竞争和死锁问题。\n【进程和线程的区别】\n特性 进程 线程 本质 操作系统进行资源分配的基本单元 构成任务调度与执行的核心单元 开销 独立的代码和数据段，进程切换成本高 线程共享进程的资源，维护独立的堆栈和程序计数器，线程切换成本低 内存分配 每个进程分配独立的内存空间 除了CPU之外，系统不会给线程分配内存，线程组共享资源 稳定性 进程隔离性强，崩溃时不会影响其他进程 线程共享进程资源，崩溃可能导致整个进程异常终止 安全性 有独立的内存空间，安全性高 多个线程共享内存空间，存在数据竞争和线程安全的问题，需要用同步和互斥机制来解决 【JVM 视角下的进程和线程】\n一个进程可以有多个线程，多个线程之间共享堆和方法区 (元空间)，但是各自有独立的程序计数器、虚拟机栈和本地方法栈，确保线程间执行的上下文彼此隔离。\n线程共享数据区：堆、方法区 ( JDK8 之后叫元空间)、执行引擎 线程隔离区域：程序计数器、虚拟机栈、本地方法栈、每个线程都有独立的脚本 【进程切换和线程切换的区别】\n时间效率：线程切换比进程切换快，因为线程共享地址空间，而进程需要切换页面和上下文（涉及更多资源） 空间效率：线程共享内存和文件资源，数据交换不需要内核参与，效率更高；进程切换涉及更复杂的上下文保存和恢复。 【进程和线程切换的上下文是什么？】\n进程控制块 (process control block) PCB 数据结构是用来描述进程的\nPCB是进程存在的唯一标识，其中包含\nPCB内容：进程唯一标识符、状态信息（创建、就绪、运行、阻塞、结束）、优先级、资源分配清单（内存和文件句柄）、CPU寄存器值等 进程状态变迁：创建、就绪、运行、阻塞、结束，五种状态当中进行切换 【进程的上下文切换】\n进程的上下文：包含虚拟内存、栈、全局变量 等用户空间的资源，还包括内核堆栈、寄存器等内核空间的资源。\n进程上下文切换：将上一个进程 进程A 的上下文保存到当前进程 进程B 的PCB中，当需要运行另外一个进程 进程A 的时候，需要从 进程B 的PCB取出上下文，恢复到CPU中，使得 进程A 可以从中断点继续执行。\n进程切换发生的场景\n时间片用完：某个进程的时间片用完了，进程变为就绪态 资源不足：某个进程所需要的资源不足，会被挂起，变成就绪挂起状态 主动挂起：进程被主动挂起 优先级不足：遇到更高优先级的进程，需要被调度成阻塞状态 硬件中断：突然断电了 【线程的上下文切换】\n不同进程内的线程切换：相当于不同进程之间的上下文切换 （比如两个单线程的进程） 同一个进程内的线程切换：因为虚拟内存是共享的，所以切换的过程中，虚拟内存（堆、方法区、执行引擎）不动，只切换线程的私有数据 （本地方法栈、虚拟机栈）、寄存器等共享的数据 【文件句柄、内存空间、网络连接】\n文件句柄：文件句柄是操作系统给进程打开的每个文件分配的唯一整数标识符，用来跟踪文件的位置、权限等状态信息。比如区餐厅点餐，服务员给一个牌子（桌号）。这个牌子就是句柄，代表你的桌子。服务员不知道你是谁，只能通过桌号，找到你的桌子，给你上菜。\n内存空间：内存空间包含代码段、数据段、堆区、栈区、文件映射段\n代码段：存放二进制可执行代码，通常是只读的 数据段：存放全局变量和静态变量，分为已初始化数据区和未初始化数据区 (BSS段) 堆区：用于动态分配内存 栈区：存放函数的局部变量、参数、返回地址等，大小固定 文件映射段：包括动态库、共享内存等 (mmap 分配内存) 网络连接：Linux里面，网络连接是一种特殊的文件，可以通过文件句柄进行操作。一般是用来两台计算机之间通过网络协议 (TCP/IP) 建立的通信信道。\n4. 进程之间的通信方式有哪些？ 【为什么进程需要进行通信？】\n不同的进程有不同的用户地址空间，进程A的全局变量，进程B是看不到的。进程之间想要交换数据需要通过内核，在内核开辟缓冲区。进程A从用户空间copy数据到内核缓冲区，进程B再从内核缓冲区读走数据，实现进程之间的通信。\n【进程之间的通信方式】\n管道/匿名管道：管道是一种单向通信的方式，用于父进程和子进程之间，或者同一主机上的不同进程之间传递数据。可以是匿名的，也可是命名的。\nps -ef | grep [name] # Linux指令的|就是匿名管道 命名管道：和匿名管道类似，遵循先进先出原则，以磁盘文件的形式存在，可以实现本机任意两个进程的通信。\nmkfifo pipeDemo # 创建命名管道 echo \"Hello! World!\" \u003e pipeDemo # 向管道内写入数据 cat \u003c pipeDemo # 读取pipeDemo管道的数据,显示 Hello! World! 信号：异步的通信方式，通知接受进程某个事件已经发生，一般用于进程之间发送中断或者终止命令。\n信号量：信号量是一种同步原语，用于管理对共享区域的访问，可以用来实现进程间的互斥访问和同步操作。\n消息队列：消息队列是链表形式的，遵循先进先出的原则。允许进程A向进程B发送消息，消息在队列中按照顺序存储。但是读取的过程中，进程B不一定非要按照现金先出的顺序读取，可以随机查询。\n共享内存：共享内存允许多个进程访问同一块内存区域，可以看见其他进程对共享进程的更新，从而实现快速的数据交换。但是需要注意数据同步的问题，避免出现数据一致性问题。\n套接字 (socket)：套接字其实就是协议+IP+端口，允许在网络上的不同主机上面的进程进行通信，比如说微信/飞书发消息。\n文件：进程可以通过读写文件来进行通信，这种方式通常用于进程之间的间接通信，比如临时文件或者共享文件。\n【消息队列详解】\n消息队列就是保存在内核中的消息链表，消息队列的生命周期随内核存在而存在。如果不主动释放或者不关闭系统，则会一直存在。匿名管道的生命周期是随进程存在而存在的，进程结束就销毁了。和管道不同，消息队列不需要其他进程在队列上面等待消息到达，可以随时往消息队列里面写入消息。\n消息队列的缺点：\n通信不及时：因为不需要其他进程在消息队列等着，进程只有轮询检查消息队列，如果有时间间隔，肯定会有没来得及看消息的时候 数据大小存在限制：消息队列不适合传输比较大的数据，而且需要把数据从用户态copy到内核态里面 【共享内存】\n进程A和进程B都拿出一块虚拟地址空间映射到相同物理内存，一个进程写入，另外一个进程就可以马上看到，不用从用户态copy数据到内核态，提高进程间的通信速度。但是需要某种同步机制(比如信号量)来达到进程之间的同步和互斥 （比如进程A需要通过信号量通知进程B，它正在写入）。另外，两个进程写同一个地址，先写的进程会发现内容被覆盖了。\n【信号量机制】\n信号量是用来防止进程之间因为竞争共享资源的，而造成的数据错乱。引入保护机制，使得共享的资源在任意时刻只能被一个进程访问。信号量是整型计数器，用于实现进程间的互斥和同步，不是用来缓存进程之间的通信数据的。信号量有两种操作，P 操作和 V 操作：\nP 操作：将信号量减去1，如果相减之后信号量 \u003c 0，则表明资源被占用。如果信号量 \u003e= 0， 表明资源还可以继续使用 V 操作：将信号量加上1，如果相加之后信号量 \u003c= 0, 说明有阻塞进程，唤醒该进程运行。如果相加之后，信号量 \u003e 0，则表明没有阻塞进程，直接运行。 如果信号量初始化为 1，代表是互斥信号量。如果初始化为 0，代表是同步信号量。\n【基于TCP协议通信的套接字socket编程模型】\nTCP套接字通信 服务端和客户端初始化套接字 socket 的 文件描述符 服务端 bind 绑定 IP 和 端口， listen 监听 ，accept 等客户端进行连接 客户端 connect 向服务端地址和端口发起连接请求 服务端 accpet 返回传输 socket 文件描述符 客户端 write 写入数据，服务端 read 读取 客户端 close 的时候，服务端 read 会读取到 EOF (End of File)， 处理完数据之后，服务端 close 关闭链接 UDP套接字通信：每次通信的时候调用sendto 和 recvfrom()， 都需要传入目标主机的IP地址和端口 5. 进程间的调度算法知道吗？ 先来先服务 (FCFS, First Come First Service)：按照进程到达的先后顺序进行调度，先到达的进程先执行，后达到的进程后执行。就像区银行取钱，挨个排队一样。\n最短作业优先 (SJF, Short Job First)：按照进程的执行时间进行排序，执行时间短的进程优先执行，以减少平均等待时间。但是，可能会出现饥饿现象，执行时间长的程序，可能要等很久才能被执行。可以类比成银行让客户按照办理业务的时间进行排队，依次处理。\n优先级调度：给每个进程分配一个优先级，根据优先级高低进行调度，优先级高的进程先执行。但是，优先级较低的程序需要等很久才能执行，可能会出现饥饿现象。\n时间片轮转 (PR)：将CPU时间分成多个时间片，每个进程轮流占用一个时间片，如果一个进程在该时间片结束的时候还没有执行完成，则将其移到队列末尾，等待下一次调度。\n多级反馈队列调度 (MFQS, Multilevel Feedback Queue Scheduling)：多级的意思是有多个队列，每个队列的优先级从高到低，优先级越高时间片越短（为了避免优先级低的进程被饿死了）。反馈的意思是如果有新的进程进入优先级高的队列的时候，立即停止当前运行的进程，转到优先级最高的队里去从头运行。（让优先级高的队列，得到快速处理的保障）具体工程流程如下：\n设置多个队列，每个队列赋予不同的优先级，优先级从高到低，同时优先级越高的队列，时间片设置的越短 如果有新的进程，会把它放到第一级队列的末尾，按照先来先服务的原则排队等待被调度。如果在第一级队列规定时间片没有运行完成，则将其转入第二级队列末尾，直到完成为止。 当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行的时候，有新进程进入较高优先级的队列，则停止当前运行的进程，并且将其移动到原来队列的队尾。然后从较高优先级队列开始，重复刚才的过程。 6. 网络I/O阻塞的原因？ 网络I/O会被阻塞是因为进行网络数据传输的过程中，操作系统在等待数据的发送或接收完成之前，进程将被挂起，直到数据传输完成之后才恢复进程执行。\n网络I/O阻塞的主要原因：\n等待数据到达或发送完成：当进程尝试从网络套接字 socket 读取数据的时候，如果数据还没到达（数据未就绪），操作系统会让进程进入阻塞状态，直到数据到达为止。同样，数据未能立即发出去的时候，发送操作也可能被阻塞，等待缓冲区有空闲空间。 系统资源有限：当系统资源（网络缓冲区、连接数）被占满的时候，进一步的I/O请求可能会被阻塞，等待资源释放后才能继续。 默认的阻塞行为：大多数网络API (比如recv、send、accept等) 在默认情况下都是阻塞的，调用这些API的时候，如果条件不满足，会让调用者等待，直到I/O操作完成。 7. 什么是用户态和内核态？ 运行模式 权限级别 可执行操作 特点 用户态 较低 不能直接访问硬件或者越权操作，需要通过系统调用让内核执行敏感操作 安全性高，程序出现问题，不会影响系统的稳定性。 内核态 较高 可直接访问硬件资源并执行如内存管理、进程调度等于越权操作 能够高效管理硬件和系统资源 用户态和内核态是 CPU 的状态，描述了CPU在执行指令是的特权级别和范围权限。进程运行的过程当中，可能会因为CPU状态的切换，在用户态和内核态之间更替。\n简单来说，一个进程当中，如果CPU 是用户态就是线程运行进程本身的程序代码，如果 CPU 是内核态就是把线程交给操作系统运行。\nCPU是用户态，进程只能访问自己的存储空间：用户态下，进程不能直接使用系统资源，只能访问自己的存储空间，不能越权访问系统的资源。也不能改变CPU的工作状态（用户态、内核态、空闲状态）。在用户态下，进程无法修改CPU的工作状态。在内核态下，操作系统可以通过修改CPU寄存器的值来切换权限，实现内核态和用户态的切换。 CPU是内核态，进程可以通过os访问系统资源：内核态下，进程可以通过执行操作系统的程序，来直接使用计算机的所有硬件资源。但是，必须从用户态切换到内核态才可以，这样也保证了安全性和稳定性。 【为什么要区分用户态和内核态】\n因为 CPU 的所有指令当中，有部分指令是非常危险的，操作不当就会导致系统崩溃。而且部分指令可能涉及到硬件的操作，参数很多，很容易出问题。所以凡是涉及到 I/O 读写，内存分配等硬件资源的操作的时候，为了保证安全性和稳定性，往往不能让进程直接操作，而是通过系统调用（调用操作系统的程序）让 CPU 从用户态切换到内核态，程序在内核态下面运行。\n其中，CPU 的指令是有权限分级的，不同级别的权限包含不同的 CPU 指令集。比如 InterCPU 把 CPU 的指令集操作权限从高到低分为四个级别：ring0、ring1、ring2、ring3。\n【注意】\nring3 的权限最低，只能使用常规的 CPU 指令集，不能使用操作硬件资源的 CPU 指令集，比如I/O读写、网卡访问、申请内存等操作都不可以。ring0 的权限最高，可以使用所有的 CPU 指令集 Linux系统当中只采用了 ring0 和 ring3 这两个权限。ring0 对应的就是内核态，程序完全在操作系统内核当中运行。ring3 对应的是用户态，程序在自己的存储空间当中运行。 【用户态和内核态的空间】\n在内存资源的使用上，操作系统对用户态和内核态也做了限制。内存结构如下图所示，包含了内核空间和用户空间（程序代码和数据、堆内存、栈内存、命令行参数和环境变量等）。每个进程创建的时候，都会分配虚拟空间地址，和内存结构一样。虚拟空间就记录，对应的在实际内存中存放的位置。虚拟地址空间与物理内存通过**内存管理单元（MMU）和页表（Page Table）**实现动态映射。例如，在Linux ( 32 位系统)下，总共的内存空间是 2^32 bytes = 4GB ，内核态为 1G，用户态为 3G。 **【注意】**内核态的地址空间存放整个内核的代码，所有的内核模块和内核维护的数据，这一部分是所有进程共享的。所有进程的内核态逻辑地址是共享同一块内存地址的。同时 CPU 处于内核态的时候，进程可以操作全部范围的虚拟空间地址，并且属于内核态的高位虚拟空间只有内核态下，程序才能操作。\n【用户态和内核态的切换】\n用户态和内核态的切换具有一定的开销，下面是从用户态切换到内核态的流程（比如发起 I/O 调用）\n保留用户态的现场 （上下文、程序计数器（寄存器）、用户栈） 复制用户参数，从用户栈切换到内核栈，CPU 进入内核态 额外的检查 （因为内核代码对用户是不信任的） 执行内核态中相关的代码 复制内核态代码执行结果，回到用户态 恢复用户态现场（上下文、程序计数器（寄存器）、用户栈） 从用户态主动切换到内核态，需要有入口才行，操作系统提供了统一的入口（系统调用）。系统调用就是一组通用的访问接口，这些接口就叫系统调用。\n【用户态什么时候切换到内核态】\n系统调用：用户态进程通过系统调用向操作系统申请资源完成工作，比如 fork() 创建子进程，就是一个创建新进程的系统调用。系统调用的核心是系草系统为用户特别开放的一个中断来实现的，成为软中断。 异常：当 CPU 在执行用户态的进程的时候，发生了一些没有预知的异常。此时，当前运行进程会切换到处理该异常的内核态中的相关进程，就是从用户态切换到内核态了。比如出现缺页异常 中断：当 CPU 在执行用户态的进程的时候，外围设备完成用户请求的操作之后，会向 CPU 发出相应的中断信号。此时， CPU 会暂停执行下一条即将执行的指令，转到与中断信号对应的内核态下的处理程序去执行，从用户态切换到了内核态。比如硬盘读写完成，系统会切换到硬盘读写的中断处理程序中执行后边的操作。 ",
  "wordCount" : "501",
  "inLanguage": "en",
  "image": "https://swimmingliu.cn/papermod-cover.png","datePublished": "2025-03-01T09:49:44+08:00",
  "dateModified": "2025-03-01T09:49:44+08:00",
  "author":[{
    "@type": "Person",
    "name": "SwimmingLiu"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://swimmingliu.cn/posts/job/operation-system-interview-questions/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "SwimmingLiu's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://swimmingliu.cn/images/swimmingliu_icon.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://swimmingliu.cn/" accesskey="h" title="𝓢𝔀𝓲𝓶𝓶𝓲𝓷𝓰𝓛𝓲𝓾&#39;𝓼 𝓑𝓵𝓸𝓰 (Alt + H)">
                <img src="https://swimmingliu.cn/images/swimmingliu_icon.png" alt="" aria-label="logo"
                    height="30">𝓢𝔀𝓲𝓶𝓶𝓲𝓷𝓰𝓛𝓲𝓾&#39;𝓼 𝓑𝓵𝓸𝓰</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://swimmingliu.cn/index.html" title="🏡 Home">
                    <span>🏡 Home</span>
                </a>
            </li>
            <li>
                <a href="https://swimmingliu.cn/search/" title="🔍 Search">
                    <span>🔍 Search</span>
                </a>
            </li>
            <li>
                <a href="https://swimmingliu.cn/posts/" title="🗒️ Posts">
                    <span>🗒️ Posts</span>
                </a>
            </li>
            <li>
                <a href="https://swimmingliu.cn/archives/" title="📃 Archive">
                    <span>📃 Archive</span>
                </a>
            </li>
            <li>
                <a href="https://swimmingliu.cn/tags/" title="📑 Tags">
                    <span>📑 Tags</span>
                </a>
            </li>
            <li>
                <a href="https://bento.me/swimmingliu" title="👨🏻‍🎓 About Me">
                    <span>👨🏻‍🎓 About Me</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
            <li>
                <a href="https://www.emojisearch.app/" title="Emoji">
                    <span>Emoji</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://swimmingliu.cn/">Home</a>&nbsp;»&nbsp;<a href="https://swimmingliu.cn/posts/">📚 Posts</a>&nbsp;»&nbsp;<a href="https://swimmingliu.cn/posts/job/">💻 Job</a></div>
    <h1 class="post-title entry-hint-parent">
      操作系统面试题笔记
    </h1>
    <div class="post-meta"><span title='2025-03-01 09:49:44 +0800 CST'>March 1, 2025</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;SwimmingLiu

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#1-%e8%af%b4%e8%af%b4%e4%bd%a0%e7%9f%a5%e9%81%93%e7%9a%84%e5%87%a0%e7%a7%8d-io-%e6%a8%a1%e5%9e%8b" aria-label="1. 说说你知道的几种 I/O 模型">1. 说说你知道的几种 I/O 模型</a></li>
                <li>
                    <a href="#2-selectpollepoll-%e4%b9%8b%e9%97%b4%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="2. Select、Poll、Epoll 之间有什么区别？">2. Select、Poll、Epoll 之间有什么区别？</a></li>
                <li>
                    <a href="#3-%e7%ba%bf%e7%a8%8b%e5%92%8c%e8%bf%9b%e7%a8%8b%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="3. 线程和进程有什么区别？">3. 线程和进程有什么区别？</a></li>
                <li>
                    <a href="#4-%e8%bf%9b%e7%a8%8b%e4%b9%8b%e9%97%b4%e7%9a%84%e9%80%9a%e4%bf%a1%e6%96%b9%e5%bc%8f%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="4. 进程之间的通信方式有哪些？">4. 进程之间的通信方式有哪些？</a></li>
                <li>
                    <a href="#5-%e8%bf%9b%e7%a8%8b%e9%97%b4%e7%9a%84%e8%b0%83%e5%ba%a6%e7%ae%97%e6%b3%95%e7%9f%a5%e9%81%93%e5%90%97" aria-label="5. 进程间的调度算法知道吗？">5. 进程间的调度算法知道吗？</a></li>
                <li>
                    <a href="#6-%e7%bd%91%e7%bb%9cio%e9%98%bb%e5%a1%9e%e7%9a%84%e5%8e%9f%e5%9b%a0" aria-label="6. 网络I/O阻塞的原因？">6. 网络I/O阻塞的原因？</a></li>
                <li>
                    <a href="#7-%e4%bb%80%e4%b9%88%e6%98%af%e7%94%a8%e6%88%b7%e6%80%81%e5%92%8c%e5%86%85%e6%a0%b8%e6%80%81" aria-label="7. 什么是用户态和内核态？">7. 什么是用户态和内核态？</a>
                </li>
            </ul>
        </div>
    </details>
</div>
  <div class="post-content"><h2 id="1-说说你知道的几种-io-模型">1. 说说你知道的几种 I/O 模型<a hidden class="anchor" aria-hidden="true" href="#1-说说你知道的几种-io-模型">#</a></h2>
<p><strong>【常见的五大I/O模型】</strong></p>
<p>常见的五大I/O模式分别为: 同步阻塞I/O (Blocking I/O) <code>BIO</code>、非阻塞I/O (Non-blocking I/O) <code>NIO</code>、I/O多路复用、信号量驱动I/O、异步I/O <code>AIO</code></p>
<p>我们假如要烧水喝，看不同模型是怎么烧的水喝</p>
<table>
  <thead>
      <tr>
          <th><strong>I/O 模型</strong></th>
          <th>特性</th>
          <th>烧水案例</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>同步阻塞I/O <code>BIO</code></strong></td>
          <td>数据从网卡到内核，再从内核到用户空间，都是阻塞操作。</td>
          <td>自己动手烧水，一直盯着，等水烧开了，倒在杯子里喝。</td>
      </tr>
      <tr>
          <td><strong>非阻塞I/O <code>NIO</code></strong></td>
          <td>数据从网卡到内核不阻塞，<code>read</code>不到数据直接返回，但是从内核到用户空间会阻塞 (用户轮询<code>read</code>)</td>
          <td>自己动手烧水，隔两分钟看一下，水烧开没有。等水烧开了，倒在杯子里喝。</td>
      </tr>
      <tr>
          <td><strong>I/O多路复用</strong></td>
          <td>只有一个线程查看多个连接是否有数据准备就绪 (看从网卡能不能<code>read</code>到数据到内核)</td>
          <td>找专门烧水的领居帮忙，他把水烧好了之后，会喊你来拿。但是你要自己倒在杯子里喝。</td>
      </tr>
      <tr>
          <td><strong>信号驱动I/O</strong></td>
          <td>数据从网卡到内核之后会自动通知用户程序，然后让他<code>read</code>读取数据</td>
          <td>去烧水房烧水，全自动的，有个通知灯。水烧完了之后会按你家的门铃，但是有客人来了，也会按门铃</td>
      </tr>
      <tr>
          <td><strong>异步I/O <code>AIO</code></strong></td>
          <td>全程不阻塞，拷贝到用户空间之后直接回调。</td>
          <td>和多路复用类似，但是烧完水之后不用自己倒水，他帮你倒好了，还吹凉了，你过来喝就行。</td>
      </tr>
  </tbody>
</table>
<p><img alt="IO五种模型" loading="lazy" src="https://oss.swimmingliu.cn/3bbe065d-f63f-11ef-a797-c858c0c1deba"></p>
<p><strong>【为什么会产生各种I/O】</strong></p>
<p>下图是两个不同主机上，应用程序传递数据的过程，借助该过程来理解 <code>I/O</code> 是如何产生的</p>
<blockquote>
<p>DMA（直接内存访问）是一种不经过CPU直接在网络适配器（网卡）和主机内存之间进行数据传输的机制，用于提升数据传输效率。</p></blockquote>
<p><img alt="两个主机的应用程序是如何通信的" loading="lazy" src="https://oss.swimmingliu.cn/c3fa5783-0332-11f0-9b6e-c858c0c1debd"></p>
<p><strong>【同步阻塞 I/O <code>BIO</code>】</strong></p>
<p>同步阻塞I/O <code>BIO</code> 的工作机制：应用程序被阻塞，直到数据复制到应用进程的缓冲区才返回。阻塞并意味着整个操作系统都被阻塞。其他程序还可以执行，不消耗CPU事件。同步阻塞 I/O <code>BIO</code> 中，应用程序发起 <code>read</code> 调用来读取数据之后，一直被阻塞，直到内核把数据copy到用户空间。该方案适合客户端连接数量不高的情况。下图的<code>read</code> 和 <code>recvfrom</code> 函数是一个意思。</p>
<p><img alt="同步阻塞IO结构图" loading="lazy" src="https://oss.swimmingliu.cn/c5e8e28c-0332-11f0-bf73-c858c0c1debd"></p>
<p><strong>【非阻塞式  I/O <code>NIO</code>】</strong></p>
<p>非阻塞式  I/O <code>NIO</code> 的工作机制：应用程序执行<code>read</code> 系统调用之后，内核返回一个错误码。应用程序可以继续执行，但是需要不断的轮询 <code>read</code> 来获取 I/O是否完成，这种方式称之为 <strong>轮询 <code>polling</code></strong> 。等到数据准备就绪，从内核空间copy到用户空间的时候，进程才被阻塞，直到内核copy完成。该方案比较低效，会不停的消耗CPU资源。</p>
<p><img alt="同步非阻塞IO结构图" loading="lazy" src="https://oss.swimmingliu.cn/c6372625-0332-11f0-8efb-c858c0c1debd"></p>
<p><strong>【I/O 多路复用】</strong></p>
<p>I/O 多路复用是一种支持面向缓存的，基于通道I/O的操作方法，它是基于同步非阻塞I/O设计的。适合高负载、高并发应用。I/O 复用是通过 <code>select</code> 或者 <code>poll</code> 机制，让单个进程能够同时处理多个套接字的读写事件。当任一套接字可读的时候，被阻塞的进程会被唤醒并继续执行。和多进程或者多线程方案相比， I/O 复用避免了创建和切换 进程/线程带来的额外开销。在没有I/O复用的情况下，每次建立一个新的 <code>Socket</code> 连接 都需要单独启动一个线程来处理。</p>
<p>【注意】I/O 多路复用相较于同步非阻塞I/O <code>NIO</code> 少了轮询调用 <code>read</code> 的操作 (轮询<code>polling</code>)， 减少了CPU资源的消耗。复用同一个线程，处理多个<code>socket</code> 中的事件，防止创建过多线程导致的上下文切换的开销。</p>
<p>I/O 复用的具体工作流程：</p>
<ol>
<li>线程首先发起 <code>select</code> 调用，询问内核数据是否准备就绪</li>
<li>等待内核把数据准备好，用户线程再发起<code>read</code> 调用</li>
<li>数据从内核空间copy到用户空间，该过程应用程序还是阻塞的</li>
</ol>
<p><img alt="IO多路复用结构图" loading="lazy" src="https://oss.swimmingliu.cn/c7bb0376-0332-11f0-9a63-c858c0c1debd"></p>
<p><strong>【信号驱动 I/O】</strong></p>
<p>使用 <code>sigaction</code> 系统调用，内核立即返回。应用程序继续执行，内核等待数据准备就绪之后，发送 <code>SIGIO</code> 信号。应用程序受到信号之后，开始 <code>read</code> 系统调用，数据从内核空间复制到用户空间，该过程应用程序阻塞。 和 I/O 多路复用比较相似。</p>
<p><img alt="信号驱动IO结构图" loading="lazy" src="https://oss.swimmingliu.cn/c97555b1-0332-11f0-bfbd-c858c0c1debd"></p>
<p><strong>【异步 I/O <code>AIO</code>】</strong></p>
<p>异步 I/O <code>AIO</code> 是基于事件和回调机制实现的，应用程序 <code>read</code> 系统调用之后，直接返回，完全不阻塞。当后台处理完之后，操作系统通知相应的线程进行后续的操作。</p>
<p><img alt="异步IO结构图" loading="lazy" src="https://oss.swimmingliu.cn/cb80c2b5-0332-11f0-82f3-c858c0c1debd"></p>
<p><strong>【五大 I/O 模型比较】</strong></p>
<p><img alt="五大IO模型比较图" loading="lazy" src="https://oss.swimmingliu.cn/cdb47ee6-0332-11f0-9e45-c858c0c1debd"></p>
<h2 id="2-selectpollepoll-之间有什么区别">2. Select、Poll、Epoll 之间有什么区别？<a hidden class="anchor" aria-hidden="true" href="#2-selectpollepoll-之间有什么区别">#</a></h2>
<table>
  <thead>
      <tr>
          <th>特性</th>
          <th>select</th>
          <th>poll</th>
          <th>epoll</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>触发机制</strong></td>
          <td>水平触发</td>
          <td>水平触发</td>
          <td>边缘触发</td>
      </tr>
      <tr>
          <td><strong>文件描述符存储方式</strong></td>
          <td>位图</td>
          <td>动态数组</td>
          <td>红黑书 + 就绪链表</td>
      </tr>
      <tr>
          <td><strong>性能</strong></td>
          <td>随着文件描述符量增加，性能下降 ( <code>O(N)</code> )</td>
          <td>随着文件描述符量增加，性能下降( <code>O(N)</code> )</td>
          <td>监听列表为 <code>O(1)</code> ，调用事件回调 <code>o(k)</code></td>
      </tr>
  </tbody>
</table>
<p><strong>【水平触发和边缘触发的区别】</strong></p>
<ul>
<li><strong>边缘触发</strong>：事件发生的时候只通知一次，需要用户立即处理，如果没有处理，后续不会再通知</li>
<li><strong>水平触发</strong>：事件发生的时候会反复通知，直到处理完成</li>
</ul>
<h2 id="3-线程和进程有什么区别">3. 线程和进程有什么区别？<a hidden class="anchor" aria-hidden="true" href="#3-线程和进程有什么区别">#</a></h2>
<ul>
<li>
<p><strong>进程 (Process)</strong>：进程是运行中的程序实例，拥有独立的内存空间和系统资源。比如打开的微信/抖音/微博，都是一个单独的进程。</p>
</li>
<li>
<p><strong>线程 (Thread)</strong>：线程也叫轻量级的进程，比进程轻量。一般来说，一个进程里面有多个线程同时执行，并且共享进程的资源。在 <code>Linux</code> 当中，线程可以共享内存空间、文件句柄、网络连接等。</p>
</li>
<li>
<p><strong>协程</strong>：用户态轻量级线程，由程序控制切换，无需内核参与。协程切换只需要保存和恢复上下文，开销比线程小得多，适合处理高并发任务（比如异步<code>I/O</code>）</p>
</li>
</ul>
<p><strong>【注意】</strong> 多线程不是越多越好，因为线程越多就会增加切换成本，可能导致系统负载过高。而且需要同步机制避免数据竞争和死锁问题。</p>
<p><strong>【进程和线程的区别】</strong></p>
<table>
  <thead>
      <tr>
          <th>特性</th>
          <th>进程</th>
          <th>线程</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>本质</strong></td>
          <td>操作系统进行资源分配的基本单元</td>
          <td>构成任务调度与执行的核心单元</td>
      </tr>
      <tr>
          <td><strong>开销</strong></td>
          <td>独立的代码和数据段，进程切换成本高</td>
          <td>线程共享进程的资源，维护独立的堆栈和程序计数器，线程切换成本低</td>
      </tr>
      <tr>
          <td><strong>内存分配</strong></td>
          <td>每个进程分配独立的内存空间</td>
          <td>除了CPU之外，系统不会给线程分配内存，线程组共享资源</td>
      </tr>
      <tr>
          <td><strong>稳定性</strong></td>
          <td>进程隔离性强，崩溃时不会影响其他进程</td>
          <td>线程共享进程资源，崩溃可能导致整个进程异常终止</td>
      </tr>
      <tr>
          <td><strong>安全性</strong></td>
          <td>有独立的内存空间，安全性高</td>
          <td>多个线程共享内存空间，存在数据竞争和线程安全的问题，需要用同步和互斥机制来解决</td>
      </tr>
  </tbody>
</table>
<p><img alt="进程和线程的区别" loading="lazy" src="https://oss.swimmingliu.cn/ce89bb5b-0332-11f0-af3a-c858c0c1debd"></p>
<p><strong>【JVM 视角下的进程和线程】</strong></p>
<p>一个进程可以有多个线程，多个线程之间共享堆和方法区 (元空间)，但是各自有独立的程序计数器、虚拟机栈和本地方法栈，确保线程间执行的上下文彼此隔离。</p>
<ul>
<li><strong>线程共享数据区</strong>：堆、方法区  ( <code>JDK8</code> 之后叫元空间)、执行引擎</li>
<li><strong>线程隔离区域</strong>：程序计数器、虚拟机栈、本地方法栈、每个线程都有独立的脚本</li>
</ul>
<p><img alt="JVM视角下的进程和线程-JDK对比" loading="lazy" src="https://oss.swimmingliu.cn/cf254a63-0332-11f0-ba01-c858c0c1debd"></p>
<p><strong>【进程切换和线程切换的区别】</strong></p>
<ul>
<li><strong>时间效率</strong>：线程切换比进程切换快，因为线程共享地址空间，而进程需要切换页面和上下文（涉及更多资源）</li>
<li><strong>空间效率</strong>：线程共享内存和文件资源，数据交换不需要内核参与，效率更高；进程切换涉及更复杂的上下文保存和恢复。</li>
</ul>
<p><strong>【进程和线程切换的上下文是什么？】</strong></p>
<blockquote>
<p>进程控制块 (process control block) PCB 数据结构是用来描述进程的</p>
<p>PCB是进程存在的唯一标识，其中包含</p>
<ul>
<li><strong>PCB内容</strong>：进程唯一标识符、状态信息（创建、就绪、运行、阻塞、结束）、优先级、资源分配清单（内存和文件句柄）、CPU寄存器值等</li>
<li><strong>进程状态变迁</strong>：创建、就绪、运行、阻塞、结束，五种状态当中进行切换</li>
</ul></blockquote>
<p><img alt="进程的状态切换" loading="lazy" src="https://oss.swimmingliu.cn/cfe8e42c-0332-11f0-a3d0-c858c0c1debd"></p>
<p><strong>【进程的上下文切换】</strong></p>
<ul>
<li>
<p><strong>进程的上下文</strong>：包含<strong>虚拟内存</strong>、<strong>栈</strong>、<strong>全局变量</strong> 等用户空间的资源，还包括<strong>内核堆栈</strong>、<strong>寄存器</strong>等内核空间的资源。</p>
</li>
<li>
<p><strong>进程上下文切换</strong>：将上一个进程 <code>进程A</code> 的上下文保存到当前进程 <code>进程B</code> 的PCB中，当需要运行另外一个进程 <code>进程A</code> 的时候，需要从 <code>进程B</code> 的PCB取出上下文，恢复到CPU中，使得 <code>进程A</code> 可以从中断点继续执行。</p>
</li>
<li>
<p><strong>进程切换发生的场景</strong></p>
<ul>
<li><strong>时间片用完</strong>：某个进程的时间片用完了，进程变为就绪态</li>
<li><strong>资源不足</strong>：某个进程所需要的资源不足，会被挂起，变成就绪挂起状态</li>
<li><strong>主动挂起</strong>：进程被主动挂起</li>
<li><strong>优先级不足</strong>：遇到更高优先级的进程，需要被调度成阻塞状态</li>
<li><strong>硬件中断</strong>：突然断电了</li>
</ul>
</li>
</ul>
<p><strong>【线程的上下文切换】</strong></p>
<ul>
<li><strong>不同进程内的线程切换</strong>：相当于不同进程之间的上下文切换 （比如两个单线程的进程）</li>
<li><strong>同一个进程内的线程切换</strong>：因为虚拟内存是共享的，所以切换的过程中，虚拟内存（堆、方法区、执行引擎）不动，只切换线程的私有数据 （本地方法栈、虚拟机栈）、寄存器等共享的数据</li>
</ul>
<p><strong>【文件句柄、内存空间、网络连接】</strong></p>
<ul>
<li>
<p><strong>文件句柄</strong>：文件句柄是操作系统给进程打开的每个文件分配的唯一整数标识符，用来跟踪文件的位置、权限等状态信息。比如区餐厅点餐，服务员给一个牌子（桌号）。这个牌子就是句柄，代表你的桌子。服务员不知道你是谁，只能通过桌号，找到你的桌子，给你上菜。</p>
</li>
<li>
<p><strong>内存空间</strong>：内存空间包含代码段、数据段、堆区、栈区、文件映射段</p>
<ul>
<li><strong>代码段</strong>：存放二进制可执行代码，通常是只读的</li>
<li><strong>数据段</strong>：存放全局变量和静态变量，分为已初始化数据区和未初始化数据区 (BSS段)</li>
<li><strong>堆区</strong>：用于动态分配内存</li>
<li><strong>栈区</strong>：存放函数的局部变量、参数、返回地址等，大小固定</li>
<li><strong>文件映射段</strong>：包括动态库、共享内存等 (<code>mmap</code> 分配内存)</li>
</ul>
<p><img alt="进程的内存空间结构图" loading="lazy" src="https://oss.swimmingliu.cn/d0129fbb-0332-11f0-a917-c858c0c1debd"></p>
</li>
<li>
<p><strong>网络连接</strong>：Linux里面，网络连接是一种特殊的文件，可以通过文件句柄进行操作。一般是用来两台计算机之间通过网络协议 (TCP/IP) 建立的通信信道。</p>
</li>
</ul>
<h2 id="4-进程之间的通信方式有哪些">4. 进程之间的通信方式有哪些？<a hidden class="anchor" aria-hidden="true" href="#4-进程之间的通信方式有哪些">#</a></h2>
<p><strong>【为什么进程需要进行通信？】</strong></p>
<p>不同的进程有不同的用户地址空间，进程A的全局变量，进程B是看不到的。进程之间想要交换数据需要通过内核，在内核开辟缓冲区。进程A从用户空间copy数据到内核缓冲区，进程B再从内核缓冲区读走数据，实现进程之间的通信。</p>
<p><img alt="进程之间的通信方式结构图" loading="lazy" src="https://oss.swimmingliu.cn/d05bc804-0332-11f0-a84f-c858c0c1debd"></p>
<p><strong>【进程之间的通信方式】</strong></p>
<ul>
<li>
<p><strong>管道/匿名管道</strong>：管道是一种单向通信的方式，用于父进程和子进程之间，或者同一主机上的不同进程之间传递数据。可以是匿名的，也可是命名的。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">ps -ef <span class="p">|</span> grep <span class="o">[</span>name<span class="o">]</span> <span class="c1"># Linux指令的|就是匿名管道</span>
</span></span></code></pre></div></li>
<li>
<p><strong>命名管道</strong>：和匿名管道类似，遵循先进先出原则，以磁盘文件的形式存在，可以实现本机任意两个进程的通信。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">mkfifo pipeDemo <span class="c1"># 创建命名管道</span>
</span></span><span class="line"><span class="cl"><span class="nb">echo</span> <span class="s2">&#34;Hello! World!&#34;</span> &gt; pipeDemo <span class="c1"># 向管道内写入数据</span>
</span></span><span class="line"><span class="cl">cat &lt; pipeDemo <span class="c1"># 读取pipeDemo管道的数据,显示 Hello! World!</span>
</span></span></code></pre></div></li>
<li>
<p><strong>信号</strong>：异步的通信方式，通知接受进程某个事件已经发生，一般用于进程之间发送中断或者终止命令。</p>
</li>
<li>
<p><strong>信号量</strong>：信号量是一种同步原语，用于管理对共享区域的访问，可以用来实现进程间的互斥访问和同步操作。</p>
</li>
<li>
<p><strong>消息队列</strong>：消息队列是链表形式的，遵循先进先出的原则。允许进程A向进程B发送消息，消息在队列中按照顺序存储。但是读取的过程中，进程B不一定非要按照现金先出的顺序读取，可以随机查询。</p>
</li>
<li>
<p><strong>共享内存</strong>：共享内存允许多个进程访问同一块内存区域，可以看见其他进程对共享进程的更新，从而实现快速的数据交换。但是需要注意数据同步的问题，避免出现数据一致性问题。</p>
</li>
<li>
<p><strong>套接字 (socket)</strong>：套接字其实就是<strong>协议+IP+端口</strong>，允许在网络上的不同主机上面的进程进行通信，比如说微信/飞书发消息。</p>
</li>
<li>
<p><strong>文件</strong>：进程可以通过读写文件来进行通信，这种方式通常用于进程之间的间接通信，比如临时文件或者共享文件。</p>
</li>
</ul>
<p><strong>【消息队列详解】</strong></p>
<p>消息队列就是保存在内核中的消息链表，消息队列的生命周期随内核存在而存在。如果不主动释放或者不关闭系统，则会一直存在。匿名管道的生命周期是随进程存在而存在的，进程结束就销毁了。和管道不同，消息队列不需要其他进程在队列上面等待消息到达，可以随时往消息队列里面写入消息。</p>
<p>消息队列的缺点：</p>
<ul>
<li><strong>通信不及时</strong>：因为不需要其他进程在消息队列等着，进程只有轮询检查消息队列，如果有时间间隔，肯定会有没来得及看消息的时候</li>
<li><strong>数据大小存在限制</strong>：消息队列不适合传输比较大的数据，而且需要把数据从用户态copy到内核态里面</li>
</ul>
<p><strong>【共享内存】</strong></p>
<p>进程A和进程B都拿出一块虚拟地址空间映射到相同物理内存，一个进程写入，另外一个进程就可以马上看到，不用从用户态copy数据到内核态，提高进程间的通信速度。但是需要某种同步机制(比如信号量)来达到进程之间的同步和互斥 （比如进程A需要通过信号量通知进程B，它正在写入）。另外，两个进程写同一个地址，先写的进程会发现内容被覆盖了。</p>
<p><img alt="进程通信-共享内存" loading="lazy" src="https://oss.swimmingliu.cn/d13f9ce3-0332-11f0-a287-c858c0c1debd"></p>
<p><strong>【信号量机制】</strong></p>
<p>信号量是用来防止进程之间因为竞争共享资源的，而造成的数据错乱。引入保护机制，使得共享的资源在任意时刻只能被一个进程访问。信号量是整型计数器，用于实现进程间的互斥和同步，不是用来缓存进程之间的通信数据的。信号量有两种操作，<code>P</code> 操作和 <code>V</code> 操作：</p>
<ul>
<li><strong><code>P</code> 操作</strong>：将信号量减去1，如果相减之后信号量 &lt; 0，则表明资源被占用。如果信号量 &gt;= 0， 表明资源还可以继续使用</li>
<li><strong><code>V</code> 操作</strong>：将信号量加上1，如果相加之后信号量 &lt;= 0, 说明有阻塞进程，唤醒该进程运行。如果相加之后，信号量 &gt; 0，则表明没有阻塞进程，直接运行。</li>
</ul>
<p>如果信号量初始化为 <code>1</code>，代表是互斥信号量。如果初始化为 <code>0</code>，代表是同步信号量。</p>
<p><strong>【基于TCP协议通信的套接字socket编程模型】</strong></p>
<ul>
<li><strong>TCP套接字通信</strong>
<ol>
<li>服务端和客户端初始化套接字 <code>socket</code> 的 文件描述符</li>
<li>服务端 <code>bind</code> 绑定 IP 和 端口， <code>listen</code> 监听 ，<code>accept</code> 等客户端进行连接</li>
<li>客户端 <code>connect</code> 向服务端地址和端口发起连接请求</li>
<li>服务端 <code>accpet</code> 返回传输 <code>socket</code> 文件描述符</li>
<li>客户端 <code>write</code> 写入数据，服务端 <code>read</code> 读取</li>
<li>客户端 <code>close</code> 的时候，服务端 <code>read</code> 会读取到 EOF (End of File)， 处理完数据之后，服务端 <code>close</code> 关闭链接</li>
</ol>
</li>
<li><strong>UDP套接字通信</strong>：每次通信的时候调用<code>sendto</code> 和 <code>recvfrom()</code>， 都需要传入目标主机的IP地址和端口</li>
</ul>
<p><img alt="进程通信-UDP和TCP套接字对比" loading="lazy" src="https://oss.swimmingliu.cn/d2797c47-0332-11f0-a564-c858c0c1debd"></p>
<h2 id="5-进程间的调度算法知道吗">5. 进程间的调度算法知道吗？<a hidden class="anchor" aria-hidden="true" href="#5-进程间的调度算法知道吗">#</a></h2>
<ul>
<li>
<p><strong>先来先服务 (FCFS, First Come First Service)</strong>：按照进程到达的先后顺序进行调度，先到达的进程先执行，后达到的进程后执行。就像区银行取钱，挨个排队一样。</p>
<p><img alt="进程调度算法-先来先服务" loading="lazy" src="https://oss.swimmingliu.cn/d468838a-0332-11f0-8d92-c858c0c1debd"></p>
</li>
<li>
<p><strong>最短作业优先 (SJF, Short Job First)</strong>：按照进程的执行时间进行排序，执行时间短的进程优先执行，以减少平均等待时间。但是，可能会出现饥饿现象，执行时间长的程序，可能要等很久才能被执行。可以类比成银行让客户按照办理业务的时间进行排队，依次处理。</p>
<p><img alt="进程调度算法-最短作业优先" loading="lazy" src="https://oss.swimmingliu.cn/d5aafd90-0332-11f0-afb7-c858c0c1debd"></p>
</li>
<li>
<p><strong>优先级调度</strong>：给每个进程分配一个优先级，根据优先级高低进行调度，优先级高的进程先执行。但是，优先级较低的程序需要等很久才能执行，可能会出现饥饿现象。</p>
<p><img alt="进程调度算法-优先级调度" loading="lazy" src="https://oss.swimmingliu.cn/d5c72623-0332-11f0-8962-c858c0c1debd"></p>
</li>
<li>
<p><strong>时间片轮转 (PR)</strong>：将CPU时间分成多个时间片，每个进程轮流占用一个时间片，如果一个进程在该时间片结束的时候还没有执行完成，则将其移到队列末尾，等待下一次调度。</p>
<p><img alt="进程调度算法-时间片轮转" loading="lazy" src="https://oss.swimmingliu.cn/d5f00864-0332-11f0-adba-c858c0c1debd"></p>
</li>
<li>
<p><strong>多级反馈队列调度 (MFQS, Multilevel Feedback Queue Scheduling)</strong>：<strong>多级</strong>的意思是有多个队列，每个队列的优先级从高到低，优先级越高时间片越短（为了避免优先级低的进程被饿死了）。<strong>反馈</strong>的意思是如果有新的进程进入优先级高的队列的时候，立即停止当前运行的进程，转到优先级最高的队里去从头运行。（让优先级高的队列，得到快速处理的保障）具体工程流程如下：</p>
<ol>
<li>设置多个队列，每个队列赋予不同的优先级，优先级从高到低，同时优先级越高的队列，时间片设置的越短</li>
<li>如果有新的进程，会把它放到第一级队列的末尾，按照先来先服务的原则排队等待被调度。如果在第一级队列规定时间片没有运行完成，则将其转入第二级队列末尾，直到完成为止。</li>
<li>当较高优先级的队列为空，才调度较低优先级的队列中的进程运行。如果进程运行的时候，有新进程进入较高优先级的队列，则停止当前运行的进程，并且将其移动到原来队列的队尾。然后从较高优先级队列开始，重复刚才的过程。</li>
</ol>
<p><img alt="进程调度算法-多级反馈队列调度" loading="lazy" src="https://oss.swimmingliu.cn/d6532bb1-0332-11f0-844a-c858c0c1debd"></p>
</li>
</ul>
<h2 id="6-网络io阻塞的原因">6. 网络I/O阻塞的原因？<a hidden class="anchor" aria-hidden="true" href="#6-网络io阻塞的原因">#</a></h2>
<p>网络I/O会被阻塞是因为进行网络数据传输的过程中，操作系统在等待数据的发送或接收完成之前，进程将被挂起，直到数据传输完成之后才恢复进程执行。</p>
<p>网络I/O阻塞的主要原因：</p>
<ul>
<li><strong>等待数据到达或发送完成</strong>：当进程尝试从网络套接字 <code>socket</code> 读取数据的时候，如果数据还没到达（数据未就绪），操作系统会让进程进入阻塞状态，直到数据到达为止。同样，数据未能立即发出去的时候，发送操作也可能被阻塞，等待缓冲区有空闲空间。</li>
<li><strong>系统资源有限</strong>：当系统资源（网络缓冲区、连接数）被占满的时候，进一步的I/O请求可能会被阻塞，等待资源释放后才能继续。</li>
<li><strong>默认的阻塞行为</strong>：大多数网络API (比如<code>recv</code>、<code>send</code>、<code>accept</code>等) 在默认情况下都是阻塞的，调用这些API的时候，如果条件不满足，会让调用者等待，直到I/O操作完成。</li>
</ul>
<h2 id="7-什么是用户态和内核态">7. 什么是用户态和内核态？<a hidden class="anchor" aria-hidden="true" href="#7-什么是用户态和内核态">#</a></h2>
<table>
  <thead>
      <tr>
          <th>运行模式</th>
          <th>权限级别</th>
          <th>可执行操作</th>
          <th>特点</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>用户态</strong></td>
          <td>较低</td>
          <td>不能直接访问硬件或者越权操作，需要通过系统调用让内核执行敏感操作</td>
          <td>安全性高，程序出现问题，不会影响系统的稳定性。</td>
      </tr>
      <tr>
          <td><strong>内核态</strong></td>
          <td>较高</td>
          <td>可直接访问硬件资源并执行如内存管理、进程调度等于越权操作</td>
          <td>能够高效管理硬件和系统资源</td>
      </tr>
  </tbody>
</table>
<p><strong>用户态和内核态</strong>是 <strong><code>CPU</code> 的状态</strong>，描述了CPU在执行指令是的特权级别和范围权限。进程运行的过程当中，可能会因为CPU状态的切换，在用户态和内核态之间更替。</p>
<p>简单来说，一个进程当中，如果<code>CPU</code> 是用户态就是线程运行进程本身的程序代码，如果 <code>CPU</code> 是内核态就是把线程交给操作系统运行。</p>
<ul>
<li><strong>CPU是用户态，进程只能访问自己的存储空间</strong>：用户态下，进程不能直接使用系统资源，只能访问自己的存储空间，不能越权访问系统的资源。也不能改变CPU的工作状态（用户态、内核态、空闲状态）。在用户态下，进程无法修改CPU的工作状态。在内核态下，操作系统可以通过修改CPU寄存器的值来切换权限，实现内核态和用户态的切换。</li>
<li><strong>CPU是内核态，进程可以通过os访问系统资源</strong>：内核态下，进程可以通过执行操作系统的程序，来直接使用计算机的所有硬件资源。但是，必须从用户态切换到内核态才可以，这样也保证了安全性和稳定性。</li>
</ul>
<p><strong>【为什么要区分用户态和内核态】</strong></p>
<p>因为 <code>CPU</code> 的所有指令当中，有部分指令是非常危险的，操作不当就会导致系统崩溃。而且部分指令可能涉及到硬件的操作，参数很多，很容易出问题。所以凡是涉及到 I/O 读写，内存分配等硬件资源的操作的时候，为了保证安全性和稳定性，往往不能让进程直接操作，而是通过系统调用（调用操作系统的程序）让 <code>CPU</code> 从用户态切换到内核态，程序在内核态下面运行。</p>
<p>其中，<code>CPU</code> 的指令是有权限分级的，不同级别的权限包含不同的 <code>CPU</code> 指令集。比如 <code>InterCPU</code> 把 <code>CPU</code> 的指令集操作权限从高到低分为四个级别：<code>ring0</code>、<code>ring1</code>、<code>ring2</code>、<code>ring3</code>。</p>
<p><strong>【注意】</strong></p>
<ol>
<li><code>ring3</code> 的权限最低，只能使用常规的 <code>CPU</code> 指令集，不能使用操作硬件资源的 <code>CPU</code> 指令集，比如I/O读写、网卡访问、申请内存等操作都不可以。<code>ring0</code> 的权限最高，可以使用所有的 <code>CPU</code> 指令集</li>
<li>Linux系统当中只采用了 <code>ring0</code> 和 <code>ring3</code> 这两个权限。<code>ring0</code> 对应的就是内核态，程序完全在操作系统内核当中运行。<code>ring3</code> 对应的是用户态，程序在自己的存储空间当中运行。</li>
</ol>
<p><img alt="内核态和用户态示意图" loading="lazy" src="https://oss.swimmingliu.cn/d73a7e09-0332-11f0-b5fc-c858c0c1debd"></p>
<p><strong>【用户态和内核态的空间】</strong></p>
<p>在内存资源的使用上，操作系统对用户态和内核态也做了限制。内存结构如下图所示，包含了内核空间和用户空间（程序代码和数据、堆内存、栈内存、命令行参数和环境变量等）。每个进程创建的时候，都会分配虚拟空间地址，和内存结构一样。虚拟空间就记录，对应的在实际内存中存放的位置。虚拟地址空间与物理内存通过**内存管理单元（MMU）<strong>和</strong>页表（Page Table）**实现动态映射。例如，在Linux ( <code>32</code> 位系统)下，总共的内存空间是 <code>2^32 bytes = 4GB </code> ，内核态为 <code>1G</code>，用户态为 <code>3G</code>。
**【注意】**内核态的地址空间存放整个内核的代码，所有的内核模块和内核维护的数据，这一部分是所有进程共享的。所有进程的内核态逻辑地址是共享同一块内存地址的。同时 <code>CPU</code> 处于内核态的时候，进程可以操作全部范围的虚拟空间地址，并且属于内核态的高位虚拟空间只有内核态下，程序才能操作。</p>
<p><img alt="内核态和用户态在进程中的结构图和Linux环境" loading="lazy" src="https://oss.swimmingliu.cn/d7b95b18-0332-11f0-a5e7-c858c0c1debd"></p>
<p><strong>【用户态和内核态的切换】</strong></p>
<p>用户态和内核态的切换具有一定的开销，下面是从用户态切换到内核态的流程（比如发起 <code>I/O</code> 调用）</p>
<ol>
<li>保留用户态的现场 （上下文、程序计数器（寄存器）、用户栈）</li>
<li>复制用户参数，从用户栈切换到内核栈，<code>CPU</code> 进入内核态</li>
<li>额外的检查 （因为内核代码对用户是不信任的）</li>
<li>执行内核态中相关的代码</li>
<li>复制内核态代码执行结果，回到用户态</li>
<li>恢复用户态现场（上下文、程序计数器（寄存器）、用户栈）</li>
</ol>
<p>从用户态主动切换到内核态，需要有入口才行，操作系统提供了统一的入口（系统调用）。系统调用就是一组通用的访问接口，这些接口就叫系统调用。</p>
<p><img alt="Linux架构图-用户态-内核态" loading="lazy" src="https://oss.swimmingliu.cn/d80f5dc7-0332-11f0-abe8-c858c0c1debd"></p>
<p><strong>【用户态什么时候切换到内核态】</strong></p>
<ul>
<li><strong>系统调用</strong>：用户态进程通过系统调用向操作系统申请资源完成工作，比如 <code>fork()</code> 创建子进程，就是一个创建新进程的系统调用。系统调用的核心是系草系统为用户特别开放的一个<strong>中断</strong>来实现的，成为<strong>软中断</strong>。</li>
<li><strong>异常</strong>：当 <code>CPU</code> 在执行用户态的进程的时候，发生了一些没有预知的异常。此时，当前运行进程会切换到处理该异常的内核态中的相关进程，就是从用户态切换到内核态了。比如出现<strong>缺页异常</strong></li>
<li><strong>中断</strong>：当 <code>CPU</code> 在执行用户态的进程的时候，外围设备完成用户请求的操作之后，会向 <code>CPU</code> 发出相应的中断信号。此时， <code>CPU</code> 会暂停执行下一条即将执行的指令，转到与中断信号对应的内核态下的处理程序去执行，从用户态切换到了内核态。比如硬盘读写完成，系统会切换到硬盘读写的中断处理程序中执行后边的操作。</li>
</ul>


  </div>



  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://swimmingliu.cn/tags/java/">Java</a></li>
      <li><a href="https://swimmingliu.cn/tags/os/">OS</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://swimmingliu.cn/posts/job/java-juc-interview-questions/">
    <span class="title">« Prev</span>
    <br>
    <span>(JUC) Java并发面试题笔记</span>
  </a>
  <a class="next" href="https://swimmingliu.cn/posts/job/personal-interview-hot-question/">
    <span class="title">Next »</span>
    <br>
    <span>个人简历常问问题</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2023-2025 <a href="https://swimmingliu.cn/">SwimmingLiu&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
    <span>
        <a href="https://beian.miit.gov.cn/">浙ICP备2024056260号</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
