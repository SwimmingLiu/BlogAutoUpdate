<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>YOLOv9: Learning What You Want to Learn Using Programmable Gradient Information | SwimmingLiu&#39;s Blog</title>
<meta name="keywords" content="YOLOv9">
<meta name="description" content="Abstract

如今的深度学习方法主要关注如何设计最合适的目标函数，使模型的预测结果能够最接近真实情况。同时，必须设计一个适当的架构，可以帮助获取足够的信息进行预测。现有方法忽略了一个事实，即当输入数据经过逐层特征提取和空间变换时，大量信息将会丢失。本文将深入研究数据通过深度网络传输时数据丢失的重要问题，即信息瓶颈和可逆函数。我们提出了可编程梯度信息（PGI）的概念来应对深度网络实现多个目标所需的各种变化。
PGI可以为目标任务计算目标函数提供完整的输入信息，从而获得可靠的梯度信息来更新网络权值。此外，还设计了一种基于梯度路径规划的新型轻量级网络架构——通用高效层聚合网络（GELAN）。GELAN的架构证实了PGI在轻量级模型上取得了优异的结果。我们在基于 MS COCO 数据集的目标检测上验证了所提出的 GELAN 和 PGI。结果表明，与基于深度卷积开发的最先进方法相比，GELAN 仅使用传统的卷积算子即可实现更好的参数利用率。 PGI 可用于从轻型到大型的各种模型。它可以用来获取完整的信息，使得train-from-scratch (从零开始训练) 模型能够比使用大数据集预训练的state-of-theart模型获得更好的结果，对比结果如图1所示。源代码位于：https： //github.com/WongKinYiu/yolov9。
核心创新点:  依然是网络结构的创新

Programmable Gradient Information (PGI)
Generalized Efficient Layer Aggregation Network（GELAN）


Introduction

基于深度学习的模型在计算机视觉、语言处理和语音识别等各个领域都表现出了比过去的人工智能系统更好的性能。近年来，深度学习领域的研究人员主要关注如何开发更强大的系统架构和学习方法，例如CNN，Transformers[8,9,40] 、41、60、69、70]，Perceivers[26、26、32、52、56、81、81]和Mambas[17、38、80]。此外，一些研究人员尝试开发更通用的目标函数，例如损失函数[5,45,46,50,77,78]，标签分配[10,12,33,67,79]和辅助监督[18] 、20、24、28、29、51、54、68、76]。上述研究都试图精确地找到输入和目标任务之间的映射。然而，大多数过去的方法都忽略了输入数据在前馈过程中可能会产生不可忽略的信息丢失量。这种信息丢失可能会导致有偏差的梯度流，随后用于更新模型。上述问题可能导致深度网络在目标和输入之间建立不正确的关联，导致训练后的模型产生不正确的预测。
在深度网络中，输入数据在前馈过程中丢失信息的现象俗称信息瓶颈[59]，其示意图如图2所示。目前可以缓解这种现象的主要方法有：（1）可逆架构的使用[3,16,19]：该方法主要使用重复的输入数据，并以显式的方式维护输入数据的信息； （2）使用Masked建模[1,6,9,27,71,73]：主要利用重构损失，采用隐式方式最大化提取特征并保留输入信息； （3）引入深度监督概念[28,51,54,68]：它利用没有丢失太多重要信息的浅层特征来预先建立从特征到目标的映射，以确保重要信息能够被传递到更深的层次。然而，上述方法在训练过程和推理过程中都存在不同的缺点。例如，可逆架构需要额外的层来组合重复馈送的输入数据，这将显着增加推理成本。另外，由于输入数据层到输出层不能有太深的路径，这种限制将导致在训练过程中难以对高阶语义信息进行建模。对于 Masked 建模，其重建损失有时与目标损失相冲突。此外，大多数掩码机制还会产生与数据的不正确关联。 对于深层监督机制来说，会产生误差累积，如果浅层监督在训练过程中丢失信息，后续层将无法检索到所需信息。上述现象在困难任务和小模型上会更加显着。
针对上述问题，我们提出了一个新的概念，即可编程梯度信息（PGI）。其概念是通过辅助可逆分支生成可靠的梯度，使得深层特征仍然能够保持执行目标任务的关键特征。
辅助可逆分支的设计可以避免传统的融合多路径特征的深度监督过程可能造成的语义损失。换句话说，我们在不同语义层面上编程梯度信息传播，从而达到最佳的训练结果。 PGI的可逆架构建立在辅助分支上，因此没有额外的成本。由于PGI可以自由选择适合目标任务的损失函数，因此也克服了Masked建模遇到的问题。所提出的PGI机制可以应用于各种规模的深度神经网络，并且比仅适用于非常深的神经网络的深度监督机制更通用。
在本文中，我们还基于ELAN[65]设计了广义ELAN（GELAN），GELAN的设计同时考虑了参数量、计算复杂度、准确性和推理速度。这种设计允许用户针对不同的推理设备任意选择合适的计算块。我们将提出的PGI和GELAN结合起来，然后设计了新一代YOLO系列物体检测系统，我们称之为YOLOv9。我们使用MS COCO数据集进行实验，实验结果验证了我们提出的YOLOv9在所有比较中都取得了顶尖的性能。
我们总结本文的贡献如下：


我们从可逆函数的角度对现有的深度神经网络架构进行了理论分析，通过这个过程我们成功地解释了许多过去难以解释的现象。我们还基于此分析设计了PGI和辅助可逆分支，并取得了优异的结果。


我们设计的PGI解决了深度监督只能用于极深的神经网络架构的问题，从而让新的轻量级架构真正应用于日常生活中。


我们设计的GELAN仅使用常规卷积来实现比基于最先进技术的深度卷积设计更高的参数利用率，同时表现出轻、快速、准确的巨大优势。


结合所提出的PGI和GELAN，YOLOv9在MS COCO数据集上的目标检测性能在各个方面都大大超过了现有的实时目标检测器。


Programmable Gradient Information (PGI)：


自由选择适合目标任务的损失函数


可逆结构建立辅助分支，不增加推理成本


适用于各种规模的深度神经网络


GELAN：

轻、快速、准确
采用常规卷积吊打其他新颖卷积

Related work
2.1 Real-time Object Detectors

目前主流的实时目标检测器是YOLO系列[2,7,13–15,25,30,31,47–49,61–63,74,75]，这些模型大多数使用CSPNet[64]或 ELAN [65] 及其变体作为主要计算单元。在特征集成方面，通常使用改进的PAN[37]或FPN[35]作为工具，然后使用改进的YOLOv3头[49]或FCOS头[57, 58]作为预测头。最近也提出了一些实时目标检测器，例如 RT DETR [43]，其基础是 DETR [4]。然而，由于DETR系列目标检测器在没有相应领域预训练模型的情况下很难应用于新领域，因此目前应用最广泛的实时目标检测器仍然是YOLO系列。本文选择 YOLOv7 [63] 作为开发该方法的基础，该方法已在各种计算机视觉任务和各种场景中被证明有效。">
<meta name="author" content="SwimmingLiu">
<link rel="canonical" href="https://swimmingliu.cn/posts/papernotes/2024-yolov9/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.6ecbb0040febd20e47edd88a662c19f1ea945bf7427774b86594271d18f88faf.css" integrity="sha256-bsuwBA/r0g5H7diKZiwZ8eqUW/dCd3S4ZZQnHRj4j68=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<link rel="apple-touch-icon" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<link rel="mask-icon" href="https://swimmingliu.cn/images/swimmingliu_icon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://swimmingliu.cn/posts/papernotes/2024-yolov9/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>


<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        renderMathInElement(document.body, {
            
            
            delimiters: [
                { left: '$$', right: '$$', display: true },
                { left: '$', right: '$', display: false },
                { left: '\\(', right: '\\)', display: false },
                { left: '\\[', right: '\\]', display: true }
            ],
            
            throwOnError: false
        });
    });
</script>



</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://swimmingliu.cn/" accesskey="h" title="𝓢𝔀𝓲𝓶𝓶𝓲𝓷𝓰𝓛𝓲𝓾&#39;𝓼 𝓑𝓵𝓸𝓰 (Alt + H)">
                <img src="https://swimmingliu.cn/images/swimmingliu_icon.png" alt="" aria-label="logo"
                    height="30">𝓢𝔀𝓲𝓶𝓶𝓲𝓷𝓰𝓛𝓲𝓾&#39;𝓼 𝓑𝓵𝓸𝓰</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://swimmingliu.cn/index.html" title="🏡 Home">
                    <span>🏡 Home</span>
                </a>
            </li>
            <li>
                <a href="https://swimmingliu.cn/search/" title="🔍 Search">
                    <span>🔍 Search</span>
                </a>
            </li>
            <li>
                <a href="https://swimmingliu.cn/posts/" title="🗒️ Posts">
                    <span>🗒️ Posts</span>
                </a>
            </li>
            <li>
                <a href="https://swimmingliu.cn/archives/" title="📃 Archive">
                    <span>📃 Archive</span>
                </a>
            </li>
            <li>
                <a href="https://swimmingliu.cn/tags/" title="📑 Tags">
                    <span>📑 Tags</span>
                </a>
            </li>
            <li>
                <a href="https://bento.me/swimmingliu" title="👨🏻‍🎓 About Me">
                    <span>👨🏻‍🎓 About Me</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
            <li>
                <a href="https://www.emojisearch.app/" title="Emoji">
                    <span>Emoji</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://swimmingliu.cn/">Home</a>&nbsp;»&nbsp;<a href="https://swimmingliu.cn/posts/">📚 Posts</a>&nbsp;»&nbsp;<a href="https://swimmingliu.cn/posts/papernotes/">📝 Paper Notes</a></div>
    <h1 class="post-title entry-hint-parent">
      YOLOv9: Learning What You Want to Learn Using Programmable Gradient Information
    </h1>
    <div class="post-meta"><span title='2024-03-01 15:26:23 +0800 CST'>March 1, 2024</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;SwimmingLiu

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#abstract" aria-label="Abstract">Abstract</a></li>
                <li>
                    <a href="#introduction" aria-label="Introduction">Introduction</a></li>
                <li>
                    <a href="#related-work" aria-label="Related work">Related work</a><ul>
                        
                <li>
                    <a href="#21-real-time-object-detectors" aria-label="2.1 Real-time Object Detectors">2.1 Real-time Object Detectors</a></li>
                <li>
                    <a href="#22-reversible-architectures" aria-label="2.2 Reversible Architectures">2.2 Reversible Architectures</a></li>
                <li>
                    <a href="#23-auxiliary-supervision" aria-label="2.3 Auxiliary Supervision">2.3 Auxiliary Supervision</a></li></ul>
                </li>
                <li>
                    <a href="#problem-statement" aria-label="Problem Statement">Problem Statement</a><ul>
                        
                <li>
                    <a href="#31-information-bottleneck-principle" aria-label="3.1. Information Bottleneck Principle">3.1. Information Bottleneck Principle</a></li>
                <li>
                    <a href="#32-reversible-functions" aria-label="3.2. Reversible Functions">3.2. Reversible Functions</a></li></ul>
                </li>
                <li>
                    <a href="#methodology" aria-label="Methodology">Methodology</a><ul>
                        
                <li>
                    <a href="#41-programmable-gradient-information" aria-label="4.1 Programmable Gradient Information">4.1 Programmable Gradient Information</a><ul>
                        
                <li>
                    <a href="#411-auxiliary-reversible-branch" aria-label="4.1.1 Auxiliary Reversible Branch">4.1.1 Auxiliary Reversible Branch</a></li>
                <li>
                    <a href="#412-multi-level-auxiliary-information" aria-label="4.1.2 Multi-level Auxiliary Information">4.1.2 Multi-level Auxiliary Information</a></li></ul>
                </li>
                <li>
                    <a href="#42-generalized-elan" aria-label="4.2. Generalized ELAN">4.2. Generalized ELAN</a></li></ul>
                </li>
                <li>
                    <a href="#experiments" aria-label="Experiments">Experiments</a><ul>
                        
                <li>
                    <a href="#51-experimental-setup" aria-label="5.1. Experimental Setup">5.1. Experimental Setup</a></li>
                <li>
                    <a href="#52-implementation-details" aria-label="5.2 Implementation Details">5.2 Implementation Details</a></li>
                <li>
                    <a href="#53-comparison-with-state-of-the-arts" aria-label="5.3 Comparison with state-of-the-arts">5.3 Comparison with state-of-the-arts</a></li>
                <li>
                    <a href="#54-ablation-studies" aria-label="5.4 Ablation Studies">5.4 Ablation Studies</a><ul>
                        
                <li>
                    <a href="#541-generalized-elan" aria-label="5.4.1 Generalized ELAN">5.4.1 Generalized ELAN</a></li>
                <li>
                    <a href="#542-programmable-gradient-information" aria-label="5.4.2 Programmable Gradient Information">5.4.2 Programmable Gradient Information</a></li></ul>
                </li>
                <li>
                    <a href="#55-visualization" aria-label="5.5 Visualization">5.5 Visualization</a></li></ul>
                </li>
                <li>
                    <a href="#conclusions" aria-label="Conclusions">Conclusions</a>
                </li>
            </ul>
        </div>
    </details>
</div>
  <div class="post-content"><h2 id="abstract">Abstract<a hidden class="anchor" aria-hidden="true" href="#abstract">#</a></h2>
<blockquote>
<p>如今的深度学习方法主要关注如何设计<strong>最合适的目标函数</strong>，使模型的预测结果能够最接近真实情况。同时，必须设计一个<strong>适当的架构</strong>，可以帮助<strong>获取足够的信息进行预测</strong>。现有方法忽略了一个事实，即<strong>当输入数据经过逐层特征提取和空间变换时</strong>，<strong>大量信息将会丢失</strong>。本文将深入研究数据通过<strong>深度网络传输时数据丢失的重要问题</strong>，即<strong>信息瓶颈和可逆函数</strong>。我们提出了<strong>可编程梯度信息（PGI）<strong>的概念来应对深度网络实现</strong>多个目标所需的各种变化</strong>。
PGI可以为<strong>目标任务计算目标函数</strong>提供<strong>完整的输入信息</strong>，从而获得<strong>可靠的梯度信息来更新网络权值</strong>。此外，还设计了一种基于<strong>梯度路径规划的新型轻量级网络架构</strong>——<strong>通用高效层聚合网络（GELAN）</strong>。GELAN的架构证实了PGI在轻量级模型上取得了优异的结果。我们在基于 MS COCO 数据集的目标检测上验证了所提出的 GELAN 和 PGI。结果表明，与基于深度卷积开发的最先进方法相比，GELAN 仅使用<strong>传统的卷积算子</strong>即可实现更好的参数利用率。 PGI 可用于从轻型到大型的各种模型。它可以用来获取完整的信息，使得<strong>train-from-scratch (从零开始训练) 模型能够比使用大数据集预训练</strong>的state-of-theart模型获得更好的结果，对比结果如图1所示。源代码位于：https： //github.com/WongKinYiu/yolov9。</p></blockquote>
<p>核心创新点:  依然是网络结构的创新</p>
<ol>
<li>Programmable Gradient Information (PGI)</li>
<li>Generalized Efficient Layer Aggregation Network（GELAN）</li>
</ol>
<p><img alt="image-20240301113226341" loading="lazy" src="https://oss.swimmingliu.cn/f6b3ea45-d79d-11ee-a66b-c858c0c1debd"></p>
<h2 id="introduction">Introduction<a hidden class="anchor" aria-hidden="true" href="#introduction">#</a></h2>
<blockquote>
<p>基于深度学习的模型在计算机视觉、语言处理和语音识别等各个领域都表现出了比过去的人工智能系统更好的性能。近年来，深度学习领域的研究人员主要关注如何开发更强大的系统架构和学习方法，例如CNN，Transformers[8,9,40] 、41、60、69、70]，Perceivers[26、26、32、52、56、81、81]和Mambas[17、38、80]。此外，一些研究人员尝试开发更通用的目标函数，例如损失函数[5,45,46,50,77,78]，标签分配[10,12,33,67,79]和辅助监督[18] 、20、24、28、29、51、54、68、76]。上述研究都试图精确地找到<strong>输入和目标任务之间的映射</strong>。然而，大多数过去的方法都忽略了<strong>输入数据在前馈过程中可能会产生不可忽略的信息丢失量</strong>。这种<strong>信息丢失</strong>可能会导致<strong>有偏差的梯度流</strong>，随后用于更新模型。上述问题可能导致深度网络<strong>在目标和输入之间建立不正确的关联</strong>，导致训练后的模型产生不正确的预测。</p>
<p>在深度网络中，<strong>输入数据在前馈过程中丢失信息的现象</strong>俗称<strong>信息瓶颈</strong>[59]，其示意图如图2所示。目前可以缓解这种现象的主要方法有：（1）<strong>可逆架构</strong>的使用[3,16,19]：该方法主要<strong>使用重复的输入数据，并以显式的方式维护输入数据的信息</strong>； （2）使用<strong>Masked建模</strong>[1,6,9,27,71,73]：主要利用重构损失，采用<strong>隐式方式最大化提取特征并保留输入信息</strong>； （3）引入<strong>深度监督</strong>概念[28,51,54,68]：它利用<strong>没有丢失太多重要信息的浅层特征来预先建立从特征到目标的映射</strong>，以确保<strong>重要信息能够被传递到更深的层次</strong>。然而，上述方法在训练过程和推理过程中都存在不同的缺点。例如，<strong>可逆架构需要额外的层来组合重复馈送的输入数据</strong>，这将显着增加推理成本。另外，由于<strong>输入数据层到输出层不能有太深的路径</strong>，这种限制将导致<strong>在训练过程中难以对高阶语义信息进行建模</strong>。对于 <strong>Masked 建模</strong>，其<strong>重建损失有时与目标损失相冲突</strong>。此外，大多数<strong>掩码机制还会产生与数据的不正确关联</strong>。 对于<strong>深层监督</strong>机制来说，会产生<strong>误差累积</strong>，如果<strong>浅层监督在训练过程中丢失信息</strong>，<strong>后续层将无法检索到所需信息</strong>。上述现象在<strong>困难任务</strong>和<strong>小模型上</strong>会更加<strong>显着</strong>。</p>
<p>针对上述问题，我们提出了一个新的概念，即<strong>可编程梯度信息（PGI）</strong>。其概念是通过<strong>辅助可逆分支生成可靠的梯度</strong>，使得<strong>深层特征仍然能够保持执行目标任务的关键特征</strong>。</p>
<p><strong>辅助可逆分支的设计</strong>可以避免传统的<strong>融合多路径特征的深度监督过程</strong>可能造成的<strong>语义损失</strong>。换句话说，我们在<strong>不同语义层面上编程梯度信息传播</strong>，从而达到最佳的训练结果。 PGI的<strong>可逆架构建立在辅助分支上</strong>，因此<strong>没有额外的成本</strong>。由于PGI可以<strong>自由选择适合目标任务的损失函数</strong>，因此也克服了<strong>Masked建模</strong>遇到的问题。所提出的<strong>PGI机制</strong>可以应用于各种规模的<strong>深度神经网络</strong>，并且比仅适用于<strong>非常深的神经网络</strong>的<strong>深度监督机制更通用</strong>。</p>
<p>在本文中，我们还基于ELAN[65]设计了<strong>广义ELAN（GELAN）</strong>，GELAN的设计同时<strong>考虑了参数量、计算复杂度、准确性和推理速度</strong>。这种设计允许用户<strong>针对不同的推理设备任意选择合适的计算块</strong>。我们将提出的PGI和GELAN结合起来，然后设计了新一代YOLO系列物体检测系统，我们称之为YOLOv9。我们使用MS COCO数据集进行实验，实验结果验证了我们提出的YOLOv9在所有比较中都取得了顶尖的性能。</p>
<p>我们总结本文的贡献如下：</p>
<ol>
<li>
<p>我们从<strong>可逆函数的角度</strong>对<strong>现有的深度神经网络架构进行了理论分析</strong>，通过这个过程<strong>我们成功地解释了许多过去难以解释的现象</strong>。我们还基于此分析<strong>设计了PGI和辅助可逆分支</strong>，并取得了优异的结果。</p>
</li>
<li>
<p>我们设计的PGI解决了<strong>深度监督</strong>只能用于<strong>极深的神经网络架构的问题</strong>，从而让<strong>新的轻量级架构真正应用于日常生活中</strong>。</p>
</li>
<li>
<p>我们设计的GELAN仅使用<strong>常规卷积</strong>来实现比基于最先进技术的<strong>深度卷积设计更高的参数利用率</strong>，同时表现出<strong>轻、快速、准确</strong>的巨大优势。</p>
</li>
<li>
<p>结合所提出的PGI和GELAN，YOLOv9在MS COCO数据集上的目标检测性能在各个方面都大大超过了现有的实时目标检测器。</p>
</li>
</ol></blockquote>
<p>Programmable Gradient Information (PGI)：</p>
<ol>
<li>
<p>自由选择适合目标任务的损失函数</p>
</li>
<li>
<p>可逆结构建立辅助分支，不增加推理成本</p>
</li>
<li>
<p>适用于各种规模的深度神经网络</p>
</li>
</ol>
<p>GELAN：</p>
<ol>
<li>轻、快速、准确</li>
<li>采用常规卷积吊打其他新颖卷积</li>
</ol>
<h2 id="related-work">Related work<a hidden class="anchor" aria-hidden="true" href="#related-work">#</a></h2>
<h3 id="21-real-time-object-detectors">2.1 Real-time Object Detectors<a hidden class="anchor" aria-hidden="true" href="#21-real-time-object-detectors">#</a></h3>
<blockquote>
<p>目前主流的实时目标检测器是YOLO系列[2,7,13–15,25,30,31,47–49,61–63,74,75]，这些模型大多数使用CSPNet[64]或 ELAN [65] 及其变体作为主要计算单元。在特征集成方面，通常使用改进的PAN[37]或FPN[35]作为工具，然后使用改进的YOLOv3头[49]或FCOS头[57, 58]作为预测头。最近也提出了一些实时目标检测器，例如 RT DETR [43]，其基础是 DETR [4]。然而，由于DETR系列目标检测器在没有相应领域预训练模型的情况下很难应用于新领域，因此目前应用最广泛的实时目标检测器仍然是YOLO系列。本文选择 YOLOv7 [63] 作为开发该方法的基础，该方法已在各种计算机视觉任务和各种场景中被证明有效。</p>
<p>我们使用 GELAN 来改进所提出的 PGI 的架构和训练过程。上述新颖方法使所提出的 YOLOv9 成为新一代顶级实时目标检测器。</p></blockquote>
<h3 id="22-reversible-architectures">2.2 Reversible Architectures<a hidden class="anchor" aria-hidden="true" href="#22-reversible-architectures">#</a></h3>
<blockquote>
<p><strong>可逆架构</strong>[3,16,19]的运算单元必须保持<strong>可逆转换</strong>的特性，因此可以保证<strong>每层运算单元的输出特征图</strong>都能保留<strong>完整的原始信息</strong>。之前，RevCol[3]将传统的<strong>可逆单元推广到多个层次</strong>，这样做可以扩展<strong>不同层单元表达的语义层次</strong>。通过对各种神经网络架构的文献回顾，我们发现有许多高性能架构具有<strong>不同程度的可逆特性</strong>。例如，Res2Net模块[11]以<strong>分层方式将不同的输入分区与下一个分区组合起来</strong>，并在<strong>向后传递之前连接所有转换后的分区</strong>。 CBNet [34, 39]通过<strong>复合主干网重新引入原始输入数据</strong>以获得<strong>完整的原始信息</strong>，并通过各种组合方法获得<strong>不同级别的多级可逆信息</strong>。这些网络架构通常<strong>具有出色的参数利用率</strong>，但额外的复合层<strong>导致推理速度缓慢</strong>。 DynamicDet [36]结合了CBNet [34]和高效实时目标检测器YOLOv7 [63]，在速度、参数数量和精度之间实现了非常好的权衡。本文介绍了 DynamicDet 架构作为<strong>设计可逆分支的基础</strong>。此外，可逆信息被进一步引入到所提出的PGI中。所提出的新架构在<strong>推理过程中不需要额外的连接</strong>，因此可以充分保留速度、参数量和准确性的优势。</p></blockquote>
<h3 id="23-auxiliary-supervision">2.3 Auxiliary Supervision<a hidden class="anchor" aria-hidden="true" href="#23-auxiliary-supervision">#</a></h3>
<blockquote>
<p><strong>深度监督</strong>[28,54,68]是最常见的<strong>辅助监督方法</strong>，它通过在中<strong>间层插入额外的预测层</strong>来进行训练。尤其是基于Transformer的方法中引入的<strong>多层解码器</strong>的应用是最常见的一种。</p>
<p>另一种常见的辅助监督方法是利用<strong>相关元信息</strong>来指导<strong>中间层产生的特征图</strong>，并使它们<strong>具有目标任务所需的属性</strong>[18,20,24,29,76]。这种类型的示例包括使用<strong>分割损失</strong>或<strong>深度损失</strong>来提高对象检测器的准确性。</p>
<p>最近，文献[53,67,82]中有许多报告使用不同的<strong>标签分配方法</strong>来生成不同的<strong>辅助监督机制</strong>，以加快模型的收敛速度，同时提高鲁棒性。然而，<strong>辅助监督机制</strong>通常只适用于大型模型，因此当其应用于轻量级模型时，很容易造成<strong>欠参数化现象</strong>，从而使性能变差。我们提出的PGI设计了一种<strong>重新编程多级语义信息的方法</strong>，这种设计让<strong>轻量级模型也受益于辅助监督机制</strong>。</p></blockquote>
<h2 id="problem-statement">Problem Statement<a hidden class="anchor" aria-hidden="true" href="#problem-statement">#</a></h2>
<blockquote>
<p>通常，人们将<strong>深度神经网络收敛</strong>问题的困难归因于<strong>梯度消失或梯度饱和</strong>等因素，而这些现象在<strong>传统深度神经网络中确实存在</strong>。然而，现代<strong>深度神经网络已经通过设计各种归一化和激活函数</strong>从根本上解决了上述问题。尽管如此，深度神经网络<strong>仍然存在收敛速度慢或收敛结果差</strong>的问题。</p>
<p>在本文中，我们进一步探讨上述问题的本质。通过对<strong>信息瓶颈</strong>的深入分析，我们推断出这个问题的根本原因是原本来自<strong>很深网络的初始梯度</strong>在<strong>传输后很快就丢失了实现目标所需的大量信息</strong>。为了证实这一推论，我们将<strong>不同架构的深度网络前馈了初始权重</strong>，<strong>然后将其可视化并在图2中进行说明</strong>。显然，<strong>PlainNet丢失了深层物体检测所需的大量重要信息</strong>。至于<strong>ResNet、CSPNet、GELAN能够保留重要信息的比例</strong>，确实与<strong>训练后能够获得的准确率呈正相关</strong>。我们进一步设计了基于可逆网络的方法来解决上述问题的原因。本节我们将详细阐述对信息瓶颈原理和可逆函数的分析。</p></blockquote>
<p><img alt="image-20240301141144309" loading="lazy" src="https://oss.swimmingliu.cn/f71e0bea-d79d-11ee-855e-c858c0c1debd"></p>
<h3 id="31-information-bottleneck-principle">3.1. Information Bottleneck Principle<a hidden class="anchor" aria-hidden="true" href="#31-information-bottleneck-principle">#</a></h3>
<blockquote>
<p>根据信息瓶颈原理，我们知道数据X在进行变换时可能会造成信息丢失，如式(1)所示。</p>
<p><img alt="image-20240301141448840" loading="lazy" src="https://oss.swimmingliu.cn/f75db47c-d79d-11ee-8409-c858c0c1debd"></p>
<p>其中 $I$ 表示相互信息，$f$  和 $g$ 是变换函数，$θ$  和  $ϕ$ 分别是 $f$  和 $g$ 的参数。</p>
<p>在深度神经网络中，$f_θ (·)$ 和 $g_ψ (·)$ 分别表示深度神经网络中<strong>两个连续层的操作</strong>。从方程（1）我们可以预测**，随着网络层数越深，原始数据丢失的可能性就越大**。然而<strong>深度神经网络的参数是基于网络的输出以及给定的目标</strong>，然后通过<strong>计算损失函数生成新的梯度后更新网络</strong>。</p>
<p>可以想象**，更深的神经网络的输出<strong>不太能够</strong>保留有关预测目标的完整信息**。这将使得<strong>在网络训练期间</strong>使用<strong>不完整的信息成为可能</strong>，从而导<strong>致梯度不可靠和收敛性差</strong>。</p>
<p>解决上述问题的一种方法是<strong>直接增加模型的尺寸</strong>。当我们使用<strong>大量的参数来构建模型时</strong>，它<strong>更有能力对数据进行更完整的转换</strong>。上述方法使得<strong>即使在数据前馈过程中信息丢失</strong>，仍然有机会<strong>保留足够的信息来执行到目标的映射</strong>。上述现象解释了为什么在大多数现代模型中<strong>宽度比深度更重要</strong>。然而，上述结论并不能从<strong>根本上解决非常深的神经网络中梯度不可靠</strong>的问题。</p>
<p>下面，我们将介绍如何利用可逆函数来解决问题并进行相关分析。</p></blockquote>
<h3 id="32-reversible-functions">3.2. Reversible Functions<a hidden class="anchor" aria-hidden="true" href="#32-reversible-functions">#</a></h3>
<blockquote>
<p>当函数 $r$ 有一个逆变换函数 $v$ 时，我们称该函数为可逆函数，如式(2)所示。</p>
<p><img alt="image-20240301142046119" loading="lazy" src="https://oss.swimmingliu.cn/f76a4bfa-d79d-11ee-9dd7-c858c0c1debd"></p>
<p>其中 $ψ$ 和  $ζ$ 分别是 $r$ 和 $v$ 的参数。数据 $X$ 通过可逆函数转换而不会丢失信息，如式(3)所示。</p>
<p><img alt="image-20240301142216688" loading="lazy" src="https://oss.swimmingliu.cn/f776463a-d79d-11ee-8857-c858c0c1debd"></p>
<p>当网络的变换函数由<strong>可逆函数组成时</strong>，可以获得<strong>更可靠的梯度来更新模型</strong>。当今流行的深度学习方法几乎都是<strong>符合可逆性质的架构</strong>，例如式（4）。</p>
<p><img alt="image-20240301142339542" loading="lazy" src="https://oss.swimmingliu.cn/f7905b3e-d79d-11ee-ae41-c858c0c1debd"></p>
<p>其中 $l$ 表示 PreAct ResNet 的第 $l$ 层，$f$ 是第 $l$ 层的变换函数。 PreAct ResNet [22] 以<strong>显式方式重复将原始数据 X 传递到后续层</strong>。这样的设计虽然<strong>可以让一千多层的深度神经网络收敛得很好</strong>，但却破坏了<strong>我们需要深度神经网络的一个重要原因</strong>。也就是说，<strong>对于困难的问题</strong>，我们很难直接找到<strong>简单的映射函数将数据映射到目标</strong>。这也解释了<strong>为什么当层数较少时</strong>，PreAct ResNet 的性能比 ResNet [21] 差。</p></blockquote>
<p>【Remind】PreAct ResNet  和 ResNet 结构图比较一下</p>
<blockquote>
<p>此外，我们尝试使用<strong>Masked建模</strong>，使 <strong>Transformer 模型取得重大突破</strong>。我们使用近似方法，例如方程 (5) 尝试求 $r$ 的逆变换 $v$，使得<strong>变换后的特征</strong>能够利用<strong>稀疏特征保留足够的信息</strong>。方程(5) 如下：</p>
<p><img alt="image-20240301143131016" loading="lazy" src="https://oss.swimmingliu.cn/f7aab2ef-d79d-11ee-8df5-c858c0c1debd"></p>
<p>其中 $M$ 是<strong>动态二进制掩码</strong>。其他常用于执行上述任务的方法是<strong>扩散模型</strong>和<strong>可变化自动编码器</strong>，它们都具有<strong>查找反函数的功能</strong>。然而，当我们将上述方法应用于轻量级模型时，<strong>就会存在缺陷</strong>，因为<strong>轻量级模型对大量原始数据的参数化不足</strong>。由于上述原因，将<strong>数据 $X$ 映射到目标 $Y$ 的重要信息</strong> $I(Y，X)$ 也会面临同样的问题。对于这个问题，我们将使用<strong>信息瓶颈的概念来探讨它</strong>[59]。信息瓶颈的计算公式如下：</p>
<p><img alt="image-20240301143317744" loading="lazy" src="https://oss.swimmingliu.cn/f7bd2281-d79d-11ee-8f92-c858c0c1debd"></p>
<p>一般来说，$I(Y,X)$ 只会占据 $I(X,X)$ 的很小一部分。然而，这对于<strong>目标任务至关重要</strong>。因此，即使<strong>前馈阶段丢失的信息量并不大</strong>，只要覆盖了 $I(Y,X)$，<strong>训练效果就会受到很大影响</strong>。轻量级模型本身处于<strong>欠参数化状态</strong>，因此在<strong>前馈阶段很容易丢失很多重要信息</strong>。因此，我们轻量级模型的目标是如何从 $I(X, X)$ 中准确<strong>过滤</strong>出 $I(Y, X)$。至于<strong>完全保留 $X$ 的信息</strong>，这是<strong>很难做到的</strong>。基于上述分析，我们希望提出一种新的深度神经网络训练方法，不仅能够<strong>生成可靠的梯度来更新模型</strong>，而且适用于<strong>浅层和轻量级神经网络</strong>。</p></blockquote>
<h2 id="methodology">Methodology<a hidden class="anchor" aria-hidden="true" href="#methodology">#</a></h2>
<h3 id="41-programmable-gradient-information">4.1 Programmable Gradient Information<a hidden class="anchor" aria-hidden="true" href="#41-programmable-gradient-information">#</a></h3>
<blockquote>
<p>为了解决上述问题，我们提出了一种新的<strong>辅助监督框架</strong>，称为<strong>可编程梯度信息</strong>（PGI），如图3（d）所示。 PGI主要包括三个组成部分，即（1）<strong>主分支</strong>，（2）辅助可逆分支，（3）<strong>多级辅助信息</strong>。从图3(d)中我们可以看出，<strong>PGI的推理过程仅使用主分支</strong>，因此<strong>不需要任何额外的推理成本</strong>。</p></blockquote>
<p><img alt="image-20240301143756951" loading="lazy" src="https://oss.swimmingliu.cn/f7d03aa8-d79d-11ee-a606-c858c0c1debd"></p>
<blockquote>
<p>至于其他两个组件，<strong>它们用于解决或减缓深度学习方法中的几个重要问题</strong>。其中，<strong>辅助可逆分支</strong>是为了<strong>处理神经网络加深带来的问题</strong>而设计的。网络加深会造成<strong>信息瓶颈</strong>，导致<strong>损失函数无法生成可靠的梯度</strong>。对于多级辅助信息，旨在<strong>处理深度监督带来的误差累积问题</strong>，特别是<strong>针对多个预测分支的架构和轻量级模型</strong>。接下来我们将逐步介绍这两个组件。</p></blockquote>
<h4 id="411-auxiliary-reversible-branch">4.1.1 Auxiliary Reversible Branch<a hidden class="anchor" aria-hidden="true" href="#411-auxiliary-reversible-branch">#</a></h4>
<blockquote>
<p>在PGI中，我们提出了<strong>辅助可逆分支</strong>来生成<strong>可靠的梯度</strong>并更新网络参数。通过提供从<strong>数据映射到目标的信息</strong>，损失函数可以提供<strong>指导并避免从与目标不太相关的不完整前馈特征中发现错误相关性的可能性</strong>。我们提出通过<strong>引入可逆架构来维护完整信息</strong>，但是<strong>在可逆架构中添加主分支会消耗大量的推理成本</strong>。</p>
<p>我们分析了图3(b)的架构，发现当<strong>添加从深层到浅层的额外连接时</strong>，<strong>推理时间将增加20%</strong>。当我们反复将输入数据添加到网络的**高分辨率计算层（黄色框）**时，<strong>推理时间甚至超过了两倍</strong>。</p>
<p>由于我们的目标是使用<strong>可逆架构</strong>来获得可靠的梯度，因此**“可逆”并不是推理阶段的唯一必要条件**。鉴于此，我们将可逆分支视为<strong>深度监督分支的扩展</strong>，然后设计辅助可逆分支，如图3(d)所示。对于由于<strong>信息瓶颈而丢失重要信息</strong>的主分支深度特征，它们将能够从<strong>辅助可逆分支接收可靠的梯度信息</strong>。</p>
<p>这些<strong>梯度信息</strong>将<strong>驱动参数学习来协助提取正确且重要的信息</strong>，上述动作可以<strong>使主分支获得对目标任务更有效的特征</strong>。此外，<strong>可逆架构在浅层网络上</strong>的表现比<strong>在一般网络上差</strong>，因为复杂的任务需要在更深的网络中进行转换。我们提出的方法并<strong>不强迫主分支保留完整的原始信息</strong>，而是<strong>通过辅助监督机制生成有用的梯度来更新它</strong>。这种设计的优点是所提出的方法也可以<strong>应用于较浅的网络</strong>。</p>
<p>最后，由于在推理阶段可以去除辅助可逆分支，因此可以<strong>保留原始网络的推理能力</strong>。我们也可以<strong>选择PGI中的任意可逆架构来起到辅助可逆分支的作用</strong>。</p></blockquote>
<h4 id="412-multi-level-auxiliary-information">4.1.2 Multi-level Auxiliary Information<a hidden class="anchor" aria-hidden="true" href="#412-multi-level-auxiliary-information">#</a></h4>
<blockquote>
<p>在本节中，我们将讨论<strong>多级辅助信息</strong>如何工作。包括<strong>多个预测分支</strong>的<strong>深度监督架构</strong>如图 3 (c) 所示。对于目标检测，<strong>不同的特征金字塔可用于执行不同的任务</strong>，例如它们一起可以<strong>检测不同大小的目标</strong>。因此，连接到<strong>深度监督分支后</strong>，会引导<strong>浅层特征学习小物体检测所需的特征</strong>，此时<strong>系统会将其他尺寸的物体的位置</strong>视为<strong>背景</strong>。然而，上述行为会导致<strong>深层特征金字塔丢失大量预测目标对象所需的信息</strong>。关于这个问题，我们认为<strong>每个特征金字塔</strong>都需要<strong>接收所有目标对象的信息</strong>，以便<strong>后续的主分支可以保留完整的信息</strong>来学习对各种目标的预测。</p></blockquote>
<p>辅助可逆分支： (1) 可以还原所有的特征信息 （2）推理的时候，不会额外增加计算量</p>
<p>多级辅助信息： 不分大、中、小目标，把所有物体的特征都汇聚在一起</p>
<h3 id="42-generalized-elan">4.2. Generalized ELAN<a hidden class="anchor" aria-hidden="true" href="#42-generalized-elan">#</a></h3>
<blockquote>
<p>在本节中，我们将描述所提出的新网络架构——<strong>GELAN</strong>。通过结合采用<strong>梯度路径规划设计的两种神经网络架构</strong>CSPNet [64]和ELAN [65]，我们设计了兼顾轻量级、推理速度和准确性的广义高效层聚合网络（GELAN）。其整体架构如图 4 所示。我们将最初<strong>仅使用卷积层堆叠的 ELAN</strong> [65] 的功能推广到<strong>可以使用任何计算块的新架构</strong>。</p></blockquote>
<p>ELAN 和 GELAN 的区别：</p>
<ul>
<li>
<p>ELAN使用的是常规的卷积操作</p>
</li>
<li>
<p>GELAN是把卷积换成了任意的模块，最后转到相同的通道数、相同维度大小即可</p>
</li>
</ul>
<p><img alt="image-20240301145407527" loading="lazy" src="https://oss.swimmingliu.cn/f7eef375-d79d-11ee-bdb6-c858c0c1debd"></p>
<h2 id="experiments">Experiments<a hidden class="anchor" aria-hidden="true" href="#experiments">#</a></h2>
<p>实验是一篇论文，审稿人看的比较仔细的地方。学习一下别人的写法</p>
<p>附录可以给审稿人和读者，更直观的看到实现的细节</p>
<h3 id="51-experimental-setup">5.1. Experimental Setup<a hidden class="anchor" aria-hidden="true" href="#51-experimental-setup">#</a></h3>
<blockquote>
<p>我们使用 MS COCO 数据集验证了所提出的方法。</p>
<p>所有实验设置均遵循 YOLOv7 AF [63]，而数据集为 MS COCO 2017 分割。我们提到的所有模型都是使用从头开始训练策略进行训练的，总训练次数为 500 epoch。在设置学习率时，我们在前三个epoch中使用线性预热，随后的epoch根据模型规模设置相应的衰减方式。至于最后 15 个时期，我们关闭马赛克数据增强。更多设置请参考附录。</p></blockquote>
<h3 id="52-implementation-details">5.2 Implementation Details<a hidden class="anchor" aria-hidden="true" href="#52-implementation-details">#</a></h3>
<blockquote>
<p>我们分别基于 <strong>YOLOv7</strong> [63] 和 <strong>Dynamic YOLOv7</strong> [36] 构建了 YOLOv9 的通用版本和扩展版本。</p>
<p>在网络架构的设计中，我们使用 <strong>CSPNet</strong> 块 [64] 和计划的 RepConv [63] 作为计算块，用 GELAN 替换了 ELAN [65]。我们还简化了下采样模块并优化了无锚预测头。至于PGI的辅助损失部分，我们完全遵循YOLOv7的辅助头设置。详情请参阅附录。</p></blockquote>
<p><img alt="image-20240301145938462" loading="lazy" src="https://oss.swimmingliu.cn/f822dbbc-d79d-11ee-9116-c858c0c1debd"></p>
<h3 id="53-comparison-with-state-of-the-arts">5.3 Comparison with state-of-the-arts<a hidden class="anchor" aria-hidden="true" href="#53-comparison-with-state-of-the-arts">#</a></h3>
<blockquote>
<p>表 1 列出了我们提出的 YOLOv9 与其他从头开始训练的实时目标检测器的比较。总体而言，现有方法中性能最好的方法是<strong>用于轻量级模型的 YOLO MS-S</strong> [7]、用于<strong>中型模型的 YOLO MS</strong> [7]、用于通用模型的 YOLOv7 AF [63] 和<strong>用于大型模型的 YOLOv8-X</strong> [15]。与<strong>轻量级和中型模型YOLO MS</strong>[7]相比，<strong>YOLOv9的参数减少了约10%，计算量减少了5∼15%，但AP仍然有0.4∼0.6%的提升</strong>。与<strong>YOLOv7 AF相比</strong>，<strong>YOLOv9-C的参数减少了42%，计算量减少了21%，但达到了相同的AP（53%）</strong>。与<strong>YOLOv8-X相比</strong>，YOLOv9-X<strong>参数减少15%</strong>，<strong>计算量减少25%</strong>，AP显着提升1.7%。上述对比结果表明，我们提出的YOLOv9与现有方法相比在各方面都有显着改进。</p>
<p>另一方面，我们也将ImageNet预训练模型纳入对比，<strong>结果如图5所示</strong>。我们分别根据参数和计算量进行比较。就参数数量而言，性能最好的大型模型是 <strong>RT DETR</strong> [43]。从图5中我们可以看到，使用传统卷积的<strong>YOLOv9在参数利用率上</strong>甚至比使用<strong>深度卷积的YOLO MS</strong>还要好。至于大型模型的参数利用率，也大大超过了使用ImageNet预训练模型的<strong>RT DETR</strong>。更棒的是，<strong>在深度模型中，YOLOv9展示了使用PGI的巨大优势</strong>。通过准确<strong>保留和提取将数据映射到目标所需的信息</strong>，我们的方法仅<strong>需要 64% 的参数</strong>，同时保持 <strong>RT DETR-X</strong> 的精度。</p></blockquote>
<p><img alt="image-20240301150308525" loading="lazy" src="https://oss.swimmingliu.cn/f83c3be4-d79d-11ee-a260-c858c0c1debd"></p>
<blockquote>
<p>至于计算量，现有最好的模型从最小到最大依次是<strong>YOLO MS</strong> [7]、<strong>PP YOLOE</strong> [74]和<strong>RT DETR</strong> [43]。从图5中我们可以看到，<strong>YOLOv9在计算复杂度方面远远优于从头开始训练的方法</strong>。另外，如果与基于深度卷积和基于ImageNet的预训练模型相比，YOLOv9也很有竞争力。</p></blockquote>
<h3 id="54-ablation-studies">5.4 Ablation Studies<a hidden class="anchor" aria-hidden="true" href="#54-ablation-studies">#</a></h3>
<h4 id="541-generalized-elan">5.4.1 Generalized ELAN<a hidden class="anchor" aria-hidden="true" href="#541-generalized-elan">#</a></h4>
<blockquote>
<p>对于 <strong>GELAN</strong>，我们首先对<strong>计算模块进行消融研究</strong>。我们分别使用<strong>Res块</strong>[21]、<strong>Dark</strong>块[49]和<strong>CSP</strong>块[64]进行实验。表2表明，用不同的计算块替换ELAN中的卷积层后，系统可以保持良好的性能。用户确实可以自由更换计算块并在各自的推理设备上使用它们。在不同的计算块替换中，<strong>CSP 块的性能特别好</strong>。它们<strong>不仅减少了参数量和计算量</strong>，而且<strong>将 AP 提高了 0.7%</strong>。因此，我们选择CSPELAN作为YOLOv9中GELAN的组成单元。</p></blockquote>
<p><img alt="image-20240301150606317" loading="lazy" src="https://oss.swimmingliu.cn/f86e2a95-d79d-11ee-b7d5-c858c0c1debd"></p>
<blockquote>
<p>接下来，我们对不同尺寸的<strong>GELAN</strong>进行<strong>ELAN块深度和CSP块深度实验</strong>，并将结果显示在表3中。我们可以看到，当<strong>ELAN的深度从1增加到2时</strong>，<strong>精度显着提高</strong>。但当<strong>深度大于等于2时</strong>，无论是<strong>提高ELAN深度还是CSP深度</strong>，<strong>参数数量、计算量和精度总是呈现线性关系</strong>。这意味着 GELAN 对深度不敏感。</p>
<p>也就是说，用户可以任意组合GELAN中的组件来设计网络架构，无需特殊设计即可拥有性能稳定的模型。在表3中，对于YOLOv9-{S,M,C}，我们将ELAN深度和CSP深度的配对设置为{{2, 3}, {2, 1}, {2, 1}}。</p></blockquote>
<p><img alt="image-20240301150722270" loading="lazy" src="https://oss.swimmingliu.cn/f8979acd-d79d-11ee-8ed1-c858c0c1debd"></p>
<h4 id="542-programmable-gradient-information">5.4.2 Programmable Gradient Information<a hidden class="anchor" aria-hidden="true" href="#542-programmable-gradient-information">#</a></h4>
<blockquote>
<p>在PGI方面，我们分别对<strong>backbone</strong>和<strong>neck</strong>的<strong>辅助可逆分支和多级辅助信息</strong>进行了消融研究。我们设计了<strong>辅助可逆分支ICN</strong>来使用<strong>DHLC[34]链接来获取多级可逆信息</strong>。对于多级辅助信息，我们使<strong>用FPN和PAN进行消融研究</strong>，<strong>PFH的作用相当于传统的深度监督</strong>。所有实验的结果列于表4中。从表4中我们可以看出，<strong>PFH仅在深度模型中有效</strong>，而我们提出的<strong>PGI可以在不同组合下提高精度</strong>。尤其是使用<strong>ICN</strong>时，我们得到了稳定且更好的结果。我们还尝试将YOLOv7[63]中提出的lead-head指导分配应用于PGI的辅助监督，并取得了更好的性能。</p></blockquote>
<p><img alt="image-20240301151231610" loading="lazy" src="https://oss.swimmingliu.cn/f8af98a0-d79d-11ee-9a8b-c858c0c1debd"></p>
<blockquote>
<p>我们进一步将<strong>PGI和深度监督的概念应用到不同规模</strong>的模型上，并比较结果，结果如表5所示。正如一开始分析的那样，<strong>深度监督的引入会导致浅层模型精度的损失</strong>。对于一般模型来说，引入深度监督会导致性能不稳定，<strong>而深度监督的设计理念只能在极深的模型中带来收益</strong>。所提出的<strong>PGI可以有效处理信息瓶颈和信息破碎等问题</strong>，并且<strong>可以全面提高不同规模模型的准确性</strong>。 PGI 的概念带来了两个宝贵的贡献。第一个是让<strong>辅助监督方法适用于浅层模型</strong>，第二个是<strong>让深层模型训练过程获得更可靠的梯度</strong>。这些梯度使深度模型能够使用更准确的信息来建立数据和目标之间的正确相关性</p></blockquote>
<p><img alt="image-20240301151535996" loading="lazy" src="https://oss.swimmingliu.cn/f8da863f-d79d-11ee-822a-c858c0c1debd"></p>
<blockquote>
<p>最后，我们在表中显示了从基线 YOLOv7 到 YOLOv9E 逐渐增加组件的结果。我们提出的GELAN和PGI给模型带来了全面的改进。</p></blockquote>
<p><img alt="image-20240301151749920" loading="lazy" src="https://oss.swimmingliu.cn/f908a8cb-d79d-11ee-b28a-c858c0c1debd"></p>
<h3 id="55-visualization">5.5 Visualization<a hidden class="anchor" aria-hidden="true" href="#55-visualization">#</a></h3>
<blockquote>
<p>本节将<strong>探讨信息瓶颈问题并将其可视化</strong>。此外，我们<strong>还将可视化所提出的 PGI 如何使用可靠的梯度来找到数据和目标之间的正确相关性</strong>。在图6中，<strong>我们展示了在不同架构下使用随机初始权重作为前馈获得的特征图的可视化结果</strong>。我们可以看到，<strong>随着层数的增加，所有架构的原始信息逐渐减少</strong>。例如，<strong>在PlainNet的第50层，很难看到物体的位置</strong>，并且<strong>所有可区分的特征将在第100层丢失</strong>。对于ResNet，虽然在<strong>第50层仍然可以看到物体的位置，但边界信息已经丢失</strong>。当深度达到第100层时，整个图像变得模糊。 <strong>CSPNet 和提出的 GELAN 都表现得非常好</strong>，并且它们都可以保<strong>持支持清晰识别对象的特征直到第 200 层</strong>。对比中，GELAN结果更稳定，边界信息更清晰</p></blockquote>
<p><img alt="image-20240301152036432" loading="lazy" src="https://oss.swimmingliu.cn/f91e409b-d79d-11ee-8ec9-c858c0c1debd"></p>
<blockquote>
<p>图7用于展示PGI是否可以<strong>在训练过程中提供更可靠的梯度</strong>，使得用于<strong>更新的参数能够有效捕获输入数据与目标之间的关系</strong>。图7显示了<strong>GELAN和YOLOv9（GELAN + PGI）<strong>的特征图在</strong>PAN偏置预热中的可视化结果</strong>。从图7（b）和（c）的比较中，我们可以清楚地看到PGI准确而简洁地捕获了包含对象的区域**。对于不使用PGI的GELAN，我们发现它在检测物体边界时存在发散**，并且在某些<strong>背景区域也产生了意想不到的响应</strong>。这个<strong>实验证实了PGI确实可以提供更好的梯度来更新参数，并使主分支的前馈阶段能够保留更重要的特征</strong>。</p></blockquote>
<p><img alt="image-20240301152145009" loading="lazy" src="https://oss.swimmingliu.cn/f9995762-d79d-11ee-b458-c858c0c1debd"></p>
<h2 id="conclusions">Conclusions<a hidden class="anchor" aria-hidden="true" href="#conclusions">#</a></h2>
<blockquote>
<p>在本文中，我们提出使用<strong>PGI来解决信息瓶颈问题</strong>以及深<strong>度监督机制</strong>不适<strong>合轻量级神经网络的问题</strong>。我们设计了 GELAN，一个高效、轻量级的神经网络。在物体检测方面，<strong>GELAN在不同的计算块和深度设置下都具有强大且稳定的性能</strong>。它<strong>确实可以广泛扩展为适合各种推理设备的模型</strong>。针对以上两个问题，PGI的引入<strong>使得轻量级模型和深度模型</strong>都获得了精度的显着提升。 PGI和GELAN相结合设计的YOLOv9已经展现出强大的竞争力。<strong>其出色的设计使得深度模型相比YOLOv8减少了49%的参数数量和43%的计算量</strong>，但在MS COCO数据集上仍然有0.6%的AP提升。</p></blockquote>


  </div>



  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://swimmingliu.cn/tags/yolo/">YOLO</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://swimmingliu.cn/posts/papernotes/2023-dbnet/">
    <span class="title">« Prev</span>
    <br>
    <span>A Dual-Branch Framework with Prior Knowledge for Precise Segmentation of Lung Nodules in Challenging CT Scans</span>
  </a>
  <a class="next" href="https://swimmingliu.cn/posts/diary/yoloshow/">
    <span class="title">Next »</span>
    <br>
    <span>YOLOSHOW - YOLOv5/YOLOv7/YOLOv8/YOLOv9/RTDETR GUI based on Pyside6</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2023-2025 <a href="https://swimmingliu.cn/">SwimmingLiu&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
    <span>
        <a href="https://beian.miit.gov.cn/">浙ICP备2024056260号</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
