<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Java on SwimmingLiu&#39;s Blog</title>
    <link>https://swimmingliu.cn/tags/java/</link>
    <description>Recent content in Java on SwimmingLiu&#39;s Blog</description>
    <image>
      <title>SwimmingLiu&#39;s Blog</title>
      <url>https://swimmingliu.cn/papermod-cover.png</url>
      <link>https://swimmingliu.cn/papermod-cover.png</link>
    </image>
    <generator>Hugo -- 0.136.0</generator>
    <language>en</language>
    <lastBuildDate>Fri, 07 Mar 2025 21:44:36 +0800</lastBuildDate>
    <atom:link href="https://swimmingliu.cn/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>设计模式面试题笔记</title>
      <link>https://swimmingliu.cn/posts/job/desgin-mode-interview-questions/</link>
      <pubDate>Fri, 07 Mar 2025 21:44:36 +0800</pubDate>
      <guid>https://swimmingliu.cn/posts/job/desgin-mode-interview-questions/</guid>
      <description>&lt;h2 id=&#34;1-单例模式有哪几种实现如何保证线程安全&#34;&gt;1. 单例模式有哪几种实现？如何保证线程安全？&lt;/h2&gt;
&lt;p&gt;首先，单例模式和工厂模式都是一种设计模式。单例模式当中，一个类只允许创建一个对象(或者说实例)， 那这个类就是单例类。单例类是不可以被继承的，也没有了多态的特性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【单例类的实现方式】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常规单例模式有五种写法，但是编写代码的过程当中，要注意以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;构造器需要私有化&lt;/li&gt;
&lt;li&gt;暴露一个公共获取单例对象的接口 （&lt;code&gt;obj.getInstance()&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;是否支持懒加载 &lt;code&gt;延迟加载&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;是否线程安全&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;五种写法为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;饿汉式&lt;/strong&gt;： 类加载的时候，就一起把 &lt;code&gt;instance&lt;/code&gt; 静态实例创建好了，所以创建的过程市线程安全的。&lt;/p&gt;
&lt;p&gt;饿汉式的单例模式虽然不支持懒加载，有点浪费资源。但其实不会占用太多资源，并且如果一个实例初始化的过程比较复杂，就应该放在启动的时候来处理，避免运行时卡顿或发生问题， 满足&lt;code&gt;fail-fast&lt;/code&gt; 失败快速解决的设计原则&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;EagerSingleton&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Singleton&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;instance&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Singleton&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Singleton&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Singleton&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;getInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    	&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;instance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;懒汉式&lt;/strong&gt;：相较于饿汉式的方式，修改成延迟加载的模式。注意&lt;code&gt;getInstance()&lt;/code&gt;方法没有上锁的话，在大量线程并发请求的时候，可能创建多个实例。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Singleton&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Singleton&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;instance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Singleton&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;synchronized&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Singleton&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;getInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;instance&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;instance&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Singleton&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;instance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;双重检查锁&lt;/strong&gt;：饿汉式锁不支持延迟加载，然后懒汉式锁的粒度比较大，不支持高并发。双重检查锁可以实现既延迟加载，又支持高并发。其实就是在判断了没有实例之后，再进行上锁，创建实例。 但是实例必须用&lt;code&gt;volatile&lt;/code&gt; 修饰，不然&lt;code&gt;new&lt;/code&gt; 操作创建对象时，容易出现重排序的问题。&lt;/p&gt;</description>
    </item>
    <item>
      <title>(JUC) Java并发面试题笔记</title>
      <link>https://swimmingliu.cn/posts/job/java-juc-interview-questions/</link>
      <pubDate>Wed, 05 Mar 2025 21:45:49 +0800</pubDate>
      <guid>https://swimmingliu.cn/posts/job/java-juc-interview-questions/</guid>
      <description>&lt;h1 id=&#34;juc-java并发面试题笔记&#34;&gt;(JUC) Java并发面试题笔记&lt;/h1&gt;
&lt;h2 id=&#34;1-什么是-java-内存模型jmm&#34;&gt;1. 什么是 Java 内存模型（JMM）？&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;JMM&lt;/code&gt; 是 Java内存模型 ， 它是Java虚拟机 &lt;code&gt;JVM&lt;/code&gt; 定义的一种规范，用于描述多线程程序中的变量，像实例字段、静态字段和数组元素，他们如何在内存中存储和传递的规则。也就是规定线程啥时候从住内存里面读数据，啥时候把数据写回到住内存。&lt;code&gt;JMM&lt;/code&gt; 的核心目标是确保多线程环境下的&lt;strong&gt;可见性&lt;/strong&gt;、&lt;strong&gt;有序性&lt;/strong&gt;和&lt;strong&gt;原子性&lt;/strong&gt;, 避免硬件和编译器优化带来的不一致问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【可见性、有序性、原子性定义】&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;可见性&lt;/strong&gt;：确保一个线程对共享变量的修改，能够及时被另外一个线程看到。 &lt;code&gt;volatile&lt;/code&gt;就是用来保证可见性的，强制线程每次读写的时候，直接从主内存当中获取最新值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;有序性&lt;/strong&gt;：指线程执行操作的顺序。JMM允许某些指令重排序之后再提高性能，但会保证线程内的操作顺序不会被破坏。通过&lt;code&gt;happens-before&lt;/code&gt; (线程A发生在线程B之前)的关系来保证跨线程的有序性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;原子性&lt;/strong&gt;：操作不可分割，线程不会在执行的过程当中被打断。例如, &lt;code&gt;synchronize&lt;/code&gt; 关键字能确保方法或代码块的原子性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;【JMM作用】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为不同的操作系统都有一套独立的内存模型，但是Java为了满足跨平台的特性，它需要定义一套内存模型屏蔽个操作系统之间的差异。我们可以利用JMM当中定义好的从Java源码到CPU指令的执行规范，也就是使用&lt;code&gt;synchronized&lt;/code&gt; 、&lt;code&gt;volatile&lt;/code&gt; 等关键字，还有&lt;code&gt;happens-before&lt;/code&gt;原则，就可以写出并发安全的代码了。
比如说，线程A和线程B同时操作 &lt;code&gt;变量-1&lt;/code&gt;，假如最开始&lt;code&gt;变量-1&lt;/code&gt; 是 &lt;code&gt;0&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先，线程A和线程B都读取了&lt;code&gt;变量-1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;然后，线程B对取到的&lt;code&gt;变量-1&lt;/code&gt;自增为&lt;code&gt;1&lt;/code&gt;，并写回主内存&lt;/li&gt;
&lt;li&gt;此时，线程A对读取到的&lt;code&gt;变量-1&lt;/code&gt;也自增&lt;code&gt;1&lt;/code&gt;，并写回主内存。这就会导致线程B的操作失效了，出现并发安全问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果有JMM，我们就可以在线程A要修改数据之前,让它采用CAS乐观锁的方式进行修改。再次去读主内存当中的值，然后修改之后，再判断一下主内存的值是否发生变化。如果没有发生变化，就写回主内存。如果发生变化，就要进行自旋。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【注意】&lt;/strong&gt; 工作内存是每个线程独立的内存空间，其他线程都是看不到的。主内存是Java堆内存的一部分，所有的实例变量、静态变量和数组元素都存储在主内存当中。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;JMM架构图&#34; loading=&#34;lazy&#34; src=&#34;https://oss.swimmingliu.cn/49ddf552-f9c8-11ef-99c5-c858c0c1deba&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【内存间交互操作类型 (8种原子操作)】&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;lock 上锁&lt;/strong&gt;：把一个变量表示为一条线程独占的状态&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;unlock 解锁&lt;/strong&gt;： 把一个变量从独占状态中释放出来，释放后的变量才能被其他线程锁定&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;read 读取&lt;/strong&gt;： 从主内存当中读取一个变量到工作内存中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;load 载入&lt;/strong&gt;：把&lt;code&gt;read&lt;/code&gt;操作从主内存中得到的变量值放入工作内存的变量副本当中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;use 使用&lt;/strong&gt;：把工作内存当中的一个变量值传递给执行引擎&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;assign 赋值&lt;/strong&gt;：把一个从执行引擎接收到的值赋给工作内存中的变量&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;store 存储&lt;/strong&gt;：把工作内存中的一个变量的值传送给主内存中&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;write 写入&lt;/strong&gt;：把store操作从工作内存中得到的变量值放入主内存的变量中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;【volatile 特殊规则】&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;可见性&lt;/strong&gt;：对于 &lt;code&gt;volatile&lt;/code&gt; 修饰的变量的写操作会立即刷新到内存中，任何线程对这个&lt;code&gt;volatile&lt;/code&gt; 变量的读操作都能立即看到最新的值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;禁止指令重排序&lt;/strong&gt;： 在对 &lt;code&gt;volatile&lt;/code&gt; 变量进行读/写操作的时候，会插入内存屏障，禁止指令重排序。也就是该变量的写操作不能与之前的读/写操作重排序，它的都操作不能与之后的读/写操作重排序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;【Happens-Before 原则】&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>操作系统面试题笔记</title>
      <link>https://swimmingliu.cn/posts/job/operation-system-interview-questions/</link>
      <pubDate>Sat, 01 Mar 2025 09:49:44 +0800</pubDate>
      <guid>https://swimmingliu.cn/posts/job/operation-system-interview-questions/</guid>
      <description>&lt;h2 id=&#34;1-说说你知道的几种-io-模型&#34;&gt;1. 说说你知道的几种 I/O 模型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;【常见的五大I/O模型】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常见的五大I/O模式分别为: 同步阻塞I/O (Blocking I/O) &lt;code&gt;BIO&lt;/code&gt;、非阻塞I/O (Non-blocking I/O) &lt;code&gt;NIO&lt;/code&gt;、I/O多路复用、信号量驱动I/O、异步I/O &lt;code&gt;AIO&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们假如要烧水喝，看不同模型是怎么烧的水喝&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;strong&gt;I/O 模型&lt;/strong&gt;&lt;/th&gt;
          &lt;th&gt;特性&lt;/th&gt;
          &lt;th&gt;烧水案例&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;同步阻塞I/O &lt;code&gt;BIO&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;数据从网卡到内核，再从内核到用户空间，都是阻塞操作。&lt;/td&gt;
          &lt;td&gt;自己动手烧水，一直盯着，等水烧开了，倒在杯子里喝。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;非阻塞I/O &lt;code&gt;NIO&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;数据从网卡到内核不阻塞，&lt;code&gt;read&lt;/code&gt;不到数据直接返回，但是从内核到用户空间会阻塞 (用户轮询&lt;code&gt;read&lt;/code&gt;)&lt;/td&gt;
          &lt;td&gt;自己动手烧水，隔两分钟看一下，水烧开没有。等水烧开了，倒在杯子里喝。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;I/O多路复用&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;只有一个线程查看多个连接是否有数据准备就绪 (看从网卡能不能&lt;code&gt;read&lt;/code&gt;到数据到内核)&lt;/td&gt;
          &lt;td&gt;找专门烧水的领居帮忙，他把水烧好了之后，会喊你来拿。但是你要自己倒在杯子里喝。&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;信号驱动I/O&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;数据从网卡到内核之后会自动通知用户程序，然后让他&lt;code&gt;read&lt;/code&gt;读取数据&lt;/td&gt;
          &lt;td&gt;去烧水房烧水，全自动的，有个通知灯。水烧完了之后会按你家的门铃，但是有客人来了，也会按门铃&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;异步I/O &lt;code&gt;AIO&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;全程不阻塞，拷贝到用户空间之后直接回调。&lt;/td&gt;
          &lt;td&gt;和多路复用类似，但是烧完水之后不用自己倒水，他帮你倒好了，还吹凉了，你过来喝就行。&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img alt=&#34;IO五种模型&#34; loading=&#34;lazy&#34; src=&#34;https://oss.swimmingliu.cn/3bbe065d-f63f-11ef-a797-c858c0c1deba&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>个人简历常问问题</title>
      <link>https://swimmingliu.cn/posts/job/personal-interview-hot-question/</link>
      <pubDate>Thu, 27 Feb 2025 10:52:54 +0800</pubDate>
      <guid>https://swimmingliu.cn/posts/job/personal-interview-hot-question/</guid>
      <description>&lt;p&gt;个人简历详情查看 -&amp;gt; &lt;a href=&#34;https://rxresu.me/dashboard/resumes&#34;&gt;个人简历页&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;1-异步秒杀机制的异步是如何实现的&#34;&gt;1. 异步秒杀机制的异步是如何实现的?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;【正常秒杀的顺序】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;查询优惠券 -&amp;gt; 判断秒杀库存 -&amp;gt; 查询订单 -&amp;gt; 校验是否一人一单 -&amp;gt; 扣减库存 -&amp;gt; 创建订单&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【异步秒杀】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了实现用户异步下单，其实就是把是否能够下单的判断逻辑和下单的操作拆分开。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;采用Redis来判断是否有足够的库存和校验一人一单
&lt;ul&gt;
&lt;li&gt;如果满足条件，把用户、订单id、商品id保存到阻塞队列，直接给用户返回秒杀成功。&lt;/li&gt;
&lt;li&gt;如果不满足条件，直接返回秒杀失败。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;后台线程会去执行queue里边的消息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样就可以实现异步的秒杀下单了，那么如果实现判断秒杀库存和校验一人一单呢？&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;1653561657295&#34; loading=&#34;lazy&#34; src=&#34;https://oss.swimmingliu.cn/8f260a35-f4b5-11ef-a915-c858c0c1deba&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【秒杀库存 + 一人一单】&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户下单之后，判断redis当中的库存key的value是否大于&lt;code&gt;0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;value &amp;gt; 0&lt;/code&gt; -&amp;gt; 第2步&lt;/li&gt;
&lt;li&gt;&lt;code&gt;value &amp;lt;= 0&lt;/code&gt; -&amp;gt; 直接返回库存不足 （返回&lt;code&gt;1&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果库存充足，判断redis当中的秒杀商品key的 &lt;code&gt;set&lt;/code&gt; 集合是否已包含&lt;code&gt;userid&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;包含&lt;code&gt;userid&lt;/code&gt;， 说明用户已经下单了，直接返回当前用户已下单 (返回&lt;code&gt;2&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;不包含 &lt;code&gt;userid&lt;/code&gt; -&amp;gt; 第3步&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果用户没有下单，将用户的 &lt;code&gt;userid&lt;/code&gt; 存入 &lt;code&gt;set&lt;/code&gt; 里面 (返回&lt;code&gt;0&lt;/code&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;【注意】&lt;/strong&gt; 整个操作是原子性的，这样就确保了不会出现&lt;strong&gt;超卖现象和一人多单现象&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;-- 1.参数列表&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;-- 1.1.秒杀商品id&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;local&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;voucherId&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ARGV&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;-- 1.2.用户id&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;local&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;userId&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ARGV&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;-- 1.3.订单id&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;local&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;orderId&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ARGV&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;-- 2.数据key&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;-- 2.1.库存key&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;local&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stockKey&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;seckill:stock:&amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;..&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;voucherId&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;-- 2.2.秒杀商品订单key&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;local&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;orderKey&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;seckill:order:&amp;#39;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;..&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;voucherId&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;-- 3.脚本业务&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;-- 3.1.判断库存是否充足 get stockKey&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kr&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tonumber&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redis.call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;get&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stockKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;-- 3.2.库存不足，返回1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kr&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kr&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;-- 3.2.判断用户是否下单 SISMEMBER orderKey userId&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kr&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redis.call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;sismember&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;orderKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;userId&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;then&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;-- 3.3.存在，说明是重复下单，返回2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kr&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kr&#34;&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kr&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;【阻塞队列实现下单】&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Redis面试题笔记</title>
      <link>https://swimmingliu.cn/posts/job/redis-interview-questions/</link>
      <pubDate>Thu, 20 Feb 2025 21:21:45 +0800</pubDate>
      <guid>https://swimmingliu.cn/posts/job/redis-interview-questions/</guid>
      <description>&lt;h2 id=&#34;1-redis主从复制的原理&#34;&gt;1. Redis主从复制的原理&lt;/h2&gt;
&lt;p&gt;【&lt;strong&gt;主从复制的原理&lt;/strong&gt;】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同步：从节点向主节点发送&lt;code&gt;psync&lt;/code&gt;命令进行同步，从节点保存主节点返回的 &lt;code&gt;runid&lt;/code&gt; 和 &lt;code&gt; offset&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;全量复制：如果是第一次连接或者连接失败且&lt;code&gt;repl_backlog_buffer&lt;/code&gt; 缓存区不包含&lt;code&gt;slave_repl_offset&lt;/code&gt;， 则生成主节点的数据快照(RDB文件)发给从节点&lt;/li&gt;
&lt;li&gt;增量复制：全量复制完毕后，主从节点之间会保持长连接。如果连接没有断开或者&lt;code&gt;slave_repl_offset&lt;/code&gt;仍然在&lt;code&gt;repl_backlog_buffer&lt;/code&gt;中，则将后续的写操作传递给从节点，让数据保持一致。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;【全量复制细节】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;全量复制的过程是基于TCP长连接的，主要流程如下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从节点发送&lt;code&gt;psync ? -1&lt;/code&gt;表示需要建立连接进行同步，主节点返回主节点ID &lt;code&gt;runid&lt;/code&gt; 和 复制进度&lt;code&gt;offset&lt;/code&gt; (第一次同步用 -1 表示)。从节点接受之后，保存主节点的信息。&lt;/li&gt;
&lt;li&gt;主节点执行&lt;code&gt;bgsave&lt;/code&gt;命令生成数据快照RDB文件，然后将RDB文件发送给从节点。从节点接受文件后，清除现有的所有数据，然后加载RDB文件&lt;/li&gt;
&lt;li&gt;如果在制作数据快照RDB文件的过程当中，主节点接收到了新的写操作，主节点会将其记录在&lt;code&gt;repl buffer&lt;/code&gt; 里面。然后将&lt;code&gt;repl buffer&lt;/code&gt;当中的写操作发给从节点，让其数据保持一致。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt=&#34;Redis主从全量复制&#34; loading=&#34;lazy&#34; src=&#34;https://oss.swimmingliu.cn/ac630d4c-ef8d-11ef-a882-c858c0c1deba&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【增量复制细节】&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果主从节点意外断开连接，为了保持数据的一致性，必须重新同步数据。如果使用全量复制来保持一致性的话，开销太大，所以采用增量复制。&lt;/p&gt;
&lt;p&gt;增量复制的具体流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;连接恢复后，从节点会发送&lt;code&gt;psync {runid} {offset}&lt;/code&gt;， 其中主节点ID &lt;code&gt;runid&lt;/code&gt; 和 复制进度&lt;code&gt;offset&lt;/code&gt;用于标识是哪一个服务器主机和复制进度。&lt;/li&gt;
&lt;li&gt;主节点收到&lt;code&gt;psync&lt;/code&gt; 命令之后，会用&lt;code&gt;conitnue&lt;/code&gt;响应告知从节点，采用增量复制同步数据&lt;/li&gt;
&lt;li&gt;最后，主节点根据&lt;code&gt;offset&lt;/code&gt;查找对应的进度，将断线期间未同步的写命令，发送给从节点。同时，主节点将所有的写命令写入&lt;code&gt;repl_backlog_buffer&lt;/code&gt;， 用于后续判断是采用增量复制还是全量复制。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;【注意】从节点 &lt;code&gt;psync&lt;/code&gt; 携带的 &lt;code&gt;offset&lt;/code&gt; 为 &lt;code&gt;slave_repl_offset&lt;/code&gt;。如果 &lt;code&gt;repl_backlog_buffer&lt;/code&gt;包含&lt;code&gt;slave_repl_offset&lt;/code&gt; 对应的部分，则采用增量复制，否则采用全量复制。&lt;code&gt;repl_backlog_buffer&lt;/code&gt;的默认缓冲区大小为&lt;code&gt;1M&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;Redis主从增量复制&#34; loading=&#34;lazy&#34; src=&#34;https://oss.swimmingliu.cn/ac9f21a3-ef8d-11ef-9016-c858c0c1deba&#34;&gt;&lt;/p&gt;
&lt;p&gt;【&lt;strong&gt;为什么要主从复制&lt;/strong&gt;】&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;备份数据&lt;/strong&gt;：主从复制实现了数据的热备份，是持久化之外的数据冗余方式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;故障恢复&lt;/strong&gt;：当主节点宕机之后，可以采用从节点提供服务。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;:  主从复制实现了读写分离，只有主节点支持读写操作，从节点只有读操作。在读多写少的场景下，可以提高Redis服务器的并发量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;Redis主从读写分离&#34; loading=&#34;lazy&#34; src=&#34;https://oss.swimmingliu.cn/acad0d12-ef8d-11ef-b17f-c858c0c1deba&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;2-redis集群的实现原理是什么&#34;&gt;2. Redis集群的实现原理是什么?&lt;/h2&gt;
&lt;p&gt;【&lt;strong&gt;Redis集群基本知识&lt;/strong&gt;】&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;: Redis集群由多个实例组成，每个实例存储部分数据 (每个实例之间的数据不重复) 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;【注】集群和主从节点不是一个东西，集群的某一个实例当中可能包含一个主节点 + 多个从节点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;为什么用&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;问题&lt;/th&gt;
          &lt;th&gt;解决方案&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;容量不足&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;数据分片，将数据分散不存到不同的主节点&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;高并发写入&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;数据分片，将写入请求分摊到多个主节点&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;主机宕机问题&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;自动切换主从节点，避免影响服务， 不需要手动修改客户端配置&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;节点通信协议&lt;/strong&gt;：Redis集群采用Gossip协议, 支持分布式信息传播、延迟低、效率高。采用去中心化思想，任意实例(主节点)都可以作为请求入口，节点间相互通信。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分片原理&lt;/strong&gt;： 采用哈希槽(Hash Slot)机制来分配数据，整个空间可以划分为&lt;strong&gt;16384&lt;/strong&gt; (16 * 1024)个槽。 每个Redis负责一定范围的哈希槽,数据的key经过哈希函数计算之后对&lt;strong&gt;16384&lt;/strong&gt;取余可定位到对应的节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;Redis集群架构图&#34; loading=&#34;lazy&#34; src=&#34;https://oss.swimmingliu.cn/acc54635-ef8d-11ef-971e-c858c0c1deba&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java集合面试题笔记</title>
      <link>https://swimmingliu.cn/posts/job/java-set-interview-questions/</link>
      <pubDate>Thu, 20 Feb 2025 21:20:50 +0800</pubDate>
      <guid>https://swimmingliu.cn/posts/job/java-set-interview-questions/</guid>
      <description>&lt;h2 id=&#34;1-说说-java-中-hashmap-的原理&#34;&gt;1. 说说 Java 中 HashMap 的原理？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;【HashMap定义】&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;结构：数组 + 链表 + 红黑树 (&lt;code&gt;JDK 1.8&lt;/code&gt; 之后)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;默认值：初始容量为16 (数组长度)，负载因子为 0.75。当存储的元素为 16 * 0.75 = 12个时，会触发&lt;code&gt;Resize()&lt;/code&gt; 扩容操作，容量 x 2 并重新分配位置。但是扩容是有一定开销的，频繁扩容会影响性能。另外，&lt;code&gt;TREEIFY_THRESHOLD&lt;/code&gt; 转换为红黑树的默认链表长度阈值为 8, &lt;code&gt;UNTREEIFY_THRESHOLD&lt;/code&gt; 从红黑树转换为链表的阈值为 6。 两个阈值采用不同值的原因是防止刚转换为红黑树，又变成链表，反复横跳，消耗资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数组下标位置计算方法：首先使用key的&lt;code&gt;hashCode()&lt;/code&gt;方法计算下标位置，然后通过  &lt;code&gt;indexFor()&lt;/code&gt; (&lt;code&gt;JDK 1.7&lt;/code&gt; 以前) 计算下标值。 &lt;code&gt;JDK 1.7&lt;/code&gt;后，为了提高计算效率采用 &lt;code&gt;(len - 1) &amp;amp; hash&lt;/code&gt; 来确定下标值。&lt;/p&gt;
&lt;p&gt;【注】数组的长度&lt;code&gt;len&lt;/code&gt; 是2的幂次方时，&lt;code&gt;(len - 1) &amp;amp; hash&lt;/code&gt; 等价于 &lt;code&gt;hash % len&lt;/code&gt;。 这也是为什么数组长度必须是2的幂次方。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt=&#34;HashMap底层结构&#34; loading=&#34;lazy&#34; src=&#34;https://oss.swimmingliu.cn/65f25922-ef8d-11ef-827a-c858c0c1deba&#34;&gt;&lt;/p&gt;
&lt;p&gt;【&lt;strong&gt;HashMap线程不安全&lt;/strong&gt;】&lt;/p&gt;
&lt;p&gt;为了保证HashMap的读写效率高，它的操作是非同步的，也就是说读写操作没有锁保护。所以多线程场景下是线程不安全的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;【HashMap不同版本区别】&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JDK 1.7: 数组 + 链表，链表部分采用头插法，多线程会导致出现环形链表。扩容会计算每个元素hash值，并分配到新的位置，开销大。&lt;/li&gt;
&lt;li&gt;JDK 1.8：数组 + 链表 + 红黑树，采用高低位置来分配位置，即判断&lt;code&gt;(e.hash &amp;amp; oldCap) == 0&lt;/code&gt;， 减少了计算hash的次数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;【HashMap的PUT方法】&lt;/strong&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java基础题面试笔记</title>
      <link>https://swimmingliu.cn/posts/job/java-basic-interview-questions/</link>
      <pubDate>Wed, 19 Feb 2025 15:18:58 +0800</pubDate>
      <guid>https://swimmingliu.cn/posts/job/java-basic-interview-questions/</guid>
      <description>&lt;h2 id=&#34;1-序列化和反序列化&#34;&gt;1. 序列化和反序列化&lt;/h2&gt;
&lt;p&gt;1.序列化和反序列化：把对象转换为字节流，用于存储和传输；读取字节流数据，重新创建对象。
2.序列化不包括静态对象：序列化和反序列化的本质是调用对象的&lt;code&gt;writeObject&lt;/code&gt;和&lt;code&gt;readObject&lt;/code&gt;方法,来实现将对象写入输出流和读取输入流。但是，静态变量不属于对象，所以调用这两个方法就没法儿让静态变量参与。&lt;/p&gt;
&lt;h2 id=&#34;2-什么是不可变类&#34;&gt;2. 什么是不可变类？&lt;/h2&gt;
&lt;p&gt;1.不可变类：初始化之后，就不能修改的类。
2.修饰方法：final 和 private 修饰所有类和变量
3.不可修改：不暴露set方法，只能通过重新创建对象替代修改功能(&lt;code&gt;String&lt;/code&gt;的replace方法)
4.优缺点：
优点：线程安全，缓存友好
缺点：频繁拼接和修改会浪费资源&lt;/p&gt;
&lt;h2 id=&#34;3-exception和error区别&#34;&gt;3. Exception和Error区别?&lt;/h2&gt;
&lt;p&gt;1.Exception和Error定义区别：Exception是可处理程序异常，Error是系统级不可回复错误
2.try-catch建议：
1.范围能小则小
2.Exception最好要写清楚具体是哪一个Exception(IOException)
3.null值等能用if判断的，不要用try-catch,因为异常比条件语句低效
4.finally不要直接return和处理返回值&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;Exception和Error区别&#34; loading=&#34;lazy&#34; src=&#34;https://oss.swimmingliu.cn/946b73cc-ef5d-11ef-95ab-c858c0c1deba&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;4-java-中的-hashcode-和-equals-方法之间有什么关系&#34;&gt;4. Java 中的 hashCode 和 equals 方法之间有什么关系？&lt;/h2&gt;
&lt;p&gt;1、&lt;code&gt;equals()&lt;/code&gt; 和 &lt;code&gt;hashCode()&lt;/code&gt; 的关系&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果两个对象&lt;code&gt;euqals()&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt;， 则其 &lt;code&gt;hashCode()&lt;/code&gt;一定相同&lt;/li&gt;
&lt;li&gt;如果两个对象&lt;code&gt;hashCode()&lt;/code&gt; 相同，其&lt;code&gt;equals()&lt;/code&gt;结果不一定为&lt;code&gt;true&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2、为什么重写&lt;code&gt;equals()&lt;/code&gt;之后，一定要重写&lt;code&gt;hashCode()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当重写&lt;code&gt;equals()&lt;/code&gt; 之后，通常是重新定义了两个对象相等的逻辑。如果不重写&lt;code&gt;hashCode()&lt;/code&gt;方法， 则在散列集合（&lt;code&gt;HashMap&lt;/code&gt; 和 &lt;code&gt;HashSet&lt;/code&gt;）中，可能无法正确存储和检索，因为两个相同的对象可能有不同的&lt;code&gt;hash&lt;/code&gt;值。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例如，下方Person类重写了&lt;code&gt;equals()&lt;/code&gt; 方法，但是没有重新&lt;code&gt;hashCode()&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Java&#34; data-lang=&#34;Java&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;age&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;equals&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;||&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getClass&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getClass&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;person&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;age&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;age&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Objects&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equals&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;创建相同的对象，并添加到&lt;code&gt;HashSet&lt;/code&gt;中&lt;/p&gt;</description>
    </item>
    <item>
      <title>MySQL面试题笔记</title>
      <link>https://swimmingliu.cn/posts/job/mysql-interview-questions/</link>
      <pubDate>Wed, 19 Feb 2025 15:16:42 +0800</pubDate>
      <guid>https://swimmingliu.cn/posts/job/mysql-interview-questions/</guid>
      <description>&lt;h2 id=&#34;1mysql-中的数据排序是怎么实现的&#34;&gt;1.MySQL 中的数据排序是怎么实现的？&lt;/h2&gt;
&lt;p&gt;1.&lt;strong&gt;排序方法&lt;/strong&gt;：索引排序和文件排序 (filesort)&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;索引排序&lt;/strong&gt;：如果&lt;code&gt;order by xxx&lt;/code&gt;的字段为索引字段，则利用索引进行排序。效率最高，索引默认有序。&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;文件排序 (filesort)&lt;/strong&gt;：内存排序(单路排序和双路排序)和磁盘排序，具体取决于排序数据的大小。其中，内存排序使用单路排序或双路排序，取决于&lt;code&gt;max_length_for_sort_data&lt;/code&gt;(默认为4096个字节)&lt;/p&gt;
&lt;p&gt;4.&lt;strong&gt;双路排序&lt;/strong&gt;：取&lt;code&gt;row_id&lt;/code&gt;(如果有主键，则为主键)和&lt;code&gt;select a,b,c order by xxx&lt;/code&gt;的&lt;code&gt;xxx&lt;/code&gt;字段放入&lt;code&gt;sort_buffer&lt;/code&gt;(排序缓存)中，将排序后的&lt;code&gt;row_id&lt;/code&gt;回表查询&lt;code&gt;a,b,c&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;5.&lt;strong&gt;单路排序&lt;/strong&gt;: 直接把要查的所有字段放入&lt;code&gt;sort_buffer&lt;/code&gt;里，排序后直接得到结果集合&lt;/p&gt;
&lt;p&gt;6.&lt;strong&gt;磁盘排序&lt;/strong&gt;（归并排序）:将数据分为多份文件，单独对文件进行排序，然后合并成一个有序的大文件&lt;/p&gt;
&lt;h2 id=&#34;2-mysql-的-change-buffer-是什么它有什么作用&#34;&gt;2. MySQL 的 Change Buffer 是什么？它有什么作用？&lt;/h2&gt;
&lt;p&gt;1.ChangeBuffer定义：Change Buffer是InnoDB缓冲当中的一块缓存区，用于暂存二级索引的修改，避免二级索引页修改产生的随机IO
2.ChangeBuffer注意事项：只能用于二级索引，不能用于其他任何索引，包括主键索引和唯一索引都不行。
3.如果ChangeBuffer挂了，更改操作未执行，是否会出现脏数据？
首先，ChangeBuffer也会保存在磁盘空间里面，redo log会记录Change Buffer当中的修改操作，确保数据一致性。&lt;/p&gt;
&lt;p&gt;知识拓展1：一级索引和二级索引区别&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;一级索引（聚簇索引）&lt;/strong&gt;：数据表的主键索引，数据和索引存储在同一B+树的叶子节点中。每个表只能有一个一级索引。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二级索引（非聚簇索引）&lt;/strong&gt;：除主键外的其他索引，叶子节点存储索引列的值和对应的主键值。通过二级索引查询时，需要先通过二级索引获取主键值，再通过主键值查询数据，这个过程称为“回表”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;知识拓展2:  MySQL中有哪些常见索引？都有什么区别？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在MySQL中，索引是提高查询效率的关键工具。常见的索引类型包括主键索引、唯一索引、普通索引、全文索引和空间索引。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 主键索引（Primary Key Index）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：主键索引是一种特殊的唯一索引，用于唯一标识表中的每一行数据。每个表只能有一个主键索引，且主键列的值不能为空。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：主键索引的叶子节点存储完整的数据行，因此查询效率高。在InnoDB存储引擎中，主键索引是聚簇索引，数据存储与索引结构合并。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. 唯一索引（Unique Index）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：唯一索引确保索引列的每个值都是唯一的，但允许有空值。与主键索引类似，不同之处在于唯一索引允许列值为NULL。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：唯一索引的叶子节点存储索引列的值和对应的主键值。在InnoDB中，唯一索引是非聚簇索引，数据存储与索引结构分开。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3. 普通索引（Index）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：普通索引是最基本的索引类型，没有任何限制。索引列的值可以重复，也可以为NULL。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：普通索引的叶子节点存储索引列的值和对应的主键值。在InnoDB中，普通索引是非聚簇索引，数据存储与索引结构分开。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4. 全文索引（Fulltext Index）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：全文索引用于对文本数据进行全文搜索，适用于MyISAM存储引擎。它允许对文本字段进行复杂的搜索，如查找包含特定单词的记录。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：全文索引的叶子节点存储文档的词项信息。在MyISAM中，全文索引是非聚簇索引，数据存储与索引结构分开。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;5. 空间索引（Spatial Index）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;：空间索引用于对地理空间数据进行索引，支持空间数据类型的快速查询。它适用于存储地理位置、地图等空间数据的表。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：空间索引的叶子节点存储空间数据的索引信息。在MyISAM中，空间索引是非聚簇索引，数据存储与索引结构分开。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;主键索引&lt;/strong&gt;：用于唯一标识每一行数据，值不能为空。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;唯一索引&lt;/strong&gt;：确保索引列的值唯一，但允许有空值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;普通索引&lt;/strong&gt;：最基本的索引类型，允许重复和空值。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;全文索引&lt;/strong&gt;：用于对文本数据进行全文搜索，适用于MyISAM存储引擎。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空间索引&lt;/strong&gt;：用于对地理空间数据进行索引，支持空间数据类型的快速查询。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;3-详细描述一条-sql-语句在-mysql-中的执行过程&#34;&gt;3. 详细描述一条 SQL 语句在 MySQL 中的执行过程。&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;连接器判断用户是否成功建立连接，数据库连接的权限校验&lt;/li&gt;
&lt;li&gt;连接器会查询缓存，&lt;code&gt;key&lt;/code&gt; 是 SQL 语句，&lt;code&gt;value&lt;/code&gt; 是查询结果。如果命中，直接返回查询结果。(MySQL 8.0之后，就移除这个功能了)。&lt;/li&gt;
&lt;li&gt;分析器分析SQL语法和词法是否有误&lt;/li&gt;
&lt;li&gt;优化器生成SQL的执行计划，确定使用的索引和调整where的执行顺序（包括连表顺序）&lt;/li&gt;
&lt;li&gt;执行器判断当前用户是否有权限查询该表，然后执行该SQL语句&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt=&#34;MySQL架构图&#34; loading=&#34;lazy&#34; src=&#34;https://oss.swimmingliu.cn/7457976c-ef5d-11ef-b738-c858c0c1deba&#34;&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Java面试题-随手记</title>
      <link>https://swimmingliu.cn/posts/job/java-interview-questions-notes/</link>
      <pubDate>Fri, 27 Dec 2024 17:27:35 +0800</pubDate>
      <guid>https://swimmingliu.cn/posts/job/java-interview-questions-notes/</guid>
      <description>&lt;h2 id=&#34;-和-equals-区别&#34;&gt;== 和 equals 区别&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;==&lt;/code&gt; 基本类型(int, long, float, char, boolean) 值比较， 引用类型(String，List) 进行地址比较&lt;/p&gt;
&lt;p&gt;&lt;code&gt;equals&lt;/code&gt; 默认就是 &lt;code&gt;==&lt;/code&gt; ，但是部分引用类型(String，List)重写了该方法，进行值比较&lt;/p&gt;
&lt;h2 id=&#34;get-和-post-区别&#34;&gt;get 和 post 区别&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;特性&lt;/th&gt;
          &lt;th&gt;GET&lt;/th&gt;
          &lt;th&gt;POST&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;目的&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;获取资源，查询数据&lt;/td&gt;
          &lt;td&gt;提交数据，创建或更新资源&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;请求数据方式&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;参数通过 URL 查询字符串传递&lt;/td&gt;
          &lt;td&gt;数据通过请求体传递&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;数据暴露&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;数据暴露在 URL 中，较不安全&lt;/td&gt;
          &lt;td&gt;数据存储在请求体中，相对安全&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;数据大小限制&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;URL 长度有限制（约 2048 个字符）&lt;/td&gt;
          &lt;td&gt;没有数据大小限制&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;适用场景&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;获取数据，查询，展示资源&lt;/td&gt;
          &lt;td&gt;提交表单，上传文件，修改资源，发送敏感数据等&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;springmvc中reponsebodypathvariablerequestparameters在什么情况下使用&#34;&gt;SpringMVC中@ReponseBody、@PathVariable、@RequestParameters在什么情况下使用?&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;@ReponseBody&lt;/code&gt; 用于接受请求体数据，一般用于POST请求&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@PathVariable&lt;/code&gt; 用于接受路径参数，一般用户接受 &lt;code&gt;id&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@RequestParameters&lt;/code&gt; 用于接受请求参数，一般用于GET请求&lt;/p&gt;
&lt;h2 id=&#34;jvm堆的结构gc介绍和作用&#34;&gt;JVM堆的结构、GC介绍和作用&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.51cto.com/article/710705.html&#34;&gt;JVM堆结构的参考文章&lt;/a&gt; 、 &lt;a href=&#34;https://www.bilibili.com/video/BV1dt411u7wi&#34;&gt;GC垃圾回收过程&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;区域&lt;/th&gt;
          &lt;th&gt;主要用途&lt;/th&gt;
          &lt;th&gt;特点&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;新生代（Young Generation）&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;存储新创建的对象，快速垃圾回收&lt;/td&gt;
          &lt;td&gt;包含 Eden 区和两个 Survivor 区，采用复制算法进行回收&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;老年代（Old Generation）&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;存储长期存活的对象&lt;/td&gt;
          &lt;td&gt;回收频率较低，垃圾回收较耗时&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;永久代（Permanent Generation) (jdk 1.7）&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;存储类的元数据、方法字节码等&lt;/td&gt;
          &lt;td&gt;在 jdk 1.8 被 Metaspace 替代&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;strong&gt;元空间（jdk 1.8）&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;存储类的元数据&lt;/td&gt;
          &lt;td&gt;不再属于堆，使用本地内存，大小由系统限制&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;GC&lt;/code&gt; 是垃圾回收器， 作用是自动内存管理和避免内存泄漏&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
